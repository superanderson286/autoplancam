"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/better-call";
exports.ids = ["vendor-chunks/better-call"];
exports.modules = {

/***/ "(rsc)/./node_modules/better-call/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/better-call/dist/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIError: () => (/* binding */ APIError),\n/* harmony export */   _statusCode: () => (/* binding */ _statusCode),\n/* harmony export */   createEndpoint: () => (/* binding */ createEndpoint2),\n/* harmony export */   createInternalContext: () => (/* binding */ createInternalContext),\n/* harmony export */   createMiddleware: () => (/* binding */ createMiddleware),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   generator: () => (/* binding */ generator),\n/* harmony export */   getCookieKey: () => (/* binding */ getCookieKey),\n/* harmony export */   getHTML: () => (/* binding */ getHTML),\n/* harmony export */   hideInternalStackFrames: () => (/* binding */ hideInternalStackFrames),\n/* harmony export */   makeErrorForHideStackFrame: () => (/* binding */ makeErrorForHideStackFrame),\n/* harmony export */   parseCookies: () => (/* binding */ parseCookies),\n/* harmony export */   serializeCookie: () => (/* binding */ serializeCookie),\n/* harmony export */   serializeSignedCookie: () => (/* binding */ serializeSignedCookie),\n/* harmony export */   toResponse: () => (/* binding */ toResponse)\n/* harmony export */ });\n/* harmony import */ var _better_auth_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @better-auth/utils */ \"(rsc)/./node_modules/@better-auth/utils/dist/index.mjs\");\n/* harmony import */ var rou3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rou3 */ \"(rsc)/./node_modules/rou3/dist/index.mjs\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/error.ts\nfunction isErrorStackTraceLimitWritable() {\n  const desc = Object.getOwnPropertyDescriptor(Error, \"stackTraceLimit\");\n  if (desc === void 0) {\n    return Object.isExtensible(Error);\n  }\n  return Object.prototype.hasOwnProperty.call(desc, \"writable\") ? desc.writable : desc.set !== void 0;\n}\nfunction hideInternalStackFrames(stack) {\n  const lines = stack.split(\"\\n    at \");\n  if (lines.length <= 1) {\n    return stack;\n  }\n  lines.splice(1, 1);\n  return lines.join(\"\\n    at \");\n}\nfunction makeErrorForHideStackFrame(Base, clazz) {\n  class HideStackFramesError extends Base {\n    #hiddenStack;\n    constructor(...args) {\n      if (isErrorStackTraceLimitWritable()) {\n        const limit = Error.stackTraceLimit;\n        Error.stackTraceLimit = 0;\n        super(...args);\n        Error.stackTraceLimit = limit;\n      } else {\n        super(...args);\n      }\n      const stack = new Error().stack;\n      if (stack) {\n        this.#hiddenStack = hideInternalStackFrames(stack.replace(/^Error/, this.name));\n      }\n    }\n    // use `getter` here to avoid the stack trace being captured by loggers\n    get errorStack() {\n      return this.#hiddenStack;\n    }\n  }\n  Object.defineProperty(HideStackFramesError.prototype, \"constructor\", {\n    get() {\n      return clazz;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return HideStackFramesError;\n}\nvar _statusCode = {\n  OK: 200,\n  CREATED: 201,\n  ACCEPTED: 202,\n  NO_CONTENT: 204,\n  MULTIPLE_CHOICES: 300,\n  MOVED_PERMANENTLY: 301,\n  FOUND: 302,\n  SEE_OTHER: 303,\n  NOT_MODIFIED: 304,\n  TEMPORARY_REDIRECT: 307,\n  BAD_REQUEST: 400,\n  UNAUTHORIZED: 401,\n  PAYMENT_REQUIRED: 402,\n  FORBIDDEN: 403,\n  NOT_FOUND: 404,\n  METHOD_NOT_ALLOWED: 405,\n  NOT_ACCEPTABLE: 406,\n  PROXY_AUTHENTICATION_REQUIRED: 407,\n  REQUEST_TIMEOUT: 408,\n  CONFLICT: 409,\n  GONE: 410,\n  LENGTH_REQUIRED: 411,\n  PRECONDITION_FAILED: 412,\n  PAYLOAD_TOO_LARGE: 413,\n  URI_TOO_LONG: 414,\n  UNSUPPORTED_MEDIA_TYPE: 415,\n  RANGE_NOT_SATISFIABLE: 416,\n  EXPECTATION_FAILED: 417,\n  \"I'M_A_TEAPOT\": 418,\n  MISDIRECTED_REQUEST: 421,\n  UNPROCESSABLE_ENTITY: 422,\n  LOCKED: 423,\n  FAILED_DEPENDENCY: 424,\n  TOO_EARLY: 425,\n  UPGRADE_REQUIRED: 426,\n  PRECONDITION_REQUIRED: 428,\n  TOO_MANY_REQUESTS: 429,\n  REQUEST_HEADER_FIELDS_TOO_LARGE: 431,\n  UNAVAILABLE_FOR_LEGAL_REASONS: 451,\n  INTERNAL_SERVER_ERROR: 500,\n  NOT_IMPLEMENTED: 501,\n  BAD_GATEWAY: 502,\n  SERVICE_UNAVAILABLE: 503,\n  GATEWAY_TIMEOUT: 504,\n  HTTP_VERSION_NOT_SUPPORTED: 505,\n  VARIANT_ALSO_NEGOTIATES: 506,\n  INSUFFICIENT_STORAGE: 507,\n  LOOP_DETECTED: 508,\n  NOT_EXTENDED: 510,\n  NETWORK_AUTHENTICATION_REQUIRED: 511\n};\nvar InternalAPIError = class extends Error {\n  constructor(status = \"INTERNAL_SERVER_ERROR\", body = void 0, headers = {}, statusCode = typeof status === \"number\" ? status : _statusCode[status]) {\n    super(\n      body?.message,\n      body?.cause ? {\n        cause: body.cause\n      } : void 0\n    );\n    this.status = status;\n    this.body = body;\n    this.headers = headers;\n    this.statusCode = statusCode;\n    this.name = \"APIError\";\n    this.status = status;\n    this.headers = headers;\n    this.statusCode = statusCode;\n    this.body = body ? {\n      code: body?.message?.toUpperCase().replace(/ /g, \"_\").replace(/[^A-Z0-9_]/g, \"\"),\n      ...body\n    } : void 0;\n  }\n};\nvar APIError = makeErrorForHideStackFrame(InternalAPIError, Error);\n\n// src/utils.ts\nasync function getBody(request) {\n  const contentType = request.headers.get(\"content-type\") || \"\";\n  if (!request.body) {\n    return void 0;\n  }\n  if (contentType.includes(\"application/json\")) {\n    return await request.json();\n  }\n  if (contentType.includes(\"application/x-www-form-urlencoded\")) {\n    const formData = await request.formData();\n    const result = {};\n    formData.forEach((value, key) => {\n      result[key] = value.toString();\n    });\n    return result;\n  }\n  if (contentType.includes(\"multipart/form-data\")) {\n    const formData = await request.formData();\n    const result = {};\n    formData.forEach((value, key) => {\n      result[key] = value;\n    });\n    return result;\n  }\n  if (contentType.includes(\"text/plain\")) {\n    return await request.text();\n  }\n  if (contentType.includes(\"application/octet-stream\")) {\n    return await request.arrayBuffer();\n  }\n  if (contentType.includes(\"application/pdf\") || contentType.includes(\"image/\") || contentType.includes(\"video/\")) {\n    const blob = await request.blob();\n    return blob;\n  }\n  if (contentType.includes(\"application/stream\") || request.body instanceof ReadableStream) {\n    return request.body;\n  }\n  return await request.text();\n}\nfunction isAPIError(error) {\n  return error instanceof APIError || error?.name === \"APIError\";\n}\nfunction tryDecode(str) {\n  try {\n    return str.includes(\"%\") ? decodeURIComponent(str) : str;\n  } catch {\n    return str;\n  }\n}\n\n// src/to-response.ts\nfunction isJSONSerializable(value) {\n  if (value === void 0) {\n    return false;\n  }\n  const t = typeof value;\n  if (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) {\n    return true;\n  }\n  if (t !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return true;\n  }\n  if (value.buffer) {\n    return false;\n  }\n  return value.constructor && value.constructor.name === \"Object\" || typeof value.toJSON === \"function\";\n}\nfunction safeStringify(obj, replacer, space) {\n  let id = 0;\n  const seen = /* @__PURE__ */ new WeakMap();\n  const safeReplacer = (key, value) => {\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n    if (typeof value === \"object\" && value !== null) {\n      if (seen.has(value)) {\n        return `[Circular ref-${seen.get(value)}]`;\n      }\n      seen.set(value, id++);\n    }\n    if (replacer) {\n      return replacer(key, value);\n    }\n    return value;\n  };\n  return JSON.stringify(obj, safeReplacer, space);\n}\nfunction isJSONResponse(value) {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n  return \"_flag\" in value && value._flag === \"json\";\n}\nfunction toResponse(data, init) {\n  if (data instanceof Response) {\n    if (init?.headers instanceof Headers) {\n      init.headers.forEach((value, key) => {\n        data.headers.set(key, value);\n      });\n    }\n    return data;\n  }\n  const isJSON = isJSONResponse(data);\n  if (isJSON) {\n    const body2 = data.body;\n    const routerResponse = data.routerResponse;\n    if (routerResponse instanceof Response) {\n      return routerResponse;\n    }\n    const headers2 = new Headers({\n      ...routerResponse?.headers,\n      ...data.headers,\n      ...init?.headers,\n      \"Content-Type\": \"application/json\"\n    });\n    return new Response(JSON.stringify(body2), {\n      ...routerResponse,\n      headers: headers2,\n      status: data.status ?? init?.status ?? routerResponse?.status,\n      statusText: init?.statusText ?? routerResponse?.statusText\n    });\n  }\n  if (isAPIError(data)) {\n    return toResponse(data.body, {\n      status: init?.status ?? data.statusCode,\n      statusText: data.status.toString(),\n      headers: init?.headers || data.headers\n    });\n  }\n  let body = data;\n  let headers = new Headers(init?.headers);\n  if (!data) {\n    if (data === null) {\n      body = JSON.stringify(null);\n    }\n    headers.set(\"content-type\", \"application/json\");\n  } else if (typeof data === \"string\") {\n    body = data;\n    headers.set(\"Content-Type\", \"text/plain\");\n  } else if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {\n    body = data;\n    headers.set(\"Content-Type\", \"application/octet-stream\");\n  } else if (data instanceof Blob) {\n    body = data;\n    headers.set(\"Content-Type\", data.type || \"application/octet-stream\");\n  } else if (data instanceof FormData) {\n    body = data;\n  } else if (data instanceof URLSearchParams) {\n    body = data;\n    headers.set(\"Content-Type\", \"application/x-www-form-urlencoded\");\n  } else if (data instanceof ReadableStream) {\n    body = data;\n    headers.set(\"Content-Type\", \"application/octet-stream\");\n  } else if (isJSONSerializable(data)) {\n    body = safeStringify(data);\n    headers.set(\"Content-Type\", \"application/json\");\n  }\n  return new Response(body, {\n    ...init,\n    headers\n  });\n}\n\n// src/validator.ts\nasync function runValidation(options, context = {}) {\n  let request = {\n    body: context.body,\n    query: context.query\n  };\n  if (options.body) {\n    const result = await options.body[\"~standard\"].validate(context.body);\n    if (result.issues) {\n      return {\n        data: null,\n        error: fromError(result.issues, \"body\")\n      };\n    }\n    request.body = result.value;\n  }\n  if (options.query) {\n    const result = await options.query[\"~standard\"].validate(context.query);\n    if (result.issues) {\n      return {\n        data: null,\n        error: fromError(result.issues, \"query\")\n      };\n    }\n    request.query = result.value;\n  }\n  if (options.requireHeaders && !context.headers) {\n    return {\n      data: null,\n      error: { message: \"Headers is required\" }\n    };\n  }\n  if (options.requireRequest && !context.request) {\n    return {\n      data: null,\n      error: { message: \"Request is required\" }\n    };\n  }\n  return {\n    data: request,\n    error: null\n  };\n}\nfunction fromError(error, validating) {\n  const errorMessages = [];\n  for (const issue2 of error) {\n    const message = issue2.message;\n    errorMessages.push(message);\n  }\n  return {\n    message: `Invalid ${validating} parameters`\n  };\n}\n\n// src/crypto.ts\n\nvar algorithm = { name: \"HMAC\", hash: \"SHA-256\" };\nvar getCryptoKey = async (secret) => {\n  const secretBuf = typeof secret === \"string\" ? new TextEncoder().encode(secret) : secret;\n  return await (0,_better_auth_utils__WEBPACK_IMPORTED_MODULE_0__.getWebcryptoSubtle)().importKey(\"raw\", secretBuf, algorithm, false, [\n    \"sign\",\n    \"verify\"\n  ]);\n};\nvar verifySignature = async (base64Signature, value, secret) => {\n  try {\n    const signatureBinStr = atob(base64Signature);\n    const signature = new Uint8Array(signatureBinStr.length);\n    for (let i = 0, len = signatureBinStr.length; i < len; i++) {\n      signature[i] = signatureBinStr.charCodeAt(i);\n    }\n    return await (0,_better_auth_utils__WEBPACK_IMPORTED_MODULE_0__.getWebcryptoSubtle)().verify(\n      algorithm,\n      secret,\n      signature,\n      new TextEncoder().encode(value)\n    );\n  } catch (e) {\n    return false;\n  }\n};\nvar makeSignature = async (value, secret) => {\n  const key = await getCryptoKey(secret);\n  const signature = await (0,_better_auth_utils__WEBPACK_IMPORTED_MODULE_0__.getWebcryptoSubtle)().sign(\n    algorithm.name,\n    key,\n    new TextEncoder().encode(value)\n  );\n  return btoa(String.fromCharCode(...new Uint8Array(signature)));\n};\nvar signCookieValue = async (value, secret) => {\n  const signature = await makeSignature(value, secret);\n  value = `${value}.${signature}`;\n  value = encodeURIComponent(value);\n  return value;\n};\n\n// src/cookies.ts\nvar getCookieKey = (key, prefix) => {\n  let finalKey = key;\n  if (prefix) {\n    if (prefix === \"secure\") {\n      finalKey = \"__Secure-\" + key;\n    } else if (prefix === \"host\") {\n      finalKey = \"__Host-\" + key;\n    } else {\n      return void 0;\n    }\n  }\n  return finalKey;\n};\nfunction parseCookies(str) {\n  if (typeof str !== \"string\") {\n    throw new TypeError(\"argument str must be a string\");\n  }\n  const cookies = /* @__PURE__ */ new Map();\n  let index = 0;\n  while (index < str.length) {\n    const eqIdx = str.indexOf(\"=\", index);\n    if (eqIdx === -1) {\n      break;\n    }\n    let endIdx = str.indexOf(\";\", index);\n    if (endIdx === -1) {\n      endIdx = str.length;\n    } else if (endIdx < eqIdx) {\n      index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n      continue;\n    }\n    const key = str.slice(index, eqIdx).trim();\n    if (!cookies.has(key)) {\n      let val = str.slice(eqIdx + 1, endIdx).trim();\n      if (val.codePointAt(0) === 34) {\n        val = val.slice(1, -1);\n      }\n      cookies.set(key, tryDecode(val));\n    }\n    index = endIdx + 1;\n  }\n  return cookies;\n}\nvar _serialize = (key, value, opt = {}) => {\n  let cookie;\n  if (opt?.prefix === \"secure\") {\n    cookie = `${`__Secure-${key}`}=${value}`;\n  } else if (opt?.prefix === \"host\") {\n    cookie = `${`__Host-${key}`}=${value}`;\n  } else {\n    cookie = `${key}=${value}`;\n  }\n  if (key.startsWith(\"__Secure-\") && !opt.secure) {\n    opt.secure = true;\n  }\n  if (key.startsWith(\"__Host-\")) {\n    if (!opt.secure) {\n      opt.secure = true;\n    }\n    if (opt.path !== \"/\") {\n      opt.path = \"/\";\n    }\n    if (opt.domain) {\n      opt.domain = void 0;\n    }\n  }\n  if (opt && typeof opt.maxAge === \"number\" && opt.maxAge >= 0) {\n    if (opt.maxAge > 3456e4) {\n      throw new Error(\n        \"Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.\"\n      );\n    }\n    cookie += `; Max-Age=${Math.floor(opt.maxAge)}`;\n  }\n  if (opt.domain && opt.prefix !== \"host\") {\n    cookie += `; Domain=${opt.domain}`;\n  }\n  if (opt.path) {\n    cookie += `; Path=${opt.path}`;\n  }\n  if (opt.expires) {\n    if (opt.expires.getTime() - Date.now() > 3456e7) {\n      throw new Error(\n        \"Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.\"\n      );\n    }\n    cookie += `; Expires=${opt.expires.toUTCString()}`;\n  }\n  if (opt.httpOnly) {\n    cookie += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    cookie += \"; Secure\";\n  }\n  if (opt.sameSite) {\n    cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;\n  }\n  if (opt.partitioned) {\n    if (!opt.secure) {\n      opt.secure = true;\n    }\n    cookie += \"; Partitioned\";\n  }\n  return cookie;\n};\nvar serializeCookie = (key, value, opt) => {\n  value = encodeURIComponent(value);\n  return _serialize(key, value, opt);\n};\nvar serializeSignedCookie = async (key, value, secret, opt) => {\n  value = await signCookieValue(value, secret);\n  return _serialize(key, value, opt);\n};\n\n// src/context.ts\nvar createInternalContext = async (context, {\n  options,\n  path\n}) => {\n  const headers = new Headers();\n  const { data, error } = await runValidation(options, context);\n  if (error) {\n    throw new APIError(400, {\n      message: error.message,\n      code: \"VALIDATION_ERROR\"\n    });\n  }\n  const requestHeaders = \"headers\" in context ? context.headers instanceof Headers ? context.headers : new Headers(context.headers) : \"request\" in context && context.request instanceof Request ? context.request.headers : null;\n  const requestCookies = requestHeaders?.get(\"cookie\");\n  const parsedCookies = requestCookies ? parseCookies(requestCookies) : void 0;\n  const internalContext = {\n    ...context,\n    body: data.body,\n    query: data.query,\n    path: context.path || path,\n    context: \"context\" in context && context.context ? context.context : {},\n    returned: void 0,\n    headers: context?.headers,\n    request: context?.request,\n    params: \"params\" in context ? context.params : void 0,\n    method: context.method,\n    setHeader: (key, value) => {\n      headers.set(key, value);\n    },\n    getHeader: (key) => {\n      if (!requestHeaders) return null;\n      return requestHeaders.get(key);\n    },\n    getCookie: (key, prefix) => {\n      const finalKey = getCookieKey(key, prefix);\n      if (!finalKey) {\n        return null;\n      }\n      return parsedCookies?.get(finalKey) || null;\n    },\n    getSignedCookie: async (key, secret, prefix) => {\n      const finalKey = getCookieKey(key, prefix);\n      if (!finalKey) {\n        return null;\n      }\n      const value = parsedCookies?.get(finalKey);\n      if (!value) {\n        return null;\n      }\n      const signatureStartPos = value.lastIndexOf(\".\");\n      if (signatureStartPos < 1) {\n        return null;\n      }\n      const signedValue = value.substring(0, signatureStartPos);\n      const signature = value.substring(signatureStartPos + 1);\n      if (signature.length !== 44 || !signature.endsWith(\"=\")) {\n        return null;\n      }\n      const secretKey = await getCryptoKey(secret);\n      const isVerified = await verifySignature(signature, signedValue, secretKey);\n      return isVerified ? signedValue : false;\n    },\n    setCookie: (key, value, options2) => {\n      const cookie = serializeCookie(key, value, options2);\n      headers.append(\"set-cookie\", cookie);\n      return cookie;\n    },\n    setSignedCookie: async (key, value, secret, options2) => {\n      const cookie = await serializeSignedCookie(key, value, secret, options2);\n      headers.append(\"set-cookie\", cookie);\n      return cookie;\n    },\n    redirect: (url) => {\n      headers.set(\"location\", url);\n      return new APIError(\"FOUND\", void 0, headers);\n    },\n    error: (status, body, headers2) => {\n      return new APIError(status, body, headers2);\n    },\n    json: (json, routerResponse) => {\n      if (!context.asResponse) {\n        return json;\n      }\n      return {\n        body: routerResponse?.body || json,\n        routerResponse,\n        _flag: \"json\"\n      };\n    },\n    responseHeaders: headers\n  };\n  for (const middleware of options.use || []) {\n    const response = await middleware({\n      ...internalContext,\n      returnHeaders: true,\n      asResponse: false\n    });\n    if (response.response) {\n      Object.assign(internalContext.context, response.response);\n    }\n    if (response.headers) {\n      response.headers.forEach((value, key) => {\n        internalContext.responseHeaders.set(key, value);\n      });\n    }\n  }\n  return internalContext;\n};\n\n// src/middleware.ts\nfunction createMiddleware(optionsOrHandler, handler) {\n  const internalHandler = async (inputCtx) => {\n    const context = inputCtx;\n    const _handler = typeof optionsOrHandler === \"function\" ? optionsOrHandler : handler;\n    const options = typeof optionsOrHandler === \"function\" ? {} : optionsOrHandler;\n    const internalContext = await createInternalContext(context, {\n      options,\n      path: \"/\"\n    });\n    if (!_handler) {\n      throw new Error(\"handler must be defined\");\n    }\n    const response = await _handler(internalContext);\n    const headers = internalContext.responseHeaders;\n    return context.returnHeaders ? {\n      headers,\n      response\n    } : response;\n  };\n  internalHandler.options = typeof optionsOrHandler === \"function\" ? {} : optionsOrHandler;\n  return internalHandler;\n}\ncreateMiddleware.create = (opts) => {\n  function fn(optionsOrHandler, handler) {\n    if (typeof optionsOrHandler === \"function\") {\n      return createMiddleware(\n        {\n          use: opts?.use\n        },\n        optionsOrHandler\n      );\n    }\n    if (!handler) {\n      throw new Error(\"Middleware handler is required\");\n    }\n    const middleware = createMiddleware(\n      {\n        ...optionsOrHandler,\n        method: \"*\",\n        use: [...opts?.use || [], ...optionsOrHandler.use || []]\n      },\n      handler\n    );\n    return middleware;\n  }\n  return fn;\n};\n\n// src/endpoint.ts\nvar createEndpoint2 = (path, options, handler) => {\n  const internalHandler = async (...inputCtx) => {\n    const context = inputCtx[0] || {};\n    const internalContext = await createInternalContext(context, {\n      options,\n      path\n    });\n    const response = await handler(internalContext).catch(async (e) => {\n      if (isAPIError(e)) {\n        const onAPIError = options.onAPIError;\n        if (onAPIError) {\n          await onAPIError(e);\n        }\n        if (context.asResponse) {\n          return e;\n        }\n      }\n      throw e;\n    });\n    const headers = internalContext.responseHeaders;\n    return context.asResponse ? toResponse(response, {\n      headers\n    }) : context.returnHeaders ? {\n      headers,\n      response\n    } : response;\n  };\n  internalHandler.options = options;\n  internalHandler.path = path;\n  return internalHandler;\n};\ncreateEndpoint2.create = (opts) => {\n  return (path, options, handler) => {\n    return createEndpoint2(\n      path,\n      {\n        ...options,\n        use: [...options?.use || [], ...opts?.use || []]\n      },\n      handler\n    );\n  };\n};\n\n// src/router.ts\n\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/core.js\nvar NEVER = Object.freeze({\n  status: \"aborted\"\n});\n// @__NO_SIDE_EFFECTS__\nfunction $constructor(name, initializer3, params) {\n  function init(inst, def) {\n    var _a;\n    Object.defineProperty(inst, \"_zod\", {\n      value: inst._zod ?? {},\n      enumerable: false\n    });\n    (_a = inst._zod).traits ?? (_a.traits = /* @__PURE__ */ new Set());\n    inst._zod.traits.add(name);\n    initializer3(inst, def);\n    for (const k in _.prototype) {\n      if (!(k in inst))\n        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });\n    }\n    inst._zod.constr = _;\n    inst._zod.def = def;\n  }\n  const Parent = params?.Parent ?? Object;\n  class Definition extends Parent {\n  }\n  Object.defineProperty(Definition, \"name\", { value: name });\n  function _(def) {\n    var _a;\n    const inst = params?.Parent ? new Definition() : this;\n    init(inst, def);\n    (_a = inst._zod).deferred ?? (_a.deferred = []);\n    for (const fn of inst._zod.deferred) {\n      fn();\n    }\n    return inst;\n  }\n  Object.defineProperty(_, \"init\", { value: init });\n  Object.defineProperty(_, Symbol.hasInstance, {\n    value: (inst) => {\n      if (params?.Parent && inst instanceof params.Parent)\n        return true;\n      return inst?._zod?.traits?.has(name);\n    }\n  });\n  Object.defineProperty(_, \"name\", { value: name });\n  return _;\n}\nvar $brand = Symbol(\"zod_brand\");\nvar $ZodAsyncError = class extends Error {\n  constructor() {\n    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);\n  }\n};\nvar globalConfig = {};\nfunction config(newConfig) {\n  if (newConfig)\n    Object.assign(globalConfig, newConfig);\n  return globalConfig;\n}\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/util.js\nvar util_exports = {};\n__export(util_exports, {\n  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,\n  Class: () => Class,\n  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,\n  aborted: () => aborted,\n  allowsEval: () => allowsEval,\n  assert: () => assert,\n  assertEqual: () => assertEqual,\n  assertIs: () => assertIs,\n  assertNever: () => assertNever,\n  assertNotEqual: () => assertNotEqual,\n  assignProp: () => assignProp,\n  cached: () => cached,\n  captureStackTrace: () => captureStackTrace,\n  cleanEnum: () => cleanEnum,\n  cleanRegex: () => cleanRegex,\n  clone: () => clone,\n  createTransparentProxy: () => createTransparentProxy,\n  defineLazy: () => defineLazy,\n  esc: () => esc,\n  escapeRegex: () => escapeRegex,\n  extend: () => extend,\n  finalizeIssue: () => finalizeIssue,\n  floatSafeRemainder: () => floatSafeRemainder,\n  getElementAtPath: () => getElementAtPath,\n  getEnumValues: () => getEnumValues,\n  getLengthableOrigin: () => getLengthableOrigin,\n  getParsedType: () => getParsedType,\n  getSizableOrigin: () => getSizableOrigin,\n  isObject: () => isObject,\n  isPlainObject: () => isPlainObject,\n  issue: () => issue,\n  joinValues: () => joinValues,\n  jsonStringifyReplacer: () => jsonStringifyReplacer,\n  merge: () => merge,\n  normalizeParams: () => normalizeParams,\n  nullish: () => nullish,\n  numKeys: () => numKeys,\n  omit: () => omit,\n  optionalKeys: () => optionalKeys,\n  partial: () => partial,\n  pick: () => pick,\n  prefixIssues: () => prefixIssues,\n  primitiveTypes: () => primitiveTypes,\n  promiseAllObject: () => promiseAllObject,\n  propertyKeyTypes: () => propertyKeyTypes,\n  randomString: () => randomString,\n  required: () => required,\n  stringifyPrimitive: () => stringifyPrimitive,\n  unwrapMessage: () => unwrapMessage\n});\nfunction assertEqual(val) {\n  return val;\n}\nfunction assertNotEqual(val) {\n  return val;\n}\nfunction assertIs(_arg) {\n}\nfunction assertNever(_x) {\n  throw new Error();\n}\nfunction assert(_) {\n}\nfunction getEnumValues(entries) {\n  const numericValues = Object.values(entries).filter((v) => typeof v === \"number\");\n  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);\n  return values;\n}\nfunction joinValues(array2, separator = \"|\") {\n  return array2.map((val) => stringifyPrimitive(val)).join(separator);\n}\nfunction jsonStringifyReplacer(_, value) {\n  if (typeof value === \"bigint\")\n    return value.toString();\n  return value;\n}\nfunction cached(getter) {\n  const set = false;\n  return {\n    get value() {\n      if (!set) {\n        const value = getter();\n        Object.defineProperty(this, \"value\", { value });\n        return value;\n      }\n      throw new Error(\"cached value already set\");\n    }\n  };\n}\nfunction nullish(input) {\n  return input === null || input === void 0;\n}\nfunction cleanRegex(source) {\n  const start = source.startsWith(\"^\") ? 1 : 0;\n  const end = source.endsWith(\"$\") ? source.length - 1 : source.length;\n  return source.slice(start, end);\n}\nfunction floatSafeRemainder(val, step) {\n  const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n  const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n  const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n  return valInt % stepInt / 10 ** decCount;\n}\nfunction defineLazy(object, key, getter) {\n  const set = false;\n  Object.defineProperty(object, key, {\n    get() {\n      if (!set) {\n        const value = getter();\n        object[key] = value;\n        return value;\n      }\n      throw new Error(\"cached value already set\");\n    },\n    set(v) {\n      Object.defineProperty(object, key, {\n        value: v\n        // configurable: true,\n      });\n    },\n    configurable: true\n  });\n}\nfunction assignProp(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value,\n    writable: true,\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction getElementAtPath(obj, path) {\n  if (!path)\n    return obj;\n  return path.reduce((acc, key) => acc?.[key], obj);\n}\nfunction promiseAllObject(promisesObj) {\n  const keys = Object.keys(promisesObj);\n  const promises = keys.map((key) => promisesObj[key]);\n  return Promise.all(promises).then((results) => {\n    const resolvedObj = {};\n    for (let i = 0; i < keys.length; i++) {\n      resolvedObj[keys[i]] = results[i];\n    }\n    return resolvedObj;\n  });\n}\nfunction randomString(length = 10) {\n  const chars = \"abcdefghijklmnopqrstuvwxyz\";\n  let str = \"\";\n  for (let i = 0; i < length; i++) {\n    str += chars[Math.floor(Math.random() * chars.length)];\n  }\n  return str;\n}\nfunction esc(str) {\n  return JSON.stringify(str);\n}\nvar captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {\n};\nfunction isObject(data) {\n  return typeof data === \"object\" && data !== null && !Array.isArray(data);\n}\nvar allowsEval = cached(() => {\n  if (typeof navigator !== \"undefined\" && navigator?.userAgent?.includes(\"Cloudflare\")) {\n    return false;\n  }\n  try {\n    const F = Function;\n    new F(\"\");\n    return true;\n  } catch (_) {\n    return false;\n  }\n});\nfunction isPlainObject(o) {\n  if (isObject(o) === false)\n    return false;\n  const ctor = o.constructor;\n  if (ctor === void 0)\n    return true;\n  const prot = ctor.prototype;\n  if (isObject(prot) === false)\n    return false;\n  if (Object.prototype.hasOwnProperty.call(prot, \"isPrototypeOf\") === false) {\n    return false;\n  }\n  return true;\n}\nfunction numKeys(data) {\n  let keyCount = 0;\n  for (const key in data) {\n    if (Object.prototype.hasOwnProperty.call(data, key)) {\n      keyCount++;\n    }\n  }\n  return keyCount;\n}\nvar getParsedType = (data) => {\n  const t = typeof data;\n  switch (t) {\n    case \"undefined\":\n      return \"undefined\";\n    case \"string\":\n      return \"string\";\n    case \"number\":\n      return Number.isNaN(data) ? \"nan\" : \"number\";\n    case \"boolean\":\n      return \"boolean\";\n    case \"function\":\n      return \"function\";\n    case \"bigint\":\n      return \"bigint\";\n    case \"symbol\":\n      return \"symbol\";\n    case \"object\":\n      if (Array.isArray(data)) {\n        return \"array\";\n      }\n      if (data === null) {\n        return \"null\";\n      }\n      if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n        return \"promise\";\n      }\n      if (typeof Map !== \"undefined\" && data instanceof Map) {\n        return \"map\";\n      }\n      if (typeof Set !== \"undefined\" && data instanceof Set) {\n        return \"set\";\n      }\n      if (typeof Date !== \"undefined\" && data instanceof Date) {\n        return \"date\";\n      }\n      if (typeof File !== \"undefined\" && data instanceof File) {\n        return \"file\";\n      }\n      return \"object\";\n    default:\n      throw new Error(`Unknown data type: ${t}`);\n  }\n};\nvar propertyKeyTypes = /* @__PURE__ */ new Set([\"string\", \"number\", \"symbol\"]);\nvar primitiveTypes = /* @__PURE__ */ new Set([\"string\", \"number\", \"bigint\", \"boolean\", \"symbol\", \"undefined\"]);\nfunction escapeRegex(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction clone(inst, def, params) {\n  const cl = new inst._zod.constr(def ?? inst._zod.def);\n  if (!def || params?.parent)\n    cl._zod.parent = inst;\n  return cl;\n}\nfunction normalizeParams(_params) {\n  const params = _params;\n  if (!params)\n    return {};\n  if (typeof params === \"string\")\n    return { error: () => params };\n  if (params?.message !== void 0) {\n    if (params?.error !== void 0)\n      throw new Error(\"Cannot specify both `message` and `error` params\");\n    params.error = params.message;\n  }\n  delete params.message;\n  if (typeof params.error === \"string\")\n    return { ...params, error: () => params.error };\n  return params;\n}\nfunction createTransparentProxy(getter) {\n  let target;\n  return new Proxy({}, {\n    get(_, prop, receiver) {\n      target ?? (target = getter());\n      return Reflect.get(target, prop, receiver);\n    },\n    set(_, prop, value, receiver) {\n      target ?? (target = getter());\n      return Reflect.set(target, prop, value, receiver);\n    },\n    has(_, prop) {\n      target ?? (target = getter());\n      return Reflect.has(target, prop);\n    },\n    deleteProperty(_, prop) {\n      target ?? (target = getter());\n      return Reflect.deleteProperty(target, prop);\n    },\n    ownKeys(_) {\n      target ?? (target = getter());\n      return Reflect.ownKeys(target);\n    },\n    getOwnPropertyDescriptor(_, prop) {\n      target ?? (target = getter());\n      return Reflect.getOwnPropertyDescriptor(target, prop);\n    },\n    defineProperty(_, prop, descriptor) {\n      target ?? (target = getter());\n      return Reflect.defineProperty(target, prop, descriptor);\n    }\n  });\n}\nfunction stringifyPrimitive(value) {\n  if (typeof value === \"bigint\")\n    return value.toString() + \"n\";\n  if (typeof value === \"string\")\n    return `\"${value}\"`;\n  return `${value}`;\n}\nfunction optionalKeys(shape) {\n  return Object.keys(shape).filter((k) => {\n    return shape[k]._zod.optin === \"optional\" && shape[k]._zod.optout === \"optional\";\n  });\n}\nvar NUMBER_FORMAT_RANGES = {\n  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],\n  int32: [-2147483648, 2147483647],\n  uint32: [0, 4294967295],\n  float32: [-34028234663852886e22, 34028234663852886e22],\n  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]\n};\nvar BIGINT_FORMAT_RANGES = {\n  int64: [/* @__PURE__ */ BigInt(\"-9223372036854775808\"), /* @__PURE__ */ BigInt(\"9223372036854775807\")],\n  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt(\"18446744073709551615\")]\n};\nfunction pick(schema, mask) {\n  const newShape = {};\n  const currDef = schema._zod.def;\n  for (const key in mask) {\n    if (!(key in currDef.shape)) {\n      throw new Error(`Unrecognized key: \"${key}\"`);\n    }\n    if (!mask[key])\n      continue;\n    newShape[key] = currDef.shape[key];\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape: newShape,\n    checks: []\n  });\n}\nfunction omit(schema, mask) {\n  const newShape = { ...schema._zod.def.shape };\n  const currDef = schema._zod.def;\n  for (const key in mask) {\n    if (!(key in currDef.shape)) {\n      throw new Error(`Unrecognized key: \"${key}\"`);\n    }\n    if (!mask[key])\n      continue;\n    delete newShape[key];\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape: newShape,\n    checks: []\n  });\n}\nfunction extend(schema, shape) {\n  if (!isPlainObject(shape)) {\n    throw new Error(\"Invalid input to extend: expected a plain object\");\n  }\n  const def = {\n    ...schema._zod.def,\n    get shape() {\n      const _shape = { ...schema._zod.def.shape, ...shape };\n      assignProp(this, \"shape\", _shape);\n      return _shape;\n    },\n    checks: []\n    // delete existing checks\n  };\n  return clone(schema, def);\n}\nfunction merge(a, b) {\n  return clone(a, {\n    ...a._zod.def,\n    get shape() {\n      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };\n      assignProp(this, \"shape\", _shape);\n      return _shape;\n    },\n    catchall: b._zod.def.catchall,\n    checks: []\n    // delete existing checks\n  });\n}\nfunction partial(Class2, schema, mask) {\n  const oldShape = schema._zod.def.shape;\n  const shape = { ...oldShape };\n  if (mask) {\n    for (const key in mask) {\n      if (!(key in oldShape)) {\n        throw new Error(`Unrecognized key: \"${key}\"`);\n      }\n      if (!mask[key])\n        continue;\n      shape[key] = Class2 ? new Class2({\n        type: \"optional\",\n        innerType: oldShape[key]\n      }) : oldShape[key];\n    }\n  } else {\n    for (const key in oldShape) {\n      shape[key] = Class2 ? new Class2({\n        type: \"optional\",\n        innerType: oldShape[key]\n      }) : oldShape[key];\n    }\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape,\n    checks: []\n  });\n}\nfunction required(Class2, schema, mask) {\n  const oldShape = schema._zod.def.shape;\n  const shape = { ...oldShape };\n  if (mask) {\n    for (const key in mask) {\n      if (!(key in shape)) {\n        throw new Error(`Unrecognized key: \"${key}\"`);\n      }\n      if (!mask[key])\n        continue;\n      shape[key] = new Class2({\n        type: \"nonoptional\",\n        innerType: oldShape[key]\n      });\n    }\n  } else {\n    for (const key in oldShape) {\n      shape[key] = new Class2({\n        type: \"nonoptional\",\n        innerType: oldShape[key]\n      });\n    }\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape,\n    // optional: [],\n    checks: []\n  });\n}\nfunction aborted(x, startIndex = 0) {\n  for (let i = startIndex; i < x.issues.length; i++) {\n    if (x.issues[i]?.continue !== true)\n      return true;\n  }\n  return false;\n}\nfunction prefixIssues(path, issues) {\n  return issues.map((iss) => {\n    var _a;\n    (_a = iss).path ?? (_a.path = []);\n    iss.path.unshift(path);\n    return iss;\n  });\n}\nfunction unwrapMessage(message) {\n  return typeof message === \"string\" ? message : message?.message;\n}\nfunction finalizeIssue(iss, ctx, config2) {\n  const full = { ...iss, path: iss.path ?? [] };\n  if (!iss.message) {\n    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? \"Invalid input\";\n    full.message = message;\n  }\n  delete full.inst;\n  delete full.continue;\n  if (!ctx?.reportInput) {\n    delete full.input;\n  }\n  return full;\n}\nfunction getSizableOrigin(input) {\n  if (input instanceof Set)\n    return \"set\";\n  if (input instanceof Map)\n    return \"map\";\n  if (input instanceof File)\n    return \"file\";\n  return \"unknown\";\n}\nfunction getLengthableOrigin(input) {\n  if (Array.isArray(input))\n    return \"array\";\n  if (typeof input === \"string\")\n    return \"string\";\n  return \"unknown\";\n}\nfunction issue(...args) {\n  const [iss, input, inst] = args;\n  if (typeof iss === \"string\") {\n    return {\n      message: iss,\n      code: \"custom\",\n      input,\n      inst\n    };\n  }\n  return { ...iss };\n}\nfunction cleanEnum(obj) {\n  return Object.entries(obj).filter(([k, _]) => {\n    return Number.isNaN(Number.parseInt(k, 10));\n  }).map((el) => el[1]);\n}\nvar Class = class {\n  constructor(..._args) {\n  }\n};\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/errors.js\nvar initializer = (inst, def) => {\n  inst.name = \"$ZodError\";\n  Object.defineProperty(inst, \"_zod\", {\n    value: inst._zod,\n    enumerable: false\n  });\n  Object.defineProperty(inst, \"issues\", {\n    value: def,\n    enumerable: false\n  });\n  Object.defineProperty(inst, \"message\", {\n    get() {\n      return JSON.stringify(def, jsonStringifyReplacer, 2);\n    },\n    enumerable: true\n    // configurable: false,\n  });\n  Object.defineProperty(inst, \"toString\", {\n    value: () => inst.message,\n    enumerable: false\n  });\n};\nvar $ZodError = $constructor(\"$ZodError\", initializer);\nvar $ZodRealError = $constructor(\"$ZodError\", initializer, { Parent: Error });\nfunction flattenError(error, mapper = (issue2) => issue2.message) {\n  const fieldErrors = {};\n  const formErrors = [];\n  for (const sub of error.issues) {\n    if (sub.path.length > 0) {\n      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n      fieldErrors[sub.path[0]].push(mapper(sub));\n    } else {\n      formErrors.push(mapper(sub));\n    }\n  }\n  return { formErrors, fieldErrors };\n}\nfunction formatError(error, _mapper) {\n  const mapper = _mapper || function(issue2) {\n    return issue2.message;\n  };\n  const fieldErrors = { _errors: [] };\n  const processError = (error2) => {\n    for (const issue2 of error2.issues) {\n      if (issue2.code === \"invalid_union\" && issue2.errors.length) {\n        issue2.errors.map((issues) => processError({ issues }));\n      } else if (issue2.code === \"invalid_key\") {\n        processError({ issues: issue2.issues });\n      } else if (issue2.code === \"invalid_element\") {\n        processError({ issues: issue2.issues });\n      } else if (issue2.path.length === 0) {\n        fieldErrors._errors.push(mapper(issue2));\n      } else {\n        let curr = fieldErrors;\n        let i = 0;\n        while (i < issue2.path.length) {\n          const el = issue2.path[i];\n          const terminal = i === issue2.path.length - 1;\n          if (!terminal) {\n            curr[el] = curr[el] || { _errors: [] };\n          } else {\n            curr[el] = curr[el] || { _errors: [] };\n            curr[el]._errors.push(mapper(issue2));\n          }\n          curr = curr[el];\n          i++;\n        }\n      }\n    }\n  };\n  processError(error);\n  return fieldErrors;\n}\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/parse.js\nvar _parse = (_Err) => (schema, value, _ctx, _params) => {\n  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };\n  const result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise) {\n    throw new $ZodAsyncError();\n  }\n  if (result.issues.length) {\n    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));\n    captureStackTrace(e, _params?.callee);\n    throw e;\n  }\n  return result.value;\n};\nvar _parseAsync = (_Err) => async (schema, value, _ctx, params) => {\n  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n  let result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise)\n    result = await result;\n  if (result.issues.length) {\n    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));\n    captureStackTrace(e, params?.callee);\n    throw e;\n  }\n  return result.value;\n};\nvar _safeParse = (_Err) => (schema, value, _ctx) => {\n  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };\n  const result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise) {\n    throw new $ZodAsyncError();\n  }\n  return result.issues.length ? {\n    success: false,\n    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n  } : { success: true, data: result.value };\n};\nvar safeParse = /* @__PURE__ */ _safeParse($ZodRealError);\nvar _safeParseAsync = (_Err) => async (schema, value, _ctx) => {\n  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n  let result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise)\n    result = await result;\n  return result.issues.length ? {\n    success: false,\n    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n  } : { success: true, data: result.value };\n};\nvar safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/checks.js\nvar $ZodCheck = /* @__PURE__ */ $constructor(\"$ZodCheck\", (inst, def) => {\n  var _a;\n  inst._zod ?? (inst._zod = {});\n  inst._zod.def = def;\n  (_a = inst._zod).onattach ?? (_a.onattach = []);\n});\nvar $ZodCheckMaxLength = /* @__PURE__ */ $constructor(\"$ZodCheckMaxLength\", (inst, def) => {\n  var _a;\n  $ZodCheck.init(inst, def);\n  (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.length !== void 0;\n  });\n  inst._zod.onattach.push((inst2) => {\n    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;\n    if (def.maximum < curr)\n      inst2._zod.bag.maximum = def.maximum;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const length = input.length;\n    if (length <= def.maximum)\n      return;\n    const origin = getLengthableOrigin(input);\n    payload.issues.push({\n      origin,\n      code: \"too_big\",\n      maximum: def.maximum,\n      inclusive: true,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckMinLength = /* @__PURE__ */ $constructor(\"$ZodCheckMinLength\", (inst, def) => {\n  var _a;\n  $ZodCheck.init(inst, def);\n  (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.length !== void 0;\n  });\n  inst._zod.onattach.push((inst2) => {\n    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;\n    if (def.minimum > curr)\n      inst2._zod.bag.minimum = def.minimum;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const length = input.length;\n    if (length >= def.minimum)\n      return;\n    const origin = getLengthableOrigin(input);\n    payload.issues.push({\n      origin,\n      code: \"too_small\",\n      minimum: def.minimum,\n      inclusive: true,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckLengthEquals = /* @__PURE__ */ $constructor(\"$ZodCheckLengthEquals\", (inst, def) => {\n  var _a;\n  $ZodCheck.init(inst, def);\n  (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.length !== void 0;\n  });\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.minimum = def.length;\n    bag.maximum = def.length;\n    bag.length = def.length;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const length = input.length;\n    if (length === def.length)\n      return;\n    const origin = getLengthableOrigin(input);\n    const tooBig = length > def.length;\n    payload.issues.push({\n      origin,\n      ...tooBig ? { code: \"too_big\", maximum: def.length } : { code: \"too_small\", minimum: def.length },\n      inclusive: true,\n      exact: true,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckOverwrite = /* @__PURE__ */ $constructor(\"$ZodCheckOverwrite\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  inst._zod.check = (payload) => {\n    payload.value = def.tx(payload.value);\n  };\n});\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/doc.js\nvar Doc = class {\n  constructor(args = []) {\n    this.content = [];\n    this.indent = 0;\n    if (this)\n      this.args = args;\n  }\n  indented(fn) {\n    this.indent += 1;\n    fn(this);\n    this.indent -= 1;\n  }\n  write(arg) {\n    if (typeof arg === \"function\") {\n      arg(this, { execution: \"sync\" });\n      arg(this, { execution: \"async\" });\n      return;\n    }\n    const content = arg;\n    const lines = content.split(\"\\n\").filter((x) => x);\n    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));\n    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => \" \".repeat(this.indent * 2) + x);\n    for (const line of dedented) {\n      this.content.push(line);\n    }\n  }\n  compile() {\n    const F = Function;\n    const args = this?.args;\n    const content = this?.content ?? [``];\n    const lines = [...content.map((x) => `  ${x}`)];\n    return new F(...args, lines.join(\"\\n\"));\n  }\n};\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/versions.js\nvar version = {\n  major: 4,\n  minor: 0,\n  patch: 0\n};\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/schemas.js\nvar $ZodType = /* @__PURE__ */ $constructor(\"$ZodType\", (inst, def) => {\n  var _a;\n  inst ?? (inst = {});\n  inst._zod.def = def;\n  inst._zod.bag = inst._zod.bag || {};\n  inst._zod.version = version;\n  const checks = [...inst._zod.def.checks ?? []];\n  if (inst._zod.traits.has(\"$ZodCheck\")) {\n    checks.unshift(inst);\n  }\n  for (const ch of checks) {\n    for (const fn of ch._zod.onattach) {\n      fn(inst);\n    }\n  }\n  if (checks.length === 0) {\n    (_a = inst._zod).deferred ?? (_a.deferred = []);\n    inst._zod.deferred?.push(() => {\n      inst._zod.run = inst._zod.parse;\n    });\n  } else {\n    const runChecks = (payload, checks2, ctx) => {\n      let isAborted = aborted(payload);\n      let asyncResult;\n      for (const ch of checks2) {\n        if (ch._zod.def.when) {\n          const shouldRun = ch._zod.def.when(payload);\n          if (!shouldRun)\n            continue;\n        } else if (isAborted) {\n          continue;\n        }\n        const currLen = payload.issues.length;\n        const _ = ch._zod.check(payload);\n        if (_ instanceof Promise && ctx?.async === false) {\n          throw new $ZodAsyncError();\n        }\n        if (asyncResult || _ instanceof Promise) {\n          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {\n            await _;\n            const nextLen = payload.issues.length;\n            if (nextLen === currLen)\n              return;\n            if (!isAborted)\n              isAborted = aborted(payload, currLen);\n          });\n        } else {\n          const nextLen = payload.issues.length;\n          if (nextLen === currLen)\n            continue;\n          if (!isAborted)\n            isAborted = aborted(payload, currLen);\n        }\n      }\n      if (asyncResult) {\n        return asyncResult.then(() => {\n          return payload;\n        });\n      }\n      return payload;\n    };\n    inst._zod.run = (payload, ctx) => {\n      const result = inst._zod.parse(payload, ctx);\n      if (result instanceof Promise) {\n        if (ctx.async === false)\n          throw new $ZodAsyncError();\n        return result.then((result2) => runChecks(result2, checks, ctx));\n      }\n      return runChecks(result, checks, ctx);\n    };\n  }\n  inst[\"~standard\"] = {\n    validate: (value) => {\n      try {\n        const r = safeParse(inst, value);\n        return r.success ? { value: r.data } : { issues: r.error?.issues };\n      } catch (_) {\n        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });\n      }\n    },\n    vendor: \"zod\",\n    version: 1\n  };\n});\nvar $ZodUnknown = /* @__PURE__ */ $constructor(\"$ZodUnknown\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload) => payload;\n});\nvar $ZodNever = /* @__PURE__ */ $constructor(\"$ZodNever\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    payload.issues.push({\n      expected: \"never\",\n      code: \"invalid_type\",\n      input: payload.value,\n      inst\n    });\n    return payload;\n  };\n});\nfunction handleArrayResult(result, final, index) {\n  if (result.issues.length) {\n    final.issues.push(...prefixIssues(index, result.issues));\n  }\n  final.value[index] = result.value;\n}\nvar $ZodArray = /* @__PURE__ */ $constructor(\"$ZodArray\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!Array.isArray(input)) {\n      payload.issues.push({\n        expected: \"array\",\n        code: \"invalid_type\",\n        input,\n        inst\n      });\n      return payload;\n    }\n    payload.value = Array(input.length);\n    const proms = [];\n    for (let i = 0; i < input.length; i++) {\n      const item = input[i];\n      const result = def.element._zod.run({\n        value: item,\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));\n      } else {\n        handleArrayResult(result, payload, i);\n      }\n    }\n    if (proms.length) {\n      return Promise.all(proms).then(() => payload);\n    }\n    return payload;\n  };\n});\nfunction handleObjectResult(result, final, key) {\n  if (result.issues.length) {\n    final.issues.push(...prefixIssues(key, result.issues));\n  }\n  final.value[key] = result.value;\n}\nfunction handleOptionalObjectResult(result, final, key, input) {\n  if (result.issues.length) {\n    if (input[key] === void 0) {\n      if (key in input) {\n        final.value[key] = void 0;\n      } else {\n        final.value[key] = result.value;\n      }\n    } else {\n      final.issues.push(...prefixIssues(key, result.issues));\n    }\n  } else if (result.value === void 0) {\n    if (key in input)\n      final.value[key] = void 0;\n  } else {\n    final.value[key] = result.value;\n  }\n}\nvar $ZodObject = /* @__PURE__ */ $constructor(\"$ZodObject\", (inst, def) => {\n  $ZodType.init(inst, def);\n  const _normalized = cached(() => {\n    const keys = Object.keys(def.shape);\n    for (const k of keys) {\n      if (!(def.shape[k] instanceof $ZodType)) {\n        throw new Error(`Invalid element at key \"${k}\": expected a Zod schema`);\n      }\n    }\n    const okeys = optionalKeys(def.shape);\n    return {\n      shape: def.shape,\n      keys,\n      keySet: new Set(keys),\n      numKeys: keys.length,\n      optionalKeys: new Set(okeys)\n    };\n  });\n  defineLazy(inst._zod, \"propValues\", () => {\n    const shape = def.shape;\n    const propValues = {};\n    for (const key in shape) {\n      const field = shape[key]._zod;\n      if (field.values) {\n        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());\n        for (const v of field.values)\n          propValues[key].add(v);\n      }\n    }\n    return propValues;\n  });\n  const generateFastpass = (shape) => {\n    const doc = new Doc([\"shape\", \"payload\", \"ctx\"]);\n    const normalized = _normalized.value;\n    const parseStr = (key) => {\n      const k = esc(key);\n      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;\n    };\n    doc.write(`const input = payload.value;`);\n    const ids = /* @__PURE__ */ Object.create(null);\n    let counter = 0;\n    for (const key of normalized.keys) {\n      ids[key] = `key_${counter++}`;\n    }\n    doc.write(`const newResult = {}`);\n    for (const key of normalized.keys) {\n      if (normalized.optionalKeys.has(key)) {\n        const id = ids[key];\n        doc.write(`const ${id} = ${parseStr(key)};`);\n        const k = esc(key);\n        doc.write(`\n        if (${id}.issues.length) {\n          if (input[${k}] === undefined) {\n            if (${k} in input) {\n              newResult[${k}] = undefined;\n            }\n          } else {\n            payload.issues = payload.issues.concat(\n              ${id}.issues.map((iss) => ({\n                ...iss,\n                path: iss.path ? [${k}, ...iss.path] : [${k}],\n              }))\n            );\n          }\n        } else if (${id}.value === undefined) {\n          if (${k} in input) newResult[${k}] = undefined;\n        } else {\n          newResult[${k}] = ${id}.value;\n        }\n        `);\n      } else {\n        const id = ids[key];\n        doc.write(`const ${id} = ${parseStr(key)};`);\n        doc.write(`\n          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({\n            ...iss,\n            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]\n          })));`);\n        doc.write(`newResult[${esc(key)}] = ${id}.value`);\n      }\n    }\n    doc.write(`payload.value = newResult;`);\n    doc.write(`return payload;`);\n    const fn = doc.compile();\n    return (payload, ctx) => fn(shape, payload, ctx);\n  };\n  let fastpass;\n  const isObject2 = isObject;\n  const jit = !globalConfig.jitless;\n  const allowsEval2 = allowsEval;\n  const fastEnabled = jit && allowsEval2.value;\n  const catchall = def.catchall;\n  let value;\n  inst._zod.parse = (payload, ctx) => {\n    value ?? (value = _normalized.value);\n    const input = payload.value;\n    if (!isObject2(input)) {\n      payload.issues.push({\n        expected: \"object\",\n        code: \"invalid_type\",\n        input,\n        inst\n      });\n      return payload;\n    }\n    const proms = [];\n    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {\n      if (!fastpass)\n        fastpass = generateFastpass(def.shape);\n      payload = fastpass(payload, ctx);\n    } else {\n      payload.value = {};\n      const shape = value.shape;\n      for (const key of value.keys) {\n        const el = shape[key];\n        const r = el._zod.run({ value: input[key], issues: [] }, ctx);\n        const isOptional = el._zod.optin === \"optional\" && el._zod.optout === \"optional\";\n        if (r instanceof Promise) {\n          proms.push(r.then((r2) => isOptional ? handleOptionalObjectResult(r2, payload, key, input) : handleObjectResult(r2, payload, key)));\n        } else if (isOptional) {\n          handleOptionalObjectResult(r, payload, key, input);\n        } else {\n          handleObjectResult(r, payload, key);\n        }\n      }\n    }\n    if (!catchall) {\n      return proms.length ? Promise.all(proms).then(() => payload) : payload;\n    }\n    const unrecognized = [];\n    const keySet = value.keySet;\n    const _catchall = catchall._zod;\n    const t = _catchall.def.type;\n    for (const key of Object.keys(input)) {\n      if (keySet.has(key))\n        continue;\n      if (t === \"never\") {\n        unrecognized.push(key);\n        continue;\n      }\n      const r = _catchall.run({ value: input[key], issues: [] }, ctx);\n      if (r instanceof Promise) {\n        proms.push(r.then((r2) => handleObjectResult(r2, payload, key)));\n      } else {\n        handleObjectResult(r, payload, key);\n      }\n    }\n    if (unrecognized.length) {\n      payload.issues.push({\n        code: \"unrecognized_keys\",\n        keys: unrecognized,\n        input,\n        inst\n      });\n    }\n    if (!proms.length)\n      return payload;\n    return Promise.all(proms).then(() => {\n      return payload;\n    });\n  };\n});\nfunction handleUnionResults(results, final, inst, ctx) {\n  for (const result of results) {\n    if (result.issues.length === 0) {\n      final.value = result.value;\n      return final;\n    }\n  }\n  final.issues.push({\n    code: \"invalid_union\",\n    input: final.value,\n    inst,\n    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n  });\n  return final;\n}\nvar $ZodUnion = /* @__PURE__ */ $constructor(\"$ZodUnion\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"optin\", () => def.options.some((o) => o._zod.optin === \"optional\") ? \"optional\" : void 0);\n  defineLazy(inst._zod, \"optout\", () => def.options.some((o) => o._zod.optout === \"optional\") ? \"optional\" : void 0);\n  defineLazy(inst._zod, \"values\", () => {\n    if (def.options.every((o) => o._zod.values)) {\n      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));\n    }\n    return void 0;\n  });\n  defineLazy(inst._zod, \"pattern\", () => {\n    if (def.options.every((o) => o._zod.pattern)) {\n      const patterns = def.options.map((o) => o._zod.pattern);\n      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join(\"|\")})$`);\n    }\n    return void 0;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    let async = false;\n    const results = [];\n    for (const option of def.options) {\n      const result = option._zod.run({\n        value: payload.value,\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        results.push(result);\n        async = true;\n      } else {\n        if (result.issues.length === 0)\n          return result;\n        results.push(result);\n      }\n    }\n    if (!async)\n      return handleUnionResults(results, payload, inst, ctx);\n    return Promise.all(results).then((results2) => {\n      return handleUnionResults(results2, payload, inst, ctx);\n    });\n  };\n});\nvar $ZodIntersection = /* @__PURE__ */ $constructor(\"$ZodIntersection\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    const left = def.left._zod.run({ value: input, issues: [] }, ctx);\n    const right = def.right._zod.run({ value: input, issues: [] }, ctx);\n    const async = left instanceof Promise || right instanceof Promise;\n    if (async) {\n      return Promise.all([left, right]).then(([left2, right2]) => {\n        return handleIntersectionResults(payload, left2, right2);\n      });\n    }\n    return handleIntersectionResults(payload, left, right);\n  };\n});\nfunction mergeValues(a, b) {\n  if (a === b) {\n    return { valid: true, data: a };\n  }\n  if (a instanceof Date && b instanceof Date && +a === +b) {\n    return { valid: true, data: a };\n  }\n  if (isPlainObject(a) && isPlainObject(b)) {\n    const bKeys = Object.keys(b);\n    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);\n    const newObj = { ...a, ...b };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues(a[key], b[key]);\n      if (!sharedValue.valid) {\n        return {\n          valid: false,\n          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]\n        };\n      }\n      newObj[key] = sharedValue.data;\n    }\n    return { valid: true, data: newObj };\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) {\n      return { valid: false, mergeErrorPath: [] };\n    }\n    const newArray = [];\n    for (let index = 0; index < a.length; index++) {\n      const itemA = a[index];\n      const itemB = b[index];\n      const sharedValue = mergeValues(itemA, itemB);\n      if (!sharedValue.valid) {\n        return {\n          valid: false,\n          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]\n        };\n      }\n      newArray.push(sharedValue.data);\n    }\n    return { valid: true, data: newArray };\n  }\n  return { valid: false, mergeErrorPath: [] };\n}\nfunction handleIntersectionResults(result, left, right) {\n  if (left.issues.length) {\n    result.issues.push(...left.issues);\n  }\n  if (right.issues.length) {\n    result.issues.push(...right.issues);\n  }\n  if (aborted(result))\n    return result;\n  const merged = mergeValues(left.value, right.value);\n  if (!merged.valid) {\n    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);\n  }\n  result.value = merged.data;\n  return result;\n}\nvar $ZodEnum = /* @__PURE__ */ $constructor(\"$ZodEnum\", (inst, def) => {\n  $ZodType.init(inst, def);\n  const values = getEnumValues(def.entries);\n  inst._zod.values = new Set(values);\n  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === \"string\" ? escapeRegex(o) : o.toString()).join(\"|\")})$`);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (inst._zod.values.has(input)) {\n      return payload;\n    }\n    payload.issues.push({\n      code: \"invalid_value\",\n      values,\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodTransform = /* @__PURE__ */ $constructor(\"$ZodTransform\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    const _out = def.transform(payload.value, payload);\n    if (_ctx.async) {\n      const output = _out instanceof Promise ? _out : Promise.resolve(_out);\n      return output.then((output2) => {\n        payload.value = output2;\n        return payload;\n      });\n    }\n    if (_out instanceof Promise) {\n      throw new $ZodAsyncError();\n    }\n    payload.value = _out;\n    return payload;\n  };\n});\nvar $ZodOptional = /* @__PURE__ */ $constructor(\"$ZodOptional\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  inst._zod.optout = \"optional\";\n  defineLazy(inst._zod, \"values\", () => {\n    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;\n  });\n  defineLazy(inst._zod, \"pattern\", () => {\n    const pattern = def.innerType._zod.pattern;\n    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    if (def.innerType._zod.optin === \"optional\") {\n      return def.innerType._zod.run(payload, ctx);\n    }\n    if (payload.value === void 0) {\n      return payload;\n    }\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodNullable = /* @__PURE__ */ $constructor(\"$ZodNullable\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n  defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n  defineLazy(inst._zod, \"pattern\", () => {\n    const pattern = def.innerType._zod.pattern;\n    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;\n  });\n  defineLazy(inst._zod, \"values\", () => {\n    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    if (payload.value === null)\n      return payload;\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodDefault = /* @__PURE__ */ $constructor(\"$ZodDefault\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    if (payload.value === void 0) {\n      payload.value = def.defaultValue;\n      return payload;\n    }\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then((result2) => handleDefaultResult(result2, def));\n    }\n    return handleDefaultResult(result, def);\n  };\n});\nfunction handleDefaultResult(payload, def) {\n  if (payload.value === void 0) {\n    payload.value = def.defaultValue;\n  }\n  return payload;\n}\nvar $ZodPrefault = /* @__PURE__ */ $constructor(\"$ZodPrefault\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    if (payload.value === void 0) {\n      payload.value = def.defaultValue;\n    }\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodNonOptional = /* @__PURE__ */ $constructor(\"$ZodNonOptional\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"values\", () => {\n    const v = def.innerType._zod.values;\n    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then((result2) => handleNonOptionalResult(result2, inst));\n    }\n    return handleNonOptionalResult(result, inst);\n  };\n});\nfunction handleNonOptionalResult(payload, inst) {\n  if (!payload.issues.length && payload.value === void 0) {\n    payload.issues.push({\n      code: \"invalid_type\",\n      expected: \"nonoptional\",\n      input: payload.value,\n      inst\n    });\n  }\n  return payload;\n}\nvar $ZodCatch = /* @__PURE__ */ $constructor(\"$ZodCatch\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n  defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then((result2) => {\n        payload.value = result2.value;\n        if (result2.issues.length) {\n          payload.value = def.catchValue({\n            ...payload,\n            error: {\n              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))\n            },\n            input: payload.value\n          });\n          payload.issues = [];\n        }\n        return payload;\n      });\n    }\n    payload.value = result.value;\n    if (result.issues.length) {\n      payload.value = def.catchValue({\n        ...payload,\n        error: {\n          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))\n        },\n        input: payload.value\n      });\n      payload.issues = [];\n    }\n    return payload;\n  };\n});\nvar $ZodPipe = /* @__PURE__ */ $constructor(\"$ZodPipe\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"values\", () => def.in._zod.values);\n  defineLazy(inst._zod, \"optin\", () => def.in._zod.optin);\n  defineLazy(inst._zod, \"optout\", () => def.out._zod.optout);\n  inst._zod.parse = (payload, ctx) => {\n    const left = def.in._zod.run(payload, ctx);\n    if (left instanceof Promise) {\n      return left.then((left2) => handlePipeResult(left2, def, ctx));\n    }\n    return handlePipeResult(left, def, ctx);\n  };\n});\nfunction handlePipeResult(left, def, ctx) {\n  if (aborted(left)) {\n    return left;\n  }\n  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);\n}\nvar $ZodReadonly = /* @__PURE__ */ $constructor(\"$ZodReadonly\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"propValues\", () => def.innerType._zod.propValues);\n  defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  defineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n  defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then(handleReadonlyResult);\n    }\n    return handleReadonlyResult(result);\n  };\n});\nfunction handleReadonlyResult(payload) {\n  payload.value = Object.freeze(payload.value);\n  return payload;\n}\nvar $ZodCustom = /* @__PURE__ */ $constructor(\"$ZodCustom\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _) => {\n    return payload;\n  };\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const r = def.fn(input);\n    if (r instanceof Promise) {\n      return r.then((r2) => handleRefineResult(r2, payload, input, inst));\n    }\n    handleRefineResult(r, payload, input, inst);\n    return;\n  };\n});\nfunction handleRefineResult(result, payload, input, inst) {\n  if (!result) {\n    const _iss = {\n      code: \"custom\",\n      input,\n      inst,\n      // incorporates params.error into issue reporting\n      path: [...inst._zod.def.path ?? []],\n      // incorporates params.error into issue reporting\n      continue: !inst._zod.def.abort\n      // params: inst._zod.def.params,\n    };\n    if (inst._zod.def.params)\n      _iss.params = inst._zod.def.params;\n    payload.issues.push(issue(_iss));\n  }\n}\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/registries.js\nvar $output = Symbol(\"ZodOutput\");\nvar $input = Symbol(\"ZodInput\");\nvar $ZodRegistry = class {\n  constructor() {\n    this._map = /* @__PURE__ */ new Map();\n    this._idmap = /* @__PURE__ */ new Map();\n  }\n  add(schema, ..._meta) {\n    const meta = _meta[0];\n    this._map.set(schema, meta);\n    if (meta && typeof meta === \"object\" && \"id\" in meta) {\n      if (this._idmap.has(meta.id)) {\n        throw new Error(`ID ${meta.id} already exists in the registry`);\n      }\n      this._idmap.set(meta.id, schema);\n    }\n    return this;\n  }\n  clear() {\n    this._map = /* @__PURE__ */ new Map();\n    this._idmap = /* @__PURE__ */ new Map();\n    return this;\n  }\n  remove(schema) {\n    const meta = this._map.get(schema);\n    if (meta && typeof meta === \"object\" && \"id\" in meta) {\n      this._idmap.delete(meta.id);\n    }\n    this._map.delete(schema);\n    return this;\n  }\n  get(schema) {\n    const p = schema._zod.parent;\n    if (p) {\n      const pm = { ...this.get(p) ?? {} };\n      delete pm.id;\n      return { ...pm, ...this._map.get(schema) };\n    }\n    return this._map.get(schema);\n  }\n  has(schema) {\n    return this._map.has(schema);\n  }\n};\nfunction registry() {\n  return new $ZodRegistry();\n}\nvar globalRegistry = /* @__PURE__ */ registry();\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/api.js\nfunction _unknown(Class2) {\n  return new Class2({\n    type: \"unknown\"\n  });\n}\nfunction _never(Class2, params) {\n  return new Class2({\n    type: \"never\",\n    ...normalizeParams(params)\n  });\n}\nfunction _maxLength(maximum, params) {\n  const ch = new $ZodCheckMaxLength({\n    check: \"max_length\",\n    ...normalizeParams(params),\n    maximum\n  });\n  return ch;\n}\nfunction _minLength(minimum, params) {\n  return new $ZodCheckMinLength({\n    check: \"min_length\",\n    ...normalizeParams(params),\n    minimum\n  });\n}\nfunction _length(length, params) {\n  return new $ZodCheckLengthEquals({\n    check: \"length_equals\",\n    ...normalizeParams(params),\n    length\n  });\n}\nfunction _overwrite(tx) {\n  return new $ZodCheckOverwrite({\n    check: \"overwrite\",\n    tx\n  });\n}\nfunction _array(Class2, element, params) {\n  return new Class2({\n    type: \"array\",\n    element,\n    // get element() {\n    //   return element;\n    // },\n    ...normalizeParams(params)\n  });\n}\nfunction _refine(Class2, fn, _params) {\n  const schema = new Class2({\n    type: \"custom\",\n    check: \"custom\",\n    fn,\n    ...normalizeParams(_params)\n  });\n  return schema;\n}\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/classic/errors.js\nvar initializer2 = (inst, issues) => {\n  $ZodError.init(inst, issues);\n  inst.name = \"ZodError\";\n  Object.defineProperties(inst, {\n    format: {\n      value: (mapper) => formatError(inst, mapper)\n      // enumerable: false,\n    },\n    flatten: {\n      value: (mapper) => flattenError(inst, mapper)\n      // enumerable: false,\n    },\n    addIssue: {\n      value: (issue2) => inst.issues.push(issue2)\n      // enumerable: false,\n    },\n    addIssues: {\n      value: (issues2) => inst.issues.push(...issues2)\n      // enumerable: false,\n    },\n    isEmpty: {\n      get() {\n        return inst.issues.length === 0;\n      }\n      // enumerable: false,\n    }\n  });\n};\nvar ZodError = $constructor(\"ZodError\", initializer2);\nvar ZodRealError = $constructor(\"ZodError\", initializer2, {\n  Parent: Error\n});\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/classic/parse.js\nvar parse = /* @__PURE__ */ _parse(ZodRealError);\nvar parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);\nvar safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);\nvar safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/classic/schemas.js\nvar ZodType = /* @__PURE__ */ $constructor(\"ZodType\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst.def = def;\n  Object.defineProperty(inst, \"_def\", { value: def });\n  inst.check = (...checks) => {\n    return inst.clone(\n      {\n        ...def,\n        checks: [\n          ...def.checks ?? [],\n          ...checks.map((ch) => typeof ch === \"function\" ? { _zod: { check: ch, def: { check: \"custom\" }, onattach: [] } } : ch)\n        ]\n      }\n      // { parent: true }\n    );\n  };\n  inst.clone = (def2, params) => clone(inst, def2, params);\n  inst.brand = () => inst;\n  inst.register = (reg, meta) => {\n    reg.add(inst, meta);\n    return inst;\n  };\n  inst.parse = (data, params) => parse(inst, data, params, { callee: inst.parse });\n  inst.safeParse = (data, params) => safeParse2(inst, data, params);\n  inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });\n  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);\n  inst.spa = inst.safeParseAsync;\n  inst.refine = (check2, params) => inst.check(refine(check2, params));\n  inst.superRefine = (refinement) => inst.check(superRefine(refinement));\n  inst.overwrite = (fn) => inst.check(_overwrite(fn));\n  inst.optional = () => optional(inst);\n  inst.nullable = () => nullable(inst);\n  inst.nullish = () => optional(nullable(inst));\n  inst.nonoptional = (params) => nonoptional(inst, params);\n  inst.array = () => array(inst);\n  inst.or = (arg) => union([inst, arg]);\n  inst.and = (arg) => intersection(inst, arg);\n  inst.transform = (tx) => pipe(inst, transform(tx));\n  inst.default = (def2) => _default(inst, def2);\n  inst.prefault = (def2) => prefault(inst, def2);\n  inst.catch = (params) => _catch(inst, params);\n  inst.pipe = (target) => pipe(inst, target);\n  inst.readonly = () => readonly(inst);\n  inst.describe = (description) => {\n    const cl = inst.clone();\n    globalRegistry.add(cl, { description });\n    return cl;\n  };\n  Object.defineProperty(inst, \"description\", {\n    get() {\n      return globalRegistry.get(inst)?.description;\n    },\n    configurable: true\n  });\n  inst.meta = (...args) => {\n    if (args.length === 0) {\n      return globalRegistry.get(inst);\n    }\n    const cl = inst.clone();\n    globalRegistry.add(cl, args[0]);\n    return cl;\n  };\n  inst.isOptional = () => inst.safeParse(void 0).success;\n  inst.isNullable = () => inst.safeParse(null).success;\n  return inst;\n});\nvar ZodUnknown = /* @__PURE__ */ $constructor(\"ZodUnknown\", (inst, def) => {\n  $ZodUnknown.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction unknown() {\n  return _unknown(ZodUnknown);\n}\nvar ZodNever = /* @__PURE__ */ $constructor(\"ZodNever\", (inst, def) => {\n  $ZodNever.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction never(params) {\n  return _never(ZodNever, params);\n}\nvar ZodArray = /* @__PURE__ */ $constructor(\"ZodArray\", (inst, def) => {\n  $ZodArray.init(inst, def);\n  ZodType.init(inst, def);\n  inst.element = def.element;\n  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));\n  inst.nonempty = (params) => inst.check(_minLength(1, params));\n  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));\n  inst.length = (len, params) => inst.check(_length(len, params));\n  inst.unwrap = () => inst.element;\n});\nfunction array(element, params) {\n  return _array(ZodArray, element, params);\n}\nvar ZodObject = /* @__PURE__ */ $constructor(\"ZodObject\", (inst, def) => {\n  $ZodObject.init(inst, def);\n  ZodType.init(inst, def);\n  util_exports.defineLazy(inst, \"shape\", () => def.shape);\n  inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));\n  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });\n  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });\n  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });\n  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });\n  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });\n  inst.extend = (incoming) => {\n    return util_exports.extend(inst, incoming);\n  };\n  inst.merge = (other) => util_exports.merge(inst, other);\n  inst.pick = (mask) => util_exports.pick(inst, mask);\n  inst.omit = (mask) => util_exports.omit(inst, mask);\n  inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);\n  inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);\n});\nvar ZodUnion = /* @__PURE__ */ $constructor(\"ZodUnion\", (inst, def) => {\n  $ZodUnion.init(inst, def);\n  ZodType.init(inst, def);\n  inst.options = def.options;\n});\nfunction union(options, params) {\n  return new ZodUnion({\n    type: \"union\",\n    options,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodIntersection = /* @__PURE__ */ $constructor(\"ZodIntersection\", (inst, def) => {\n  $ZodIntersection.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction intersection(left, right) {\n  return new ZodIntersection({\n    type: \"intersection\",\n    left,\n    right\n  });\n}\nvar ZodEnum = /* @__PURE__ */ $constructor(\"ZodEnum\", (inst, def) => {\n  $ZodEnum.init(inst, def);\n  ZodType.init(inst, def);\n  inst.enum = def.entries;\n  inst.options = Object.values(def.entries);\n  const keys = new Set(Object.keys(def.entries));\n  inst.extract = (values, params) => {\n    const newEntries = {};\n    for (const value of values) {\n      if (keys.has(value)) {\n        newEntries[value] = def.entries[value];\n      } else\n        throw new Error(`Key ${value} not found in enum`);\n    }\n    return new ZodEnum({\n      ...def,\n      checks: [],\n      ...util_exports.normalizeParams(params),\n      entries: newEntries\n    });\n  };\n  inst.exclude = (values, params) => {\n    const newEntries = { ...def.entries };\n    for (const value of values) {\n      if (keys.has(value)) {\n        delete newEntries[value];\n      } else\n        throw new Error(`Key ${value} not found in enum`);\n    }\n    return new ZodEnum({\n      ...def,\n      checks: [],\n      ...util_exports.normalizeParams(params),\n      entries: newEntries\n    });\n  };\n});\nfunction _enum(values, params) {\n  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;\n  return new ZodEnum({\n    type: \"enum\",\n    entries,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodTransform = /* @__PURE__ */ $constructor(\"ZodTransform\", (inst, def) => {\n  $ZodTransform.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    payload.addIssue = (issue2) => {\n      if (typeof issue2 === \"string\") {\n        payload.issues.push(util_exports.issue(issue2, payload.value, def));\n      } else {\n        const _issue = issue2;\n        if (_issue.fatal)\n          _issue.continue = false;\n        _issue.code ?? (_issue.code = \"custom\");\n        _issue.input ?? (_issue.input = payload.value);\n        _issue.inst ?? (_issue.inst = inst);\n        _issue.continue ?? (_issue.continue = true);\n        payload.issues.push(util_exports.issue(_issue));\n      }\n    };\n    const output = def.transform(payload.value, payload);\n    if (output instanceof Promise) {\n      return output.then((output2) => {\n        payload.value = output2;\n        return payload;\n      });\n    }\n    payload.value = output;\n    return payload;\n  };\n});\nfunction transform(fn) {\n  return new ZodTransform({\n    type: \"transform\",\n    transform: fn\n  });\n}\nvar ZodOptional = /* @__PURE__ */ $constructor(\"ZodOptional\", (inst, def) => {\n  $ZodOptional.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction optional(innerType) {\n  return new ZodOptional({\n    type: \"optional\",\n    innerType\n  });\n}\nvar ZodNullable = /* @__PURE__ */ $constructor(\"ZodNullable\", (inst, def) => {\n  $ZodNullable.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction nullable(innerType) {\n  return new ZodNullable({\n    type: \"nullable\",\n    innerType\n  });\n}\nvar ZodDefault = /* @__PURE__ */ $constructor(\"ZodDefault\", (inst, def) => {\n  $ZodDefault.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n  inst.removeDefault = inst.unwrap;\n});\nfunction _default(innerType, defaultValue) {\n  return new ZodDefault({\n    type: \"default\",\n    innerType,\n    get defaultValue() {\n      return typeof defaultValue === \"function\" ? defaultValue() : defaultValue;\n    }\n  });\n}\nvar ZodPrefault = /* @__PURE__ */ $constructor(\"ZodPrefault\", (inst, def) => {\n  $ZodPrefault.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction prefault(innerType, defaultValue) {\n  return new ZodPrefault({\n    type: \"prefault\",\n    innerType,\n    get defaultValue() {\n      return typeof defaultValue === \"function\" ? defaultValue() : defaultValue;\n    }\n  });\n}\nvar ZodNonOptional = /* @__PURE__ */ $constructor(\"ZodNonOptional\", (inst, def) => {\n  $ZodNonOptional.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction nonoptional(innerType, params) {\n  return new ZodNonOptional({\n    type: \"nonoptional\",\n    innerType,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodCatch = /* @__PURE__ */ $constructor(\"ZodCatch\", (inst, def) => {\n  $ZodCatch.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n  inst.removeCatch = inst.unwrap;\n});\nfunction _catch(innerType, catchValue) {\n  return new ZodCatch({\n    type: \"catch\",\n    innerType,\n    catchValue: typeof catchValue === \"function\" ? catchValue : () => catchValue\n  });\n}\nvar ZodPipe = /* @__PURE__ */ $constructor(\"ZodPipe\", (inst, def) => {\n  $ZodPipe.init(inst, def);\n  ZodType.init(inst, def);\n  inst.in = def.in;\n  inst.out = def.out;\n});\nfunction pipe(in_, out) {\n  return new ZodPipe({\n    type: \"pipe\",\n    in: in_,\n    out\n    // ...util.normalizeParams(params),\n  });\n}\nvar ZodReadonly = /* @__PURE__ */ $constructor(\"ZodReadonly\", (inst, def) => {\n  $ZodReadonly.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction readonly(innerType) {\n  return new ZodReadonly({\n    type: \"readonly\",\n    innerType\n  });\n}\nvar ZodCustom = /* @__PURE__ */ $constructor(\"ZodCustom\", (inst, def) => {\n  $ZodCustom.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction check(fn) {\n  const ch = new $ZodCheck({\n    check: \"custom\"\n    // ...util.normalizeParams(params),\n  });\n  ch._zod.check = fn;\n  return ch;\n}\nfunction refine(fn, _params = {}) {\n  return _refine(ZodCustom, fn, _params);\n}\nfunction superRefine(fn) {\n  const ch = check((payload) => {\n    payload.addIssue = (issue2) => {\n      if (typeof issue2 === \"string\") {\n        payload.issues.push(util_exports.issue(issue2, payload.value, ch._zod.def));\n      } else {\n        const _issue = issue2;\n        if (_issue.fatal)\n          _issue.continue = false;\n        _issue.code ?? (_issue.code = \"custom\");\n        _issue.input ?? (_issue.input = payload.value);\n        _issue.inst ?? (_issue.inst = ch);\n        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);\n        payload.issues.push(util_exports.issue(_issue));\n      }\n    };\n    return fn(payload.value, payload);\n  });\n  return ch;\n}\n\n// src/openapi.ts\nvar paths = {};\nfunction getTypeFromZodType(zodType) {\n  switch (zodType.constructor.name) {\n    case \"ZodString\":\n      return \"string\";\n    case \"ZodNumber\":\n      return \"number\";\n    case \"ZodBoolean\":\n      return \"boolean\";\n    case \"ZodObject\":\n      return \"object\";\n    case \"ZodArray\":\n      return \"array\";\n    default:\n      return \"string\";\n  }\n}\nfunction getParameters(options) {\n  const parameters = [];\n  if (options.metadata?.openapi?.parameters) {\n    parameters.push(...options.metadata.openapi.parameters);\n    return parameters;\n  }\n  if (options.query instanceof ZodObject) {\n    Object.entries(options.query.shape).forEach(([key, value]) => {\n      if (value instanceof ZodObject) {\n        parameters.push({\n          name: key,\n          in: \"query\",\n          schema: {\n            type: getTypeFromZodType(value),\n            ...\"minLength\" in value && value.minLength ? {\n              minLength: value.minLength\n            } : {},\n            description: value.description\n          }\n        });\n      }\n    });\n  }\n  return parameters;\n}\nfunction getRequestBody(options) {\n  if (options.metadata?.openapi?.requestBody) {\n    return options.metadata.openapi.requestBody;\n  }\n  if (!options.body) return void 0;\n  if (options.body instanceof ZodObject || options.body instanceof ZodOptional) {\n    const shape = options.body.shape;\n    if (!shape) return void 0;\n    const properties = {};\n    const required2 = [];\n    Object.entries(shape).forEach(([key, value]) => {\n      if (value instanceof ZodObject) {\n        properties[key] = {\n          type: getTypeFromZodType(value),\n          description: value.description\n        };\n        if (!(value instanceof ZodOptional)) {\n          required2.push(key);\n        }\n      }\n    });\n    return {\n      required: options.body instanceof ZodOptional ? false : options.body ? true : false,\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties,\n            required: required2\n          }\n        }\n      }\n    };\n  }\n  return void 0;\n}\nfunction getResponse(responses) {\n  return {\n    \"400\": {\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties: {\n              message: {\n                type: \"string\"\n              }\n            },\n            required: [\"message\"]\n          }\n        }\n      },\n      description: \"Bad Request. Usually due to missing parameters, or invalid parameters.\"\n    },\n    \"401\": {\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties: {\n              message: {\n                type: \"string\"\n              }\n            },\n            required: [\"message\"]\n          }\n        }\n      },\n      description: \"Unauthorized. Due to missing or invalid authentication.\"\n    },\n    \"403\": {\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties: {\n              message: {\n                type: \"string\"\n              }\n            }\n          }\n        }\n      },\n      description: \"Forbidden. You do not have permission to access this resource or to perform this action.\"\n    },\n    \"404\": {\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties: {\n              message: {\n                type: \"string\"\n              }\n            }\n          }\n        }\n      },\n      description: \"Not Found. The requested resource was not found.\"\n    },\n    \"429\": {\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties: {\n              message: {\n                type: \"string\"\n              }\n            }\n          }\n        }\n      },\n      description: \"Too Many Requests. You have exceeded the rate limit. Try again later.\"\n    },\n    \"500\": {\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties: {\n              message: {\n                type: \"string\"\n              }\n            }\n          }\n        }\n      },\n      description: \"Internal Server Error. This is a problem with the server that you cannot fix.\"\n    },\n    ...responses\n  };\n}\nasync function generator(endpoints, config2) {\n  const components = {\n    schemas: {}\n  };\n  Object.entries(endpoints).forEach(([_, value]) => {\n    const options = value.options;\n    if (options.metadata?.SERVER_ONLY) return;\n    if (options.method === \"GET\") {\n      paths[value.path] = {\n        get: {\n          tags: [\"Default\", ...options.metadata?.openapi?.tags || []],\n          description: options.metadata?.openapi?.description,\n          operationId: options.metadata?.openapi?.operationId,\n          security: [\n            {\n              bearerAuth: []\n            }\n          ],\n          parameters: getParameters(options),\n          responses: getResponse(options.metadata?.openapi?.responses)\n        }\n      };\n    }\n    if (options.method === \"POST\") {\n      const body = getRequestBody(options);\n      paths[value.path] = {\n        post: {\n          tags: [\"Default\", ...options.metadata?.openapi?.tags || []],\n          description: options.metadata?.openapi?.description,\n          operationId: options.metadata?.openapi?.operationId,\n          security: [\n            {\n              bearerAuth: []\n            }\n          ],\n          parameters: getParameters(options),\n          ...body ? { requestBody: body } : {\n            requestBody: {\n              //set body none\n              content: {\n                \"application/json\": {\n                  schema: {\n                    type: \"object\",\n                    properties: {}\n                  }\n                }\n              }\n            }\n          },\n          responses: getResponse(options.metadata?.openapi?.responses)\n        }\n      };\n    }\n  });\n  const res = {\n    openapi: \"3.1.1\",\n    info: {\n      title: \"Better Auth\",\n      description: \"API Reference for your Better Auth Instance\",\n      version: \"1.1.0\"\n    },\n    components,\n    security: [\n      {\n        apiKeyCookie: []\n      }\n    ],\n    servers: [\n      {\n        url: config2?.url\n      }\n    ],\n    tags: [\n      {\n        name: \"Default\",\n        description: \"Default endpoints that are included with Better Auth by default. These endpoints are not part of any plugin.\"\n      }\n    ],\n    paths\n  };\n  return res;\n}\nvar getHTML = (apiReference, config2) => `<!doctype html>\n<html>\n  <head>\n    <title>Scalar API Reference</title>\n    <meta charset=\"utf-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1\" />\n  </head>\n  <body>\n    <script\n      id=\"api-reference\"\n      type=\"application/json\">\n    ${JSON.stringify(apiReference)}\n    </script>\n\t <script>\n      var configuration = {\n\t  \tfavicon: ${config2?.logo ? `data:image/svg+xml;utf8,${encodeURIComponent(config2.logo)}` : void 0} ,\n\t   \ttheme: ${config2?.theme || \"saturn\"},\n        metaData: {\n\t\t\ttitle: ${config2?.title || \"Open API Reference\"},\n\t\t\tdescription: ${config2?.description || \"Better Call Open API\"},\n\t\t}\n      }\n      document.getElementById('api-reference').dataset.configuration =\n        JSON.stringify(configuration)\n    </script>\n\t  <script src=\"https://cdn.jsdelivr.net/npm/@scalar/api-reference\"></script>\n  </body>\n</html>`;\n\n// src/router.ts\nvar createRouter = (endpoints, config2) => {\n  if (!config2?.openapi?.disabled) {\n    const openapi = {\n      path: \"/api/reference\",\n      ...config2?.openapi\n    };\n    endpoints[\"openapi\"] = createEndpoint2(\n      openapi.path,\n      {\n        method: \"GET\"\n      },\n      async (c) => {\n        const schema = await generator(endpoints);\n        return new Response(getHTML(schema, openapi.scalar), {\n          headers: {\n            \"Content-Type\": \"text/html\"\n          }\n        });\n      }\n    );\n  }\n  const router = (0,rou3__WEBPACK_IMPORTED_MODULE_1__.createRouter)();\n  const middlewareRouter = (0,rou3__WEBPACK_IMPORTED_MODULE_1__.createRouter)();\n  for (const endpoint of Object.values(endpoints)) {\n    if (!endpoint.options) {\n      continue;\n    }\n    if (endpoint.options?.metadata?.SERVER_ONLY) continue;\n    const methods = Array.isArray(endpoint.options?.method) ? endpoint.options.method : [endpoint.options?.method];\n    for (const method of methods) {\n      (0,rou3__WEBPACK_IMPORTED_MODULE_1__.addRoute)(router, method, endpoint.path, endpoint);\n    }\n  }\n  if (config2?.routerMiddleware?.length) {\n    for (const { path, middleware } of config2.routerMiddleware) {\n      (0,rou3__WEBPACK_IMPORTED_MODULE_1__.addRoute)(middlewareRouter, \"*\", path, middleware);\n    }\n  }\n  const processRequest = async (request) => {\n    const url = new URL(request.url);\n    const path = config2?.basePath ? url.pathname.split(config2.basePath).reduce((acc, curr, index) => {\n      if (index !== 0) {\n        if (index > 1) {\n          acc.push(`${config2.basePath}${curr}`);\n        } else {\n          acc.push(curr);\n        }\n      }\n      return acc;\n    }, []).join(\"\") : url.pathname;\n    if (!path?.length) {\n      return new Response(null, { status: 404, statusText: \"Not Found\" });\n    }\n    const route = (0,rou3__WEBPACK_IMPORTED_MODULE_1__.findRoute)(router, request.method, path);\n    if (!route?.data) {\n      return new Response(null, { status: 404, statusText: \"Not Found\" });\n    }\n    const query = {};\n    url.searchParams.forEach((value, key) => {\n      if (key in query) {\n        if (Array.isArray(query[key])) {\n          query[key].push(value);\n        } else {\n          query[key] = [query[key], value];\n        }\n      } else {\n        query[key] = value;\n      }\n    });\n    const handler = route.data;\n    const context = {\n      path,\n      method: request.method,\n      headers: request.headers,\n      params: route.params ? JSON.parse(JSON.stringify(route.params)) : {},\n      request,\n      body: handler.options.disableBody ? void 0 : await getBody(handler.options.cloneRequest ? request.clone() : request),\n      query,\n      _flag: \"router\",\n      asResponse: true,\n      context: config2?.routerContext\n    };\n    try {\n      const middlewareRoutes = (0,rou3__WEBPACK_IMPORTED_MODULE_1__.findAllRoutes)(middlewareRouter, \"*\", path);\n      if (middlewareRoutes?.length) {\n        for (const { data: middleware, params } of middlewareRoutes) {\n          const res = await middleware({\n            ...context,\n            params,\n            asResponse: false\n          });\n          if (res instanceof Response) return res;\n        }\n      }\n      const response = await handler(context);\n      return response;\n    } catch (error) {\n      if (config2?.onError) {\n        try {\n          const errorResponse = await config2.onError(error);\n          if (errorResponse instanceof Response) {\n            return toResponse(errorResponse);\n          }\n        } catch (error2) {\n          if (isAPIError(error2)) {\n            return toResponse(error2);\n          }\n          throw error2;\n        }\n      }\n      if (config2?.throwError) {\n        throw error;\n      }\n      if (isAPIError(error)) {\n        return toResponse(error);\n      }\n      console.error(`# SERVER_ERROR: `, error);\n      return new Response(null, {\n        status: 500,\n        statusText: \"Internal Server Error\"\n      });\n    }\n  };\n  return {\n    handler: async (request) => {\n      const onReq = await config2?.onRequest?.(request);\n      if (onReq instanceof Response) {\n        return onReq;\n      }\n      const req = onReq instanceof Request ? onReq : request;\n      const res = await processRequest(req);\n      const onRes = await config2?.onResponse?.(res);\n      if (onRes instanceof Response) {\n        return onRes;\n      }\n      return res;\n    },\n    endpoints\n  };\n};\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYmV0dGVyLWNhbGwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsYUFBYTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gscUNBQXFDLGFBQWE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEVBQUU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdDQUF3QztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtB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O0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQyxPQUFPLGlDQUFpQyxZQUFZO0FBQ3ZHLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0EsWUFBWSx1Q0FBdUM7QUFDbkQsa0JBQWtCLCtDQUErQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrREFBZ0I7QUFDakMsMkJBQTJCLGtEQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sOENBQVE7QUFDZDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDLE1BQU0sOENBQVE7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUIsRUFBRSxLQUFLO0FBQzlDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtDQUFrQyxzQ0FBc0M7QUFDeEU7QUFDQSxrQkFBa0IsK0NBQVM7QUFDM0I7QUFDQSxrQ0FBa0Msc0NBQXNDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1EQUFhO0FBQzVDO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBaUJFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hdXRvcGxhbmNhbS8uL25vZGVfbW9kdWxlcy9iZXR0ZXItY2FsbC9kaXN0L2luZGV4LmpzP2MyOTAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gc3JjL2Vycm9yLnRzXG5mdW5jdGlvbiBpc0Vycm9yU3RhY2tUcmFjZUxpbWl0V3JpdGFibGUoKSB7XG4gIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEVycm9yLCBcInN0YWNrVHJhY2VMaW1pdFwiKTtcbiAgaWYgKGRlc2MgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBPYmplY3QuaXNFeHRlbnNpYmxlKEVycm9yKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlc2MsIFwid3JpdGFibGVcIikgPyBkZXNjLndyaXRhYmxlIDogZGVzYy5zZXQgIT09IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGhpZGVJbnRlcm5hbFN0YWNrRnJhbWVzKHN0YWNrKSB7XG4gIGNvbnN0IGxpbmVzID0gc3RhY2suc3BsaXQoXCJcXG4gICAgYXQgXCIpO1xuICBpZiAobGluZXMubGVuZ3RoIDw9IDEpIHtcbiAgICByZXR1cm4gc3RhY2s7XG4gIH1cbiAgbGluZXMuc3BsaWNlKDEsIDEpO1xuICByZXR1cm4gbGluZXMuam9pbihcIlxcbiAgICBhdCBcIik7XG59XG5mdW5jdGlvbiBtYWtlRXJyb3JGb3JIaWRlU3RhY2tGcmFtZShCYXNlLCBjbGF6eikge1xuICBjbGFzcyBIaWRlU3RhY2tGcmFtZXNFcnJvciBleHRlbmRzIEJhc2Uge1xuICAgICNoaWRkZW5TdGFjaztcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICBpZiAoaXNFcnJvclN0YWNrVHJhY2VMaW1pdFdyaXRhYmxlKCkpIHtcbiAgICAgICAgY29uc3QgbGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gICAgICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDA7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBsaW1pdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICAgIGlmIChzdGFjaykge1xuICAgICAgICB0aGlzLiNoaWRkZW5TdGFjayA9IGhpZGVJbnRlcm5hbFN0YWNrRnJhbWVzKHN0YWNrLnJlcGxhY2UoL15FcnJvci8sIHRoaXMubmFtZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB1c2UgYGdldHRlcmAgaGVyZSB0byBhdm9pZCB0aGUgc3RhY2sgdHJhY2UgYmVpbmcgY2FwdHVyZWQgYnkgbG9nZ2Vyc1xuICAgIGdldCBlcnJvclN0YWNrKCkge1xuICAgICAgcmV0dXJuIHRoaXMuI2hpZGRlblN0YWNrO1xuICAgIH1cbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGlkZVN0YWNrRnJhbWVzRXJyb3IucHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gY2xheno7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBIaWRlU3RhY2tGcmFtZXNFcnJvcjtcbn1cbnZhciBfc3RhdHVzQ29kZSA9IHtcbiAgT0s6IDIwMCxcbiAgQ1JFQVRFRDogMjAxLFxuICBBQ0NFUFRFRDogMjAyLFxuICBOT19DT05URU5UOiAyMDQsXG4gIE1VTFRJUExFX0NIT0lDRVM6IDMwMCxcbiAgTU9WRURfUEVSTUFORU5UTFk6IDMwMSxcbiAgRk9VTkQ6IDMwMixcbiAgU0VFX09USEVSOiAzMDMsXG4gIE5PVF9NT0RJRklFRDogMzA0LFxuICBURU1QT1JBUllfUkVESVJFQ1Q6IDMwNyxcbiAgQkFEX1JFUVVFU1Q6IDQwMCxcbiAgVU5BVVRIT1JJWkVEOiA0MDEsXG4gIFBBWU1FTlRfUkVRVUlSRUQ6IDQwMixcbiAgRk9SQklEREVOOiA0MDMsXG4gIE5PVF9GT1VORDogNDA0LFxuICBNRVRIT0RfTk9UX0FMTE9XRUQ6IDQwNSxcbiAgTk9UX0FDQ0VQVEFCTEU6IDQwNixcbiAgUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQ6IDQwNyxcbiAgUkVRVUVTVF9USU1FT1VUOiA0MDgsXG4gIENPTkZMSUNUOiA0MDksXG4gIEdPTkU6IDQxMCxcbiAgTEVOR1RIX1JFUVVJUkVEOiA0MTEsXG4gIFBSRUNPTkRJVElPTl9GQUlMRUQ6IDQxMixcbiAgUEFZTE9BRF9UT09fTEFSR0U6IDQxMyxcbiAgVVJJX1RPT19MT05HOiA0MTQsXG4gIFVOU1VQUE9SVEVEX01FRElBX1RZUEU6IDQxNSxcbiAgUkFOR0VfTk9UX1NBVElTRklBQkxFOiA0MTYsXG4gIEVYUEVDVEFUSU9OX0ZBSUxFRDogNDE3LFxuICBcIkknTV9BX1RFQVBPVFwiOiA0MTgsXG4gIE1JU0RJUkVDVEVEX1JFUVVFU1Q6IDQyMSxcbiAgVU5QUk9DRVNTQUJMRV9FTlRJVFk6IDQyMixcbiAgTE9DS0VEOiA0MjMsXG4gIEZBSUxFRF9ERVBFTkRFTkNZOiA0MjQsXG4gIFRPT19FQVJMWTogNDI1LFxuICBVUEdSQURFX1JFUVVJUkVEOiA0MjYsXG4gIFBSRUNPTkRJVElPTl9SRVFVSVJFRDogNDI4LFxuICBUT09fTUFOWV9SRVFVRVNUUzogNDI5LFxuICBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFOiA0MzEsXG4gIFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TOiA0NTEsXG4gIElOVEVSTkFMX1NFUlZFUl9FUlJPUjogNTAwLFxuICBOT1RfSU1QTEVNRU5URUQ6IDUwMSxcbiAgQkFEX0dBVEVXQVk6IDUwMixcbiAgU0VSVklDRV9VTkFWQUlMQUJMRTogNTAzLFxuICBHQVRFV0FZX1RJTUVPVVQ6IDUwNCxcbiAgSFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQ6IDUwNSxcbiAgVkFSSUFOVF9BTFNPX05FR09USUFURVM6IDUwNixcbiAgSU5TVUZGSUNJRU5UX1NUT1JBR0U6IDUwNyxcbiAgTE9PUF9ERVRFQ1RFRDogNTA4LFxuICBOT1RfRVhURU5ERUQ6IDUxMCxcbiAgTkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRDogNTExXG59O1xudmFyIEludGVybmFsQVBJRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc3RhdHVzID0gXCJJTlRFUk5BTF9TRVJWRVJfRVJST1JcIiwgYm9keSA9IHZvaWQgMCwgaGVhZGVycyA9IHt9LCBzdGF0dXNDb2RlID0gdHlwZW9mIHN0YXR1cyA9PT0gXCJudW1iZXJcIiA/IHN0YXR1cyA6IF9zdGF0dXNDb2RlW3N0YXR1c10pIHtcbiAgICBzdXBlcihcbiAgICAgIGJvZHk/Lm1lc3NhZ2UsXG4gICAgICBib2R5Py5jYXVzZSA/IHtcbiAgICAgICAgY2F1c2U6IGJvZHkuY2F1c2VcbiAgICAgIH0gOiB2b2lkIDBcbiAgICApO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMubmFtZSA9IFwiQVBJRXJyb3JcIjtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgdGhpcy5ib2R5ID0gYm9keSA/IHtcbiAgICAgIGNvZGU6IGJvZHk/Lm1lc3NhZ2U/LnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvIC9nLCBcIl9cIikucmVwbGFjZSgvW15BLVowLTlfXS9nLCBcIlwiKSxcbiAgICAgIC4uLmJvZHlcbiAgICB9IDogdm9pZCAwO1xuICB9XG59O1xudmFyIEFQSUVycm9yID0gbWFrZUVycm9yRm9ySGlkZVN0YWNrRnJhbWUoSW50ZXJuYWxBUElFcnJvciwgRXJyb3IpO1xuXG4vLyBzcmMvdXRpbHMudHNcbmFzeW5jIGZ1bmN0aW9uIGdldEJvZHkocmVxdWVzdCkge1xuICBjb25zdCBjb250ZW50VHlwZSA9IHJlcXVlc3QuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikgfHwgXCJcIjtcbiAgaWYgKCFyZXF1ZXN0LmJvZHkpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICByZXR1cm4gYXdhaXQgcmVxdWVzdC5qc29uKCk7XG4gIH1cbiAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpKSB7XG4gICAgY29uc3QgZm9ybURhdGEgPSBhd2FpdCByZXF1ZXN0LmZvcm1EYXRhKCk7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9ybURhdGEuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiKSkge1xuICAgIGNvbnN0IGZvcm1EYXRhID0gYXdhaXQgcmVxdWVzdC5mb3JtRGF0YSgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvcm1EYXRhLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoY29udGVudFR5cGUuaW5jbHVkZXMoXCJ0ZXh0L3BsYWluXCIpKSB7XG4gICAgcmV0dXJuIGF3YWl0IHJlcXVlc3QudGV4dCgpO1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiKSkge1xuICAgIHJldHVybiBhd2FpdCByZXF1ZXN0LmFycmF5QnVmZmVyKCk7XG4gIH1cbiAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vcGRmXCIpIHx8IGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiaW1hZ2UvXCIpIHx8IGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwidmlkZW8vXCIpKSB7XG4gICAgY29uc3QgYmxvYiA9IGF3YWl0IHJlcXVlc3QuYmxvYigpO1xuICAgIHJldHVybiBibG9iO1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL3N0cmVhbVwiKSB8fCByZXF1ZXN0LmJvZHkgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkge1xuICAgIHJldHVybiByZXF1ZXN0LmJvZHk7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IHJlcXVlc3QudGV4dCgpO1xufVxuZnVuY3Rpb24gaXNBUElFcnJvcihlcnJvcikge1xuICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBBUElFcnJvciB8fCBlcnJvcj8ubmFtZSA9PT0gXCJBUElFcnJvclwiO1xufVxuZnVuY3Rpb24gdHJ5RGVjb2RlKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBzdHIuaW5jbHVkZXMoXCIlXCIpID8gZGVjb2RlVVJJQ29tcG9uZW50KHN0cikgOiBzdHI7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuLy8gc3JjL3RvLXJlc3BvbnNlLnRzXG5mdW5jdGlvbiBpc0pTT05TZXJpYWxpemFibGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHQgPT09IFwic3RyaW5nXCIgfHwgdCA9PT0gXCJudW1iZXJcIiB8fCB0ID09PSBcImJvb2xlYW5cIiB8fCB0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHQgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlLmJ1ZmZlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IubmFtZSA9PT0gXCJPYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUudG9KU09OID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBzYWZlU3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gIGxldCBpZCA9IDA7XG4gIGNvbnN0IHNlZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3Qgc2FmZVJlcGxhY2VyID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKHNlZW4uaGFzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYFtDaXJjdWxhciByZWYtJHtzZWVuLmdldCh2YWx1ZSl9XWA7XG4gICAgICB9XG4gICAgICBzZWVuLnNldCh2YWx1ZSwgaWQrKyk7XG4gICAgfVxuICAgIGlmIChyZXBsYWNlcikge1xuICAgICAgcmV0dXJuIHJlcGxhY2VyKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIHNhZmVSZXBsYWNlciwgc3BhY2UpO1xufVxuZnVuY3Rpb24gaXNKU09OUmVzcG9uc2UodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIFwiX2ZsYWdcIiBpbiB2YWx1ZSAmJiB2YWx1ZS5fZmxhZyA9PT0gXCJqc29uXCI7XG59XG5mdW5jdGlvbiB0b1Jlc3BvbnNlKGRhdGEsIGluaXQpIHtcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgIGlmIChpbml0Py5oZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgICAgaW5pdC5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgZGF0YS5oZWFkZXJzLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBjb25zdCBpc0pTT04gPSBpc0pTT05SZXNwb25zZShkYXRhKTtcbiAgaWYgKGlzSlNPTikge1xuICAgIGNvbnN0IGJvZHkyID0gZGF0YS5ib2R5O1xuICAgIGNvbnN0IHJvdXRlclJlc3BvbnNlID0gZGF0YS5yb3V0ZXJSZXNwb25zZTtcbiAgICBpZiAocm91dGVyUmVzcG9uc2UgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHJvdXRlclJlc3BvbnNlO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXJzMiA9IG5ldyBIZWFkZXJzKHtcbiAgICAgIC4uLnJvdXRlclJlc3BvbnNlPy5oZWFkZXJzLFxuICAgICAgLi4uZGF0YS5oZWFkZXJzLFxuICAgICAgLi4uaW5pdD8uaGVhZGVycyxcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShib2R5MiksIHtcbiAgICAgIC4uLnJvdXRlclJlc3BvbnNlLFxuICAgICAgaGVhZGVyczogaGVhZGVyczIsXG4gICAgICBzdGF0dXM6IGRhdGEuc3RhdHVzID8/IGluaXQ/LnN0YXR1cyA/PyByb3V0ZXJSZXNwb25zZT8uc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogaW5pdD8uc3RhdHVzVGV4dCA/PyByb3V0ZXJSZXNwb25zZT8uc3RhdHVzVGV4dFxuICAgIH0pO1xuICB9XG4gIGlmIChpc0FQSUVycm9yKGRhdGEpKSB7XG4gICAgcmV0dXJuIHRvUmVzcG9uc2UoZGF0YS5ib2R5LCB7XG4gICAgICBzdGF0dXM6IGluaXQ/LnN0YXR1cyA/PyBkYXRhLnN0YXR1c0NvZGUsXG4gICAgICBzdGF0dXNUZXh0OiBkYXRhLnN0YXR1cy50b1N0cmluZygpLFxuICAgICAgaGVhZGVyczogaW5pdD8uaGVhZGVycyB8fCBkYXRhLmhlYWRlcnNcbiAgICB9KTtcbiAgfVxuICBsZXQgYm9keSA9IGRhdGE7XG4gIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5pdD8uaGVhZGVycyk7XG4gIGlmICghZGF0YSkge1xuICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkobnVsbCk7XG4gICAgfVxuICAgIGhlYWRlcnMuc2V0KFwiY29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGJvZHkgPSBkYXRhO1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwidGV4dC9wbGFpblwiKTtcbiAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgYm9keSA9IGRhdGE7XG4gICAgaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIik7XG4gIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICBib2R5ID0gZGF0YTtcbiAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBkYXRhLnR5cGUgfHwgXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIik7XG4gIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgYm9keSA9IGRhdGE7XG4gIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykge1xuICAgIGJvZHkgPSBkYXRhO1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpO1xuICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkge1xuICAgIGJvZHkgPSBkYXRhO1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIpO1xuICB9IGVsc2UgaWYgKGlzSlNPTlNlcmlhbGl6YWJsZShkYXRhKSkge1xuICAgIGJvZHkgPSBzYWZlU3RyaW5naWZ5KGRhdGEpO1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgfVxuICByZXR1cm4gbmV3IFJlc3BvbnNlKGJvZHksIHtcbiAgICAuLi5pbml0LFxuICAgIGhlYWRlcnNcbiAgfSk7XG59XG5cbi8vIHNyYy92YWxpZGF0b3IudHNcbmFzeW5jIGZ1bmN0aW9uIHJ1blZhbGlkYXRpb24ob3B0aW9ucywgY29udGV4dCA9IHt9KSB7XG4gIGxldCByZXF1ZXN0ID0ge1xuICAgIGJvZHk6IGNvbnRleHQuYm9keSxcbiAgICBxdWVyeTogY29udGV4dC5xdWVyeVxuICB9O1xuICBpZiAob3B0aW9ucy5ib2R5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3B0aW9ucy5ib2R5W1wifnN0YW5kYXJkXCJdLnZhbGlkYXRlKGNvbnRleHQuYm9keSk7XG4gICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiBmcm9tRXJyb3IocmVzdWx0Lmlzc3VlcywgXCJib2R5XCIpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXF1ZXN0LmJvZHkgPSByZXN1bHQudmFsdWU7XG4gIH1cbiAgaWYgKG9wdGlvbnMucXVlcnkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvcHRpb25zLnF1ZXJ5W1wifnN0YW5kYXJkXCJdLnZhbGlkYXRlKGNvbnRleHQucXVlcnkpO1xuICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogZnJvbUVycm9yKHJlc3VsdC5pc3N1ZXMsIFwicXVlcnlcIilcbiAgICAgIH07XG4gICAgfVxuICAgIHJlcXVlc3QucXVlcnkgPSByZXN1bHQudmFsdWU7XG4gIH1cbiAgaWYgKG9wdGlvbnMucmVxdWlyZUhlYWRlcnMgJiYgIWNvbnRleHQuaGVhZGVycykge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgZXJyb3I6IHsgbWVzc2FnZTogXCJIZWFkZXJzIGlzIHJlcXVpcmVkXCIgfVxuICAgIH07XG4gIH1cbiAgaWYgKG9wdGlvbnMucmVxdWlyZVJlcXVlc3QgJiYgIWNvbnRleHQucmVxdWVzdCkge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgZXJyb3I6IHsgbWVzc2FnZTogXCJSZXF1ZXN0IGlzIHJlcXVpcmVkXCIgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkYXRhOiByZXF1ZXN0LFxuICAgIGVycm9yOiBudWxsXG4gIH07XG59XG5mdW5jdGlvbiBmcm9tRXJyb3IoZXJyb3IsIHZhbGlkYXRpbmcpIHtcbiAgY29uc3QgZXJyb3JNZXNzYWdlcyA9IFtdO1xuICBmb3IgKGNvbnN0IGlzc3VlMiBvZiBlcnJvcikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBpc3N1ZTIubWVzc2FnZTtcbiAgICBlcnJvck1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlOiBgSW52YWxpZCAke3ZhbGlkYXRpbmd9IHBhcmFtZXRlcnNgXG4gIH07XG59XG5cbi8vIHNyYy9jcnlwdG8udHNcbmltcG9ydCB7IGdldFdlYmNyeXB0b1N1YnRsZSB9IGZyb20gXCJAYmV0dGVyLWF1dGgvdXRpbHNcIjtcbnZhciBhbGdvcml0aG0gPSB7IG5hbWU6IFwiSE1BQ1wiLCBoYXNoOiBcIlNIQS0yNTZcIiB9O1xudmFyIGdldENyeXB0b0tleSA9IGFzeW5jIChzZWNyZXQpID0+IHtcbiAgY29uc3Qgc2VjcmV0QnVmID0gdHlwZW9mIHNlY3JldCA9PT0gXCJzdHJpbmdcIiA/IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzZWNyZXQpIDogc2VjcmV0O1xuICByZXR1cm4gYXdhaXQgZ2V0V2ViY3J5cHRvU3VidGxlKCkuaW1wb3J0S2V5KFwicmF3XCIsIHNlY3JldEJ1ZiwgYWxnb3JpdGhtLCBmYWxzZSwgW1xuICAgIFwic2lnblwiLFxuICAgIFwidmVyaWZ5XCJcbiAgXSk7XG59O1xudmFyIHZlcmlmeVNpZ25hdHVyZSA9IGFzeW5jIChiYXNlNjRTaWduYXR1cmUsIHZhbHVlLCBzZWNyZXQpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzaWduYXR1cmVCaW5TdHIgPSBhdG9iKGJhc2U2NFNpZ25hdHVyZSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gbmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlQmluU3RyLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNpZ25hdHVyZUJpblN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2lnbmF0dXJlW2ldID0gc2lnbmF0dXJlQmluU3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBnZXRXZWJjcnlwdG9TdWJ0bGUoKS52ZXJpZnkoXG4gICAgICBhbGdvcml0aG0sXG4gICAgICBzZWNyZXQsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodmFsdWUpXG4gICAgKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbnZhciBtYWtlU2lnbmF0dXJlID0gYXN5bmMgKHZhbHVlLCBzZWNyZXQpID0+IHtcbiAgY29uc3Qga2V5ID0gYXdhaXQgZ2V0Q3J5cHRvS2V5KHNlY3JldCk7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IGdldFdlYmNyeXB0b1N1YnRsZSgpLnNpZ24oXG4gICAgYWxnb3JpdGhtLm5hbWUsXG4gICAga2V5LFxuICAgIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSlcbiAgKTtcbiAgcmV0dXJuIGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5uZXcgVWludDhBcnJheShzaWduYXR1cmUpKSk7XG59O1xudmFyIHNpZ25Db29raWVWYWx1ZSA9IGFzeW5jICh2YWx1ZSwgc2VjcmV0KSA9PiB7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IG1ha2VTaWduYXR1cmUodmFsdWUsIHNlY3JldCk7XG4gIHZhbHVlID0gYCR7dmFsdWV9LiR7c2lnbmF0dXJlfWA7XG4gIHZhbHVlID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLy8gc3JjL2Nvb2tpZXMudHNcbnZhciBnZXRDb29raWVLZXkgPSAoa2V5LCBwcmVmaXgpID0+IHtcbiAgbGV0IGZpbmFsS2V5ID0ga2V5O1xuICBpZiAocHJlZml4KSB7XG4gICAgaWYgKHByZWZpeCA9PT0gXCJzZWN1cmVcIikge1xuICAgICAgZmluYWxLZXkgPSBcIl9fU2VjdXJlLVwiICsga2V5O1xuICAgIH0gZWxzZSBpZiAocHJlZml4ID09PSBcImhvc3RcIikge1xuICAgICAgZmluYWxLZXkgPSBcIl9fSG9zdC1cIiArIGtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbmFsS2V5O1xufTtcbmZ1bmN0aW9uIHBhcnNlQ29va2llcyhzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJndW1lbnQgc3RyIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gIH1cbiAgY29uc3QgY29va2llcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCBpbmRleCA9IDA7XG4gIHdoaWxlIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBjb25zdCBlcUlkeCA9IHN0ci5pbmRleE9mKFwiPVwiLCBpbmRleCk7XG4gICAgaWYgKGVxSWR4ID09PSAtMSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCBlbmRJZHggPSBzdHIuaW5kZXhPZihcIjtcIiwgaW5kZXgpO1xuICAgIGlmIChlbmRJZHggPT09IC0xKSB7XG4gICAgICBlbmRJZHggPSBzdHIubGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAoZW5kSWR4IDwgZXFJZHgpIHtcbiAgICAgIGluZGV4ID0gc3RyLmxhc3RJbmRleE9mKFwiO1wiLCBlcUlkeCAtIDEpICsgMTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBzdHIuc2xpY2UoaW5kZXgsIGVxSWR4KS50cmltKCk7XG4gICAgaWYgKCFjb29raWVzLmhhcyhrZXkpKSB7XG4gICAgICBsZXQgdmFsID0gc3RyLnNsaWNlKGVxSWR4ICsgMSwgZW5kSWR4KS50cmltKCk7XG4gICAgICBpZiAodmFsLmNvZGVQb2ludEF0KDApID09PSAzNCkge1xuICAgICAgICB2YWwgPSB2YWwuc2xpY2UoMSwgLTEpO1xuICAgICAgfVxuICAgICAgY29va2llcy5zZXQoa2V5LCB0cnlEZWNvZGUodmFsKSk7XG4gICAgfVxuICAgIGluZGV4ID0gZW5kSWR4ICsgMTtcbiAgfVxuICByZXR1cm4gY29va2llcztcbn1cbnZhciBfc2VyaWFsaXplID0gKGtleSwgdmFsdWUsIG9wdCA9IHt9KSA9PiB7XG4gIGxldCBjb29raWU7XG4gIGlmIChvcHQ/LnByZWZpeCA9PT0gXCJzZWN1cmVcIikge1xuICAgIGNvb2tpZSA9IGAke2BfX1NlY3VyZS0ke2tleX1gfT0ke3ZhbHVlfWA7XG4gIH0gZWxzZSBpZiAob3B0Py5wcmVmaXggPT09IFwiaG9zdFwiKSB7XG4gICAgY29va2llID0gYCR7YF9fSG9zdC0ke2tleX1gfT0ke3ZhbHVlfWA7XG4gIH0gZWxzZSB7XG4gICAgY29va2llID0gYCR7a2V5fT0ke3ZhbHVlfWA7XG4gIH1cbiAgaWYgKGtleS5zdGFydHNXaXRoKFwiX19TZWN1cmUtXCIpICYmICFvcHQuc2VjdXJlKSB7XG4gICAgb3B0LnNlY3VyZSA9IHRydWU7XG4gIH1cbiAgaWYgKGtleS5zdGFydHNXaXRoKFwiX19Ib3N0LVwiKSkge1xuICAgIGlmICghb3B0LnNlY3VyZSkge1xuICAgICAgb3B0LnNlY3VyZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHQucGF0aCAhPT0gXCIvXCIpIHtcbiAgICAgIG9wdC5wYXRoID0gXCIvXCI7XG4gICAgfVxuICAgIGlmIChvcHQuZG9tYWluKSB7XG4gICAgICBvcHQuZG9tYWluID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBpZiAob3B0ICYmIHR5cGVvZiBvcHQubWF4QWdlID09PSBcIm51bWJlclwiICYmIG9wdC5tYXhBZ2UgPj0gMCkge1xuICAgIGlmIChvcHQubWF4QWdlID4gMzQ1NmU0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ29va2llcyBNYXgtQWdlIFNIT1VMRCBOT1QgYmUgZ3JlYXRlciB0aGFuIDQwMCBkYXlzICgzNDU2MDAwMCBzZWNvbmRzKSBpbiBkdXJhdGlvbi5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29va2llICs9IGA7IE1heC1BZ2U9JHtNYXRoLmZsb29yKG9wdC5tYXhBZ2UpfWA7XG4gIH1cbiAgaWYgKG9wdC5kb21haW4gJiYgb3B0LnByZWZpeCAhPT0gXCJob3N0XCIpIHtcbiAgICBjb29raWUgKz0gYDsgRG9tYWluPSR7b3B0LmRvbWFpbn1gO1xuICB9XG4gIGlmIChvcHQucGF0aCkge1xuICAgIGNvb2tpZSArPSBgOyBQYXRoPSR7b3B0LnBhdGh9YDtcbiAgfVxuICBpZiAob3B0LmV4cGlyZXMpIHtcbiAgICBpZiAob3B0LmV4cGlyZXMuZ2V0VGltZSgpIC0gRGF0ZS5ub3coKSA+IDM0NTZlNykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkNvb2tpZXMgRXhwaXJlcyBTSE9VTEQgTk9UIGJlIGdyZWF0ZXIgdGhhbiA0MDAgZGF5cyAoMzQ1NjAwMDAgc2Vjb25kcykgaW4gdGhlIGZ1dHVyZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29va2llICs9IGA7IEV4cGlyZXM9JHtvcHQuZXhwaXJlcy50b1VUQ1N0cmluZygpfWA7XG4gIH1cbiAgaWYgKG9wdC5odHRwT25seSkge1xuICAgIGNvb2tpZSArPSBcIjsgSHR0cE9ubHlcIjtcbiAgfVxuICBpZiAob3B0LnNlY3VyZSkge1xuICAgIGNvb2tpZSArPSBcIjsgU2VjdXJlXCI7XG4gIH1cbiAgaWYgKG9wdC5zYW1lU2l0ZSkge1xuICAgIGNvb2tpZSArPSBgOyBTYW1lU2l0ZT0ke29wdC5zYW1lU2l0ZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG9wdC5zYW1lU2l0ZS5zbGljZSgxKX1gO1xuICB9XG4gIGlmIChvcHQucGFydGl0aW9uZWQpIHtcbiAgICBpZiAoIW9wdC5zZWN1cmUpIHtcbiAgICAgIG9wdC5zZWN1cmUgPSB0cnVlO1xuICAgIH1cbiAgICBjb29raWUgKz0gXCI7IFBhcnRpdGlvbmVkXCI7XG4gIH1cbiAgcmV0dXJuIGNvb2tpZTtcbn07XG52YXIgc2VyaWFsaXplQ29va2llID0gKGtleSwgdmFsdWUsIG9wdCkgPT4ge1xuICB2YWx1ZSA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gIHJldHVybiBfc2VyaWFsaXplKGtleSwgdmFsdWUsIG9wdCk7XG59O1xudmFyIHNlcmlhbGl6ZVNpZ25lZENvb2tpZSA9IGFzeW5jIChrZXksIHZhbHVlLCBzZWNyZXQsIG9wdCkgPT4ge1xuICB2YWx1ZSA9IGF3YWl0IHNpZ25Db29raWVWYWx1ZSh2YWx1ZSwgc2VjcmV0KTtcbiAgcmV0dXJuIF9zZXJpYWxpemUoa2V5LCB2YWx1ZSwgb3B0KTtcbn07XG5cbi8vIHNyYy9jb250ZXh0LnRzXG52YXIgY3JlYXRlSW50ZXJuYWxDb250ZXh0ID0gYXN5bmMgKGNvbnRleHQsIHtcbiAgb3B0aW9ucyxcbiAgcGF0aFxufSkgPT4ge1xuICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgcnVuVmFsaWRhdGlvbihvcHRpb25zLCBjb250ZXh0KTtcbiAgaWYgKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEFQSUVycm9yKDQwMCwge1xuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgIGNvZGU6IFwiVkFMSURBVElPTl9FUlJPUlwiXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgcmVxdWVzdEhlYWRlcnMgPSBcImhlYWRlcnNcIiBpbiBjb250ZXh0ID8gY29udGV4dC5oZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycyA/IGNvbnRleHQuaGVhZGVycyA6IG5ldyBIZWFkZXJzKGNvbnRleHQuaGVhZGVycykgOiBcInJlcXVlc3RcIiBpbiBjb250ZXh0ICYmIGNvbnRleHQucmVxdWVzdCBpbnN0YW5jZW9mIFJlcXVlc3QgPyBjb250ZXh0LnJlcXVlc3QuaGVhZGVycyA6IG51bGw7XG4gIGNvbnN0IHJlcXVlc3RDb29raWVzID0gcmVxdWVzdEhlYWRlcnM/LmdldChcImNvb2tpZVwiKTtcbiAgY29uc3QgcGFyc2VkQ29va2llcyA9IHJlcXVlc3RDb29raWVzID8gcGFyc2VDb29raWVzKHJlcXVlc3RDb29raWVzKSA6IHZvaWQgMDtcbiAgY29uc3QgaW50ZXJuYWxDb250ZXh0ID0ge1xuICAgIC4uLmNvbnRleHQsXG4gICAgYm9keTogZGF0YS5ib2R5LFxuICAgIHF1ZXJ5OiBkYXRhLnF1ZXJ5LFxuICAgIHBhdGg6IGNvbnRleHQucGF0aCB8fCBwYXRoLFxuICAgIGNvbnRleHQ6IFwiY29udGV4dFwiIGluIGNvbnRleHQgJiYgY29udGV4dC5jb250ZXh0ID8gY29udGV4dC5jb250ZXh0IDoge30sXG4gICAgcmV0dXJuZWQ6IHZvaWQgMCxcbiAgICBoZWFkZXJzOiBjb250ZXh0Py5oZWFkZXJzLFxuICAgIHJlcXVlc3Q6IGNvbnRleHQ/LnJlcXVlc3QsXG4gICAgcGFyYW1zOiBcInBhcmFtc1wiIGluIGNvbnRleHQgPyBjb250ZXh0LnBhcmFtcyA6IHZvaWQgMCxcbiAgICBtZXRob2Q6IGNvbnRleHQubWV0aG9kLFxuICAgIHNldEhlYWRlcjogKGtleSwgdmFsdWUpID0+IHtcbiAgICAgIGhlYWRlcnMuc2V0KGtleSwgdmFsdWUpO1xuICAgIH0sXG4gICAgZ2V0SGVhZGVyOiAoa2V5KSA9PiB7XG4gICAgICBpZiAoIXJlcXVlc3RIZWFkZXJzKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiByZXF1ZXN0SGVhZGVycy5nZXQoa2V5KTtcbiAgICB9LFxuICAgIGdldENvb2tpZTogKGtleSwgcHJlZml4KSA9PiB7XG4gICAgICBjb25zdCBmaW5hbEtleSA9IGdldENvb2tpZUtleShrZXksIHByZWZpeCk7XG4gICAgICBpZiAoIWZpbmFsS2V5KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlZENvb2tpZXM/LmdldChmaW5hbEtleSkgfHwgbnVsbDtcbiAgICB9LFxuICAgIGdldFNpZ25lZENvb2tpZTogYXN5bmMgKGtleSwgc2VjcmV0LCBwcmVmaXgpID0+IHtcbiAgICAgIGNvbnN0IGZpbmFsS2V5ID0gZ2V0Q29va2llS2V5KGtleSwgcHJlZml4KTtcbiAgICAgIGlmICghZmluYWxLZXkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlZENvb2tpZXM/LmdldChmaW5hbEtleSk7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbmF0dXJlU3RhcnRQb3MgPSB2YWx1ZS5sYXN0SW5kZXhPZihcIi5cIik7XG4gICAgICBpZiAoc2lnbmF0dXJlU3RhcnRQb3MgPCAxKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbmVkVmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgc2lnbmF0dXJlU3RhcnRQb3MpO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdmFsdWUuc3Vic3RyaW5nKHNpZ25hdHVyZVN0YXJ0UG9zICsgMSk7XG4gICAgICBpZiAoc2lnbmF0dXJlLmxlbmd0aCAhPT0gNDQgfHwgIXNpZ25hdHVyZS5lbmRzV2l0aChcIj1cIikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBzZWNyZXRLZXkgPSBhd2FpdCBnZXRDcnlwdG9LZXkoc2VjcmV0KTtcbiAgICAgIGNvbnN0IGlzVmVyaWZpZWQgPSBhd2FpdCB2ZXJpZnlTaWduYXR1cmUoc2lnbmF0dXJlLCBzaWduZWRWYWx1ZSwgc2VjcmV0S2V5KTtcbiAgICAgIHJldHVybiBpc1ZlcmlmaWVkID8gc2lnbmVkVmFsdWUgOiBmYWxzZTtcbiAgICB9LFxuICAgIHNldENvb2tpZTogKGtleSwgdmFsdWUsIG9wdGlvbnMyKSA9PiB7XG4gICAgICBjb25zdCBjb29raWUgPSBzZXJpYWxpemVDb29raWUoa2V5LCB2YWx1ZSwgb3B0aW9uczIpO1xuICAgICAgaGVhZGVycy5hcHBlbmQoXCJzZXQtY29va2llXCIsIGNvb2tpZSk7XG4gICAgICByZXR1cm4gY29va2llO1xuICAgIH0sXG4gICAgc2V0U2lnbmVkQ29va2llOiBhc3luYyAoa2V5LCB2YWx1ZSwgc2VjcmV0LCBvcHRpb25zMikgPT4ge1xuICAgICAgY29uc3QgY29va2llID0gYXdhaXQgc2VyaWFsaXplU2lnbmVkQ29va2llKGtleSwgdmFsdWUsIHNlY3JldCwgb3B0aW9uczIpO1xuICAgICAgaGVhZGVycy5hcHBlbmQoXCJzZXQtY29va2llXCIsIGNvb2tpZSk7XG4gICAgICByZXR1cm4gY29va2llO1xuICAgIH0sXG4gICAgcmVkaXJlY3Q6ICh1cmwpID0+IHtcbiAgICAgIGhlYWRlcnMuc2V0KFwibG9jYXRpb25cIiwgdXJsKTtcbiAgICAgIHJldHVybiBuZXcgQVBJRXJyb3IoXCJGT1VORFwiLCB2b2lkIDAsIGhlYWRlcnMpO1xuICAgIH0sXG4gICAgZXJyb3I6IChzdGF0dXMsIGJvZHksIGhlYWRlcnMyKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IEFQSUVycm9yKHN0YXR1cywgYm9keSwgaGVhZGVyczIpO1xuICAgIH0sXG4gICAganNvbjogKGpzb24sIHJvdXRlclJlc3BvbnNlKSA9PiB7XG4gICAgICBpZiAoIWNvbnRleHQuYXNSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJvZHk6IHJvdXRlclJlc3BvbnNlPy5ib2R5IHx8IGpzb24sXG4gICAgICAgIHJvdXRlclJlc3BvbnNlLFxuICAgICAgICBfZmxhZzogXCJqc29uXCJcbiAgICAgIH07XG4gICAgfSxcbiAgICByZXNwb25zZUhlYWRlcnM6IGhlYWRlcnNcbiAgfTtcbiAgZm9yIChjb25zdCBtaWRkbGV3YXJlIG9mIG9wdGlvbnMudXNlIHx8IFtdKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtaWRkbGV3YXJlKHtcbiAgICAgIC4uLmludGVybmFsQ29udGV4dCxcbiAgICAgIHJldHVybkhlYWRlcnM6IHRydWUsXG4gICAgICBhc1Jlc3BvbnNlOiBmYWxzZVxuICAgIH0pO1xuICAgIGlmIChyZXNwb25zZS5yZXNwb25zZSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihpbnRlcm5hbENvbnRleHQuY29udGV4dCwgcmVzcG9uc2UucmVzcG9uc2UpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2UuaGVhZGVycykge1xuICAgICAgcmVzcG9uc2UuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGludGVybmFsQ29udGV4dC5yZXNwb25zZUhlYWRlcnMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbnRlcm5hbENvbnRleHQ7XG59O1xuXG4vLyBzcmMvbWlkZGxld2FyZS50c1xuZnVuY3Rpb24gY3JlYXRlTWlkZGxld2FyZShvcHRpb25zT3JIYW5kbGVyLCBoYW5kbGVyKSB7XG4gIGNvbnN0IGludGVybmFsSGFuZGxlciA9IGFzeW5jIChpbnB1dEN0eCkgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSBpbnB1dEN0eDtcbiAgICBjb25zdCBfaGFuZGxlciA9IHR5cGVvZiBvcHRpb25zT3JIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zT3JIYW5kbGVyIDogaGFuZGxlcjtcbiAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnNPckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIiA/IHt9IDogb3B0aW9uc09ySGFuZGxlcjtcbiAgICBjb25zdCBpbnRlcm5hbENvbnRleHQgPSBhd2FpdCBjcmVhdGVJbnRlcm5hbENvbnRleHQoY29udGV4dCwge1xuICAgICAgb3B0aW9ucyxcbiAgICAgIHBhdGg6IFwiL1wiXG4gICAgfSk7XG4gICAgaWYgKCFfaGFuZGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaGFuZGxlciBtdXN0IGJlIGRlZmluZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2hhbmRsZXIoaW50ZXJuYWxDb250ZXh0KTtcbiAgICBjb25zdCBoZWFkZXJzID0gaW50ZXJuYWxDb250ZXh0LnJlc3BvbnNlSGVhZGVycztcbiAgICByZXR1cm4gY29udGV4dC5yZXR1cm5IZWFkZXJzID8ge1xuICAgICAgaGVhZGVycyxcbiAgICAgIHJlc3BvbnNlXG4gICAgfSA6IHJlc3BvbnNlO1xuICB9O1xuICBpbnRlcm5hbEhhbmRsZXIub3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zT3JIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIgPyB7fSA6IG9wdGlvbnNPckhhbmRsZXI7XG4gIHJldHVybiBpbnRlcm5hbEhhbmRsZXI7XG59XG5jcmVhdGVNaWRkbGV3YXJlLmNyZWF0ZSA9IChvcHRzKSA9PiB7XG4gIGZ1bmN0aW9uIGZuKG9wdGlvbnNPckhhbmRsZXIsIGhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnNPckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGNyZWF0ZU1pZGRsZXdhcmUoXG4gICAgICAgIHtcbiAgICAgICAgICB1c2U6IG9wdHM/LnVzZVxuICAgICAgICB9LFxuICAgICAgICBvcHRpb25zT3JIYW5kbGVyXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pZGRsZXdhcmUgaGFuZGxlciBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgbWlkZGxld2FyZSA9IGNyZWF0ZU1pZGRsZXdhcmUoXG4gICAgICB7XG4gICAgICAgIC4uLm9wdGlvbnNPckhhbmRsZXIsXG4gICAgICAgIG1ldGhvZDogXCIqXCIsXG4gICAgICAgIHVzZTogWy4uLm9wdHM/LnVzZSB8fCBbXSwgLi4ub3B0aW9uc09ySGFuZGxlci51c2UgfHwgW11dXG4gICAgICB9LFxuICAgICAgaGFuZGxlclxuICAgICk7XG4gICAgcmV0dXJuIG1pZGRsZXdhcmU7XG4gIH1cbiAgcmV0dXJuIGZuO1xufTtcblxuLy8gc3JjL2VuZHBvaW50LnRzXG52YXIgY3JlYXRlRW5kcG9pbnQyID0gKHBhdGgsIG9wdGlvbnMsIGhhbmRsZXIpID0+IHtcbiAgY29uc3QgaW50ZXJuYWxIYW5kbGVyID0gYXN5bmMgKC4uLmlucHV0Q3R4KSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IGlucHV0Q3R4WzBdIHx8IHt9O1xuICAgIGNvbnN0IGludGVybmFsQ29udGV4dCA9IGF3YWl0IGNyZWF0ZUludGVybmFsQ29udGV4dChjb250ZXh0LCB7XG4gICAgICBvcHRpb25zLFxuICAgICAgcGF0aFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlcihpbnRlcm5hbENvbnRleHQpLmNhdGNoKGFzeW5jIChlKSA9PiB7XG4gICAgICBpZiAoaXNBUElFcnJvcihlKSkge1xuICAgICAgICBjb25zdCBvbkFQSUVycm9yID0gb3B0aW9ucy5vbkFQSUVycm9yO1xuICAgICAgICBpZiAob25BUElFcnJvcikge1xuICAgICAgICAgIGF3YWl0IG9uQVBJRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQuYXNSZXNwb25zZSkge1xuICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBpbnRlcm5hbENvbnRleHQucmVzcG9uc2VIZWFkZXJzO1xuICAgIHJldHVybiBjb250ZXh0LmFzUmVzcG9uc2UgPyB0b1Jlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgICBoZWFkZXJzXG4gICAgfSkgOiBjb250ZXh0LnJldHVybkhlYWRlcnMgPyB7XG4gICAgICBoZWFkZXJzLFxuICAgICAgcmVzcG9uc2VcbiAgICB9IDogcmVzcG9uc2U7XG4gIH07XG4gIGludGVybmFsSGFuZGxlci5vcHRpb25zID0gb3B0aW9ucztcbiAgaW50ZXJuYWxIYW5kbGVyLnBhdGggPSBwYXRoO1xuICByZXR1cm4gaW50ZXJuYWxIYW5kbGVyO1xufTtcbmNyZWF0ZUVuZHBvaW50Mi5jcmVhdGUgPSAob3B0cykgPT4ge1xuICByZXR1cm4gKHBhdGgsIG9wdGlvbnMsIGhhbmRsZXIpID0+IHtcbiAgICByZXR1cm4gY3JlYXRlRW5kcG9pbnQyKFxuICAgICAgcGF0aCxcbiAgICAgIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgdXNlOiBbLi4ub3B0aW9ucz8udXNlIHx8IFtdLCAuLi5vcHRzPy51c2UgfHwgW11dXG4gICAgICB9LFxuICAgICAgaGFuZGxlclxuICAgICk7XG4gIH07XG59O1xuXG4vLyBzcmMvcm91dGVyLnRzXG5pbXBvcnQgeyBhZGRSb3V0ZSwgY3JlYXRlUm91dGVyIGFzIGNyZWF0ZVJvdTNSb3V0ZXIsIGZpbmRBbGxSb3V0ZXMsIGZpbmRSb3V0ZSB9IGZyb20gXCJyb3UzXCI7XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS96b2RANC4wLjEvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL2NvcmUuanNcbnZhciBORVZFUiA9IE9iamVjdC5mcmVlemUoe1xuICBzdGF0dXM6IFwiYWJvcnRlZFwiXG59KTtcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiAkY29uc3RydWN0b3IobmFtZSwgaW5pdGlhbGl6ZXIzLCBwYXJhbXMpIHtcbiAgZnVuY3Rpb24gaW5pdChpbnN0LCBkZWYpIHtcbiAgICB2YXIgX2E7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIFwiX3pvZFwiLCB7XG4gICAgICB2YWx1ZTogaW5zdC5fem9kID8/IHt9LFxuICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICB9KTtcbiAgICAoX2EgPSBpbnN0Ll96b2QpLnRyYWl0cyA/PyAoX2EudHJhaXRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgaW5zdC5fem9kLnRyYWl0cy5hZGQobmFtZSk7XG4gICAgaW5pdGlhbGl6ZXIzKGluc3QsIGRlZik7XG4gICAgZm9yIChjb25zdCBrIGluIF8ucHJvdG90eXBlKSB7XG4gICAgICBpZiAoIShrIGluIGluc3QpKVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdCwgaywgeyB2YWx1ZTogXy5wcm90b3R5cGVba10uYmluZChpbnN0KSB9KTtcbiAgICB9XG4gICAgaW5zdC5fem9kLmNvbnN0ciA9IF87XG4gICAgaW5zdC5fem9kLmRlZiA9IGRlZjtcbiAgfVxuICBjb25zdCBQYXJlbnQgPSBwYXJhbXM/LlBhcmVudCA/PyBPYmplY3Q7XG4gIGNsYXNzIERlZmluaXRpb24gZXh0ZW5kcyBQYXJlbnQge1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWZpbml0aW9uLCBcIm5hbWVcIiwgeyB2YWx1ZTogbmFtZSB9KTtcbiAgZnVuY3Rpb24gXyhkZWYpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgaW5zdCA9IHBhcmFtcz8uUGFyZW50ID8gbmV3IERlZmluaXRpb24oKSA6IHRoaXM7XG4gICAgaW5pdChpbnN0LCBkZWYpO1xuICAgIChfYSA9IGluc3QuX3pvZCkuZGVmZXJyZWQgPz8gKF9hLmRlZmVycmVkID0gW10pO1xuICAgIGZvciAoY29uc3QgZm4gb2YgaW5zdC5fem9kLmRlZmVycmVkKSB7XG4gICAgICBmbigpO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdDtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXywgXCJpbml0XCIsIHsgdmFsdWU6IGluaXQgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogKGluc3QpID0+IHtcbiAgICAgIGlmIChwYXJhbXM/LlBhcmVudCAmJiBpbnN0IGluc3RhbmNlb2YgcGFyYW1zLlBhcmVudClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gaW5zdD8uX3pvZD8udHJhaXRzPy5oYXMobmFtZSk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF8sIFwibmFtZVwiLCB7IHZhbHVlOiBuYW1lIH0pO1xuICByZXR1cm4gXztcbn1cbnZhciAkYnJhbmQgPSBTeW1ib2woXCJ6b2RfYnJhbmRcIik7XG52YXIgJFpvZEFzeW5jRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoYEVuY291bnRlcmVkIFByb21pc2UgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlLiBVc2UgLnBhcnNlQXN5bmMoKSBpbnN0ZWFkLmApO1xuICB9XG59O1xudmFyIGdsb2JhbENvbmZpZyA9IHt9O1xuZnVuY3Rpb24gY29uZmlnKG5ld0NvbmZpZykge1xuICBpZiAobmV3Q29uZmlnKVxuICAgIE9iamVjdC5hc3NpZ24oZ2xvYmFsQ29uZmlnLCBuZXdDb25maWcpO1xuICByZXR1cm4gZ2xvYmFsQ29uZmlnO1xufVxuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vem9kQDQuMC4xL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS91dGlsLmpzXG52YXIgdXRpbF9leHBvcnRzID0ge307XG5fX2V4cG9ydCh1dGlsX2V4cG9ydHMsIHtcbiAgQklHSU5UX0ZPUk1BVF9SQU5HRVM6ICgpID0+IEJJR0lOVF9GT1JNQVRfUkFOR0VTLFxuICBDbGFzczogKCkgPT4gQ2xhc3MsXG4gIE5VTUJFUl9GT1JNQVRfUkFOR0VTOiAoKSA9PiBOVU1CRVJfRk9STUFUX1JBTkdFUyxcbiAgYWJvcnRlZDogKCkgPT4gYWJvcnRlZCxcbiAgYWxsb3dzRXZhbDogKCkgPT4gYWxsb3dzRXZhbCxcbiAgYXNzZXJ0OiAoKSA9PiBhc3NlcnQsXG4gIGFzc2VydEVxdWFsOiAoKSA9PiBhc3NlcnRFcXVhbCxcbiAgYXNzZXJ0SXM6ICgpID0+IGFzc2VydElzLFxuICBhc3NlcnROZXZlcjogKCkgPT4gYXNzZXJ0TmV2ZXIsXG4gIGFzc2VydE5vdEVxdWFsOiAoKSA9PiBhc3NlcnROb3RFcXVhbCxcbiAgYXNzaWduUHJvcDogKCkgPT4gYXNzaWduUHJvcCxcbiAgY2FjaGVkOiAoKSA9PiBjYWNoZWQsXG4gIGNhcHR1cmVTdGFja1RyYWNlOiAoKSA9PiBjYXB0dXJlU3RhY2tUcmFjZSxcbiAgY2xlYW5FbnVtOiAoKSA9PiBjbGVhbkVudW0sXG4gIGNsZWFuUmVnZXg6ICgpID0+IGNsZWFuUmVnZXgsXG4gIGNsb25lOiAoKSA9PiBjbG9uZSxcbiAgY3JlYXRlVHJhbnNwYXJlbnRQcm94eTogKCkgPT4gY3JlYXRlVHJhbnNwYXJlbnRQcm94eSxcbiAgZGVmaW5lTGF6eTogKCkgPT4gZGVmaW5lTGF6eSxcbiAgZXNjOiAoKSA9PiBlc2MsXG4gIGVzY2FwZVJlZ2V4OiAoKSA9PiBlc2NhcGVSZWdleCxcbiAgZXh0ZW5kOiAoKSA9PiBleHRlbmQsXG4gIGZpbmFsaXplSXNzdWU6ICgpID0+IGZpbmFsaXplSXNzdWUsXG4gIGZsb2F0U2FmZVJlbWFpbmRlcjogKCkgPT4gZmxvYXRTYWZlUmVtYWluZGVyLFxuICBnZXRFbGVtZW50QXRQYXRoOiAoKSA9PiBnZXRFbGVtZW50QXRQYXRoLFxuICBnZXRFbnVtVmFsdWVzOiAoKSA9PiBnZXRFbnVtVmFsdWVzLFxuICBnZXRMZW5ndGhhYmxlT3JpZ2luOiAoKSA9PiBnZXRMZW5ndGhhYmxlT3JpZ2luLFxuICBnZXRQYXJzZWRUeXBlOiAoKSA9PiBnZXRQYXJzZWRUeXBlLFxuICBnZXRTaXphYmxlT3JpZ2luOiAoKSA9PiBnZXRTaXphYmxlT3JpZ2luLFxuICBpc09iamVjdDogKCkgPT4gaXNPYmplY3QsXG4gIGlzUGxhaW5PYmplY3Q6ICgpID0+IGlzUGxhaW5PYmplY3QsXG4gIGlzc3VlOiAoKSA9PiBpc3N1ZSxcbiAgam9pblZhbHVlczogKCkgPT4gam9pblZhbHVlcyxcbiAganNvblN0cmluZ2lmeVJlcGxhY2VyOiAoKSA9PiBqc29uU3RyaW5naWZ5UmVwbGFjZXIsXG4gIG1lcmdlOiAoKSA9PiBtZXJnZSxcbiAgbm9ybWFsaXplUGFyYW1zOiAoKSA9PiBub3JtYWxpemVQYXJhbXMsXG4gIG51bGxpc2g6ICgpID0+IG51bGxpc2gsXG4gIG51bUtleXM6ICgpID0+IG51bUtleXMsXG4gIG9taXQ6ICgpID0+IG9taXQsXG4gIG9wdGlvbmFsS2V5czogKCkgPT4gb3B0aW9uYWxLZXlzLFxuICBwYXJ0aWFsOiAoKSA9PiBwYXJ0aWFsLFxuICBwaWNrOiAoKSA9PiBwaWNrLFxuICBwcmVmaXhJc3N1ZXM6ICgpID0+IHByZWZpeElzc3VlcyxcbiAgcHJpbWl0aXZlVHlwZXM6ICgpID0+IHByaW1pdGl2ZVR5cGVzLFxuICBwcm9taXNlQWxsT2JqZWN0OiAoKSA9PiBwcm9taXNlQWxsT2JqZWN0LFxuICBwcm9wZXJ0eUtleVR5cGVzOiAoKSA9PiBwcm9wZXJ0eUtleVR5cGVzLFxuICByYW5kb21TdHJpbmc6ICgpID0+IHJhbmRvbVN0cmluZyxcbiAgcmVxdWlyZWQ6ICgpID0+IHJlcXVpcmVkLFxuICBzdHJpbmdpZnlQcmltaXRpdmU6ICgpID0+IHN0cmluZ2lmeVByaW1pdGl2ZSxcbiAgdW53cmFwTWVzc2FnZTogKCkgPT4gdW53cmFwTWVzc2FnZVxufSk7XG5mdW5jdGlvbiBhc3NlcnRFcXVhbCh2YWwpIHtcbiAgcmV0dXJuIHZhbDtcbn1cbmZ1bmN0aW9uIGFzc2VydE5vdEVxdWFsKHZhbCkge1xuICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXMoX2FyZykge1xufVxuZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3gpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCk7XG59XG5mdW5jdGlvbiBhc3NlcnQoXykge1xufVxuZnVuY3Rpb24gZ2V0RW51bVZhbHVlcyhlbnRyaWVzKSB7XG4gIGNvbnN0IG51bWVyaWNWYWx1ZXMgPSBPYmplY3QudmFsdWVzKGVudHJpZXMpLmZpbHRlcigodikgPT4gdHlwZW9mIHYgPT09IFwibnVtYmVyXCIpO1xuICBjb25zdCB2YWx1ZXMgPSBPYmplY3QuZW50cmllcyhlbnRyaWVzKS5maWx0ZXIoKFtrLCBfXSkgPT4gbnVtZXJpY1ZhbHVlcy5pbmRleE9mKCtrKSA9PT0gLTEpLm1hcCgoW18sIHZdKSA9PiB2KTtcbiAgcmV0dXJuIHZhbHVlcztcbn1cbmZ1bmN0aW9uIGpvaW5WYWx1ZXMoYXJyYXkyLCBzZXBhcmF0b3IgPSBcInxcIikge1xuICByZXR1cm4gYXJyYXkyLm1hcCgodmFsKSA9PiBzdHJpbmdpZnlQcmltaXRpdmUodmFsKSkuam9pbihzZXBhcmF0b3IpO1xufVxuZnVuY3Rpb24ganNvblN0cmluZ2lmeVJlcGxhY2VyKF8sIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpXG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNhY2hlZChnZXR0ZXIpIHtcbiAgY29uc3Qgc2V0ID0gZmFsc2U7XG4gIHJldHVybiB7XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgaWYgKCFzZXQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXR0ZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwgeyB2YWx1ZSB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FjaGVkIHZhbHVlIGFscmVhZHkgc2V0XCIpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG51bGxpc2goaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0ID09PSBudWxsIHx8IGlucHV0ID09PSB2b2lkIDA7XG59XG5mdW5jdGlvbiBjbGVhblJlZ2V4KHNvdXJjZSkge1xuICBjb25zdCBzdGFydCA9IHNvdXJjZS5zdGFydHNXaXRoKFwiXlwiKSA/IDEgOiAwO1xuICBjb25zdCBlbmQgPSBzb3VyY2UuZW5kc1dpdGgoXCIkXCIpID8gc291cmNlLmxlbmd0aCAtIDEgOiBzb3VyY2UubGVuZ3RoO1xuICByZXR1cm4gc291cmNlLnNsaWNlKHN0YXJ0LCBlbmQpO1xufVxuZnVuY3Rpb24gZmxvYXRTYWZlUmVtYWluZGVyKHZhbCwgc3RlcCkge1xuICBjb25zdCB2YWxEZWNDb3VudCA9ICh2YWwudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICBjb25zdCBzdGVwRGVjQ291bnQgPSAoc3RlcC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gIGNvbnN0IGRlY0NvdW50ID0gdmFsRGVjQ291bnQgPiBzdGVwRGVjQ291bnQgPyB2YWxEZWNDb3VudCA6IHN0ZXBEZWNDb3VudDtcbiAgY29uc3QgdmFsSW50ID0gTnVtYmVyLnBhcnNlSW50KHZhbC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gIGNvbnN0IHN0ZXBJbnQgPSBOdW1iZXIucGFyc2VJbnQoc3RlcC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gIHJldHVybiB2YWxJbnQgJSBzdGVwSW50IC8gMTAgKiogZGVjQ291bnQ7XG59XG5mdW5jdGlvbiBkZWZpbmVMYXp5KG9iamVjdCwga2V5LCBnZXR0ZXIpIHtcbiAgY29uc3Qgc2V0ID0gZmFsc2U7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgIGdldCgpIHtcbiAgICAgIGlmICghc2V0KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0dGVyKCk7XG4gICAgICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhY2hlZCB2YWx1ZSBhbHJlYWR5IHNldFwiKTtcbiAgICB9LFxuICAgIHNldCh2KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgLy8gY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgfSk7XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5mdW5jdGlvbiBhc3NpZ25Qcm9wKHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcCwge1xuICAgIHZhbHVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudEF0UGF0aChvYmosIHBhdGgpIHtcbiAgaWYgKCFwYXRoKVxuICAgIHJldHVybiBvYmo7XG4gIHJldHVybiBwYXRoLnJlZHVjZSgoYWNjLCBrZXkpID0+IGFjYz8uW2tleV0sIG9iaik7XG59XG5mdW5jdGlvbiBwcm9taXNlQWxsT2JqZWN0KHByb21pc2VzT2JqKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9taXNlc09iaik7XG4gIGNvbnN0IHByb21pc2VzID0ga2V5cy5tYXAoKGtleSkgPT4gcHJvbWlzZXNPYmpba2V5XSk7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigocmVzdWx0cykgPT4ge1xuICAgIGNvbnN0IHJlc29sdmVkT2JqID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNvbHZlZE9ialtrZXlzW2ldXSA9IHJlc3VsdHNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlZE9iajtcbiAgfSk7XG59XG5mdW5jdGlvbiByYW5kb21TdHJpbmcobGVuZ3RoID0gMTApIHtcbiAgY29uc3QgY2hhcnMgPSBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCI7XG4gIGxldCBzdHIgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgc3RyICs9IGNoYXJzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJzLmxlbmd0aCldO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBlc2Moc3RyKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShzdHIpO1xufVxudmFyIGNhcHR1cmVTdGFja1RyYWNlID0gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPyBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA6ICguLi5fYXJncykgPT4ge1xufTtcbmZ1bmN0aW9uIGlzT2JqZWN0KGRhdGEpIHtcbiAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmIGRhdGEgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkoZGF0YSk7XG59XG52YXIgYWxsb3dzRXZhbCA9IGNhY2hlZCgoKSA9PiB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvcj8udXNlckFnZW50Py5pbmNsdWRlcyhcIkNsb3VkZmxhcmVcIikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBGID0gRnVuY3Rpb247XG4gICAgbmV3IEYoXCJcIik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pO1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvKSB7XG4gIGlmIChpc09iamVjdChvKSA9PT0gZmFsc2UpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBjdG9yID0gby5jb25zdHJ1Y3RvcjtcbiAgaWYgKGN0b3IgPT09IHZvaWQgMClcbiAgICByZXR1cm4gdHJ1ZTtcbiAgY29uc3QgcHJvdCA9IGN0b3IucHJvdG90eXBlO1xuICBpZiAoaXNPYmplY3QocHJvdCkgPT09IGZhbHNlKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm90LCBcImlzUHJvdG90eXBlT2ZcIikgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbnVtS2V5cyhkYXRhKSB7XG4gIGxldCBrZXlDb3VudCA9IDA7XG4gIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkpIHtcbiAgICAgIGtleUNvdW50Kys7XG4gICAgfVxuICB9XG4gIHJldHVybiBrZXlDb3VudDtcbn1cbnZhciBnZXRQYXJzZWRUeXBlID0gKGRhdGEpID0+IHtcbiAgY29uc3QgdCA9IHR5cGVvZiBkYXRhO1xuICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIjtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gTnVtYmVyLmlzTmFOKGRhdGEpID8gXCJuYW5cIiA6IFwibnVtYmVyXCI7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBcImJvb2xlYW5cIjtcbiAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgIHJldHVybiBcImZ1bmN0aW9uXCI7XG4gICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgcmV0dXJuIFwiYmlnaW50XCI7XG4gICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgcmV0dXJuIFwic3ltYm9sXCI7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnRoZW4gJiYgdHlwZW9mIGRhdGEudGhlbiA9PT0gXCJmdW5jdGlvblwiICYmIGRhdGEuY2F0Y2ggJiYgdHlwZW9mIGRhdGEuY2F0Y2ggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gXCJwcm9taXNlXCI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIE1hcCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIHJldHVybiBcIm1hcFwiO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBTZXQgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICByZXR1cm4gXCJzZXRcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgRGF0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gXCJkYXRlXCI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIEZpbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgcmV0dXJuIFwiZmlsZVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwib2JqZWN0XCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhIHR5cGU6ICR7dH1gKTtcbiAgfVxufTtcbnZhciBwcm9wZXJ0eUtleVR5cGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwic3ltYm9sXCJdKTtcbnZhciBwcmltaXRpdmVUeXBlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJpZ2ludFwiLCBcImJvb2xlYW5cIiwgXCJzeW1ib2xcIiwgXCJ1bmRlZmluZWRcIl0pO1xuZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xufVxuZnVuY3Rpb24gY2xvbmUoaW5zdCwgZGVmLCBwYXJhbXMpIHtcbiAgY29uc3QgY2wgPSBuZXcgaW5zdC5fem9kLmNvbnN0cihkZWYgPz8gaW5zdC5fem9kLmRlZik7XG4gIGlmICghZGVmIHx8IHBhcmFtcz8ucGFyZW50KVxuICAgIGNsLl96b2QucGFyZW50ID0gaW5zdDtcbiAgcmV0dXJuIGNsO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUGFyYW1zKF9wYXJhbXMpIHtcbiAgY29uc3QgcGFyYW1zID0gX3BhcmFtcztcbiAgaWYgKCFwYXJhbXMpXG4gICAgcmV0dXJuIHt9O1xuICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4geyBlcnJvcjogKCkgPT4gcGFyYW1zIH07XG4gIGlmIChwYXJhbXM/Lm1lc3NhZ2UgIT09IHZvaWQgMCkge1xuICAgIGlmIChwYXJhbXM/LmVycm9yICE9PSB2b2lkIDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc3BlY2lmeSBib3RoIGBtZXNzYWdlYCBhbmQgYGVycm9yYCBwYXJhbXNcIik7XG4gICAgcGFyYW1zLmVycm9yID0gcGFyYW1zLm1lc3NhZ2U7XG4gIH1cbiAgZGVsZXRlIHBhcmFtcy5tZXNzYWdlO1xuICBpZiAodHlwZW9mIHBhcmFtcy5lcnJvciA9PT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4geyAuLi5wYXJhbXMsIGVycm9yOiAoKSA9PiBwYXJhbXMuZXJyb3IgfTtcbiAgcmV0dXJuIHBhcmFtcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zcGFyZW50UHJveHkoZ2V0dGVyKSB7XG4gIGxldCB0YXJnZXQ7XG4gIHJldHVybiBuZXcgUHJveHkoe30sIHtcbiAgICBnZXQoXywgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgIHRhcmdldCA/PyAodGFyZ2V0ID0gZ2V0dGVyKCkpO1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgIH0sXG4gICAgc2V0KF8sIHByb3AsIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgdGFyZ2V0ID8/ICh0YXJnZXQgPSBnZXR0ZXIoKSk7XG4gICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgIH0sXG4gICAgaGFzKF8sIHByb3ApIHtcbiAgICAgIHRhcmdldCA/PyAodGFyZ2V0ID0gZ2V0dGVyKCkpO1xuICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgfSxcbiAgICBkZWxldGVQcm9wZXJ0eShfLCBwcm9wKSB7XG4gICAgICB0YXJnZXQgPz8gKHRhcmdldCA9IGdldHRlcigpKTtcbiAgICAgIHJldHVybiBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCk7XG4gICAgfSxcbiAgICBvd25LZXlzKF8pIHtcbiAgICAgIHRhcmdldCA/PyAodGFyZ2V0ID0gZ2V0dGVyKCkpO1xuICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xuICAgIH0sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF8sIHByb3ApIHtcbiAgICAgIHRhcmdldCA/PyAodGFyZ2V0ID0gZ2V0dGVyKCkpO1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCk7XG4gICAgfSxcbiAgICBkZWZpbmVQcm9wZXJ0eShfLCBwcm9wLCBkZXNjcmlwdG9yKSB7XG4gICAgICB0YXJnZXQgPz8gKHRhcmdldCA9IGdldHRlcigpKTtcbiAgICAgIHJldHVybiBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcCwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVByaW1pdGl2ZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKVxuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpICsgXCJuXCI7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGBcIiR7dmFsdWV9XCJgO1xuICByZXR1cm4gYCR7dmFsdWV9YDtcbn1cbmZ1bmN0aW9uIG9wdGlvbmFsS2V5cyhzaGFwZSkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoc2hhcGUpLmZpbHRlcigoaykgPT4ge1xuICAgIHJldHVybiBzaGFwZVtrXS5fem9kLm9wdGluID09PSBcIm9wdGlvbmFsXCIgJiYgc2hhcGVba10uX3pvZC5vcHRvdXQgPT09IFwib3B0aW9uYWxcIjtcbiAgfSk7XG59XG52YXIgTlVNQkVSX0ZPUk1BVF9SQU5HRVMgPSB7XG4gIHNhZmVpbnQ6IFtOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJdLFxuICBpbnQzMjogWy0yMTQ3NDgzNjQ4LCAyMTQ3NDgzNjQ3XSxcbiAgdWludDMyOiBbMCwgNDI5NDk2NzI5NV0sXG4gIGZsb2F0MzI6IFstMzQwMjgyMzQ2NjM4NTI4ODZlMjIsIDM0MDI4MjM0NjYzODUyODg2ZTIyXSxcbiAgZmxvYXQ2NDogWy1OdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFXVxufTtcbnZhciBCSUdJTlRfRk9STUFUX1JBTkdFUyA9IHtcbiAgaW50NjQ6IFsvKiBAX19QVVJFX18gKi8gQmlnSW50KFwiLTkyMjMzNzIwMzY4NTQ3NzU4MDhcIiksIC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoXCI5MjIzMzcyMDM2ODU0Nzc1ODA3XCIpXSxcbiAgdWludDY0OiBbLyogQF9fUFVSRV9fICovIEJpZ0ludCgwKSwgLyogQF9fUFVSRV9fICovIEJpZ0ludChcIjE4NDQ2NzQ0MDczNzA5NTUxNjE1XCIpXVxufTtcbmZ1bmN0aW9uIHBpY2soc2NoZW1hLCBtYXNrKSB7XG4gIGNvbnN0IG5ld1NoYXBlID0ge307XG4gIGNvbnN0IGN1cnJEZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gIGZvciAoY29uc3Qga2V5IGluIG1hc2spIHtcbiAgICBpZiAoIShrZXkgaW4gY3VyckRlZi5zaGFwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGtleTogXCIke2tleX1cImApO1xuICAgIH1cbiAgICBpZiAoIW1hc2tba2V5XSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIG5ld1NoYXBlW2tleV0gPSBjdXJyRGVmLnNoYXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIGNsb25lKHNjaGVtYSwge1xuICAgIC4uLnNjaGVtYS5fem9kLmRlZixcbiAgICBzaGFwZTogbmV3U2hhcGUsXG4gICAgY2hlY2tzOiBbXVxuICB9KTtcbn1cbmZ1bmN0aW9uIG9taXQoc2NoZW1hLCBtYXNrKSB7XG4gIGNvbnN0IG5ld1NoYXBlID0geyAuLi5zY2hlbWEuX3pvZC5kZWYuc2hhcGUgfTtcbiAgY29uc3QgY3VyckRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgZm9yIChjb25zdCBrZXkgaW4gbWFzaykge1xuICAgIGlmICghKGtleSBpbiBjdXJyRGVmLnNoYXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQga2V5OiBcIiR7a2V5fVwiYCk7XG4gICAgfVxuICAgIGlmICghbWFza1trZXldKVxuICAgICAgY29udGludWU7XG4gICAgZGVsZXRlIG5ld1NoYXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIGNsb25lKHNjaGVtYSwge1xuICAgIC4uLnNjaGVtYS5fem9kLmRlZixcbiAgICBzaGFwZTogbmV3U2hhcGUsXG4gICAgY2hlY2tzOiBbXVxuICB9KTtcbn1cbmZ1bmN0aW9uIGV4dGVuZChzY2hlbWEsIHNoYXBlKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdChzaGFwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHRvIGV4dGVuZDogZXhwZWN0ZWQgYSBwbGFpbiBvYmplY3RcIik7XG4gIH1cbiAgY29uc3QgZGVmID0ge1xuICAgIC4uLnNjaGVtYS5fem9kLmRlZixcbiAgICBnZXQgc2hhcGUoKSB7XG4gICAgICBjb25zdCBfc2hhcGUgPSB7IC4uLnNjaGVtYS5fem9kLmRlZi5zaGFwZSwgLi4uc2hhcGUgfTtcbiAgICAgIGFzc2lnblByb3AodGhpcywgXCJzaGFwZVwiLCBfc2hhcGUpO1xuICAgICAgcmV0dXJuIF9zaGFwZTtcbiAgICB9LFxuICAgIGNoZWNrczogW11cbiAgICAvLyBkZWxldGUgZXhpc3RpbmcgY2hlY2tzXG4gIH07XG4gIHJldHVybiBjbG9uZShzY2hlbWEsIGRlZik7XG59XG5mdW5jdGlvbiBtZXJnZShhLCBiKSB7XG4gIHJldHVybiBjbG9uZShhLCB7XG4gICAgLi4uYS5fem9kLmRlZixcbiAgICBnZXQgc2hhcGUoKSB7XG4gICAgICBjb25zdCBfc2hhcGUgPSB7IC4uLmEuX3pvZC5kZWYuc2hhcGUsIC4uLmIuX3pvZC5kZWYuc2hhcGUgfTtcbiAgICAgIGFzc2lnblByb3AodGhpcywgXCJzaGFwZVwiLCBfc2hhcGUpO1xuICAgICAgcmV0dXJuIF9zaGFwZTtcbiAgICB9LFxuICAgIGNhdGNoYWxsOiBiLl96b2QuZGVmLmNhdGNoYWxsLFxuICAgIGNoZWNrczogW11cbiAgICAvLyBkZWxldGUgZXhpc3RpbmcgY2hlY2tzXG4gIH0pO1xufVxuZnVuY3Rpb24gcGFydGlhbChDbGFzczIsIHNjaGVtYSwgbWFzaykge1xuICBjb25zdCBvbGRTaGFwZSA9IHNjaGVtYS5fem9kLmRlZi5zaGFwZTtcbiAgY29uc3Qgc2hhcGUgPSB7IC4uLm9sZFNoYXBlIH07XG4gIGlmIChtYXNrKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWFzaykge1xuICAgICAgaWYgKCEoa2V5IGluIG9sZFNoYXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBrZXk6IFwiJHtrZXl9XCJgKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWFza1trZXldKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHNoYXBlW2tleV0gPSBDbGFzczIgPyBuZXcgQ2xhc3MyKHtcbiAgICAgICAgdHlwZTogXCJvcHRpb25hbFwiLFxuICAgICAgICBpbm5lclR5cGU6IG9sZFNoYXBlW2tleV1cbiAgICAgIH0pIDogb2xkU2hhcGVba2V5XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2xkU2hhcGUpIHtcbiAgICAgIHNoYXBlW2tleV0gPSBDbGFzczIgPyBuZXcgQ2xhc3MyKHtcbiAgICAgICAgdHlwZTogXCJvcHRpb25hbFwiLFxuICAgICAgICBpbm5lclR5cGU6IG9sZFNoYXBlW2tleV1cbiAgICAgIH0pIDogb2xkU2hhcGVba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsb25lKHNjaGVtYSwge1xuICAgIC4uLnNjaGVtYS5fem9kLmRlZixcbiAgICBzaGFwZSxcbiAgICBjaGVja3M6IFtdXG4gIH0pO1xufVxuZnVuY3Rpb24gcmVxdWlyZWQoQ2xhc3MyLCBzY2hlbWEsIG1hc2spIHtcbiAgY29uc3Qgb2xkU2hhcGUgPSBzY2hlbWEuX3pvZC5kZWYuc2hhcGU7XG4gIGNvbnN0IHNoYXBlID0geyAuLi5vbGRTaGFwZSB9O1xuICBpZiAobWFzaykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1hc2spIHtcbiAgICAgIGlmICghKGtleSBpbiBzaGFwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQga2V5OiBcIiR7a2V5fVwiYCk7XG4gICAgICB9XG4gICAgICBpZiAoIW1hc2tba2V5XSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBzaGFwZVtrZXldID0gbmV3IENsYXNzMih7XG4gICAgICAgIHR5cGU6IFwibm9ub3B0aW9uYWxcIixcbiAgICAgICAgaW5uZXJUeXBlOiBvbGRTaGFwZVtrZXldXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2xkU2hhcGUpIHtcbiAgICAgIHNoYXBlW2tleV0gPSBuZXcgQ2xhc3MyKHtcbiAgICAgICAgdHlwZTogXCJub25vcHRpb25hbFwiLFxuICAgICAgICBpbm5lclR5cGU6IG9sZFNoYXBlW2tleV1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2xvbmUoc2NoZW1hLCB7XG4gICAgLi4uc2NoZW1hLl96b2QuZGVmLFxuICAgIHNoYXBlLFxuICAgIC8vIG9wdGlvbmFsOiBbXSxcbiAgICBjaGVja3M6IFtdXG4gIH0pO1xufVxuZnVuY3Rpb24gYWJvcnRlZCh4LCBzdGFydEluZGV4ID0gMCkge1xuICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IHguaXNzdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHguaXNzdWVzW2ldPy5jb250aW51ZSAhPT0gdHJ1ZSlcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHByZWZpeElzc3VlcyhwYXRoLCBpc3N1ZXMpIHtcbiAgcmV0dXJuIGlzc3Vlcy5tYXAoKGlzcykgPT4ge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSBpc3MpLnBhdGggPz8gKF9hLnBhdGggPSBbXSk7XG4gICAgaXNzLnBhdGgudW5zaGlmdChwYXRoKTtcbiAgICByZXR1cm4gaXNzO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVud3JhcE1lc3NhZ2UobWVzc2FnZSkge1xuICByZXR1cm4gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlIDogbWVzc2FnZT8ubWVzc2FnZTtcbn1cbmZ1bmN0aW9uIGZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvbmZpZzIpIHtcbiAgY29uc3QgZnVsbCA9IHsgLi4uaXNzLCBwYXRoOiBpc3MucGF0aCA/PyBbXSB9O1xuICBpZiAoIWlzcy5tZXNzYWdlKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHVud3JhcE1lc3NhZ2UoaXNzLmluc3Q/Ll96b2QuZGVmPy5lcnJvcj8uKGlzcykpID8/IHVud3JhcE1lc3NhZ2UoY3R4Py5lcnJvcj8uKGlzcykpID8/IHVud3JhcE1lc3NhZ2UoY29uZmlnMi5jdXN0b21FcnJvcj8uKGlzcykpID8/IHVud3JhcE1lc3NhZ2UoY29uZmlnMi5sb2NhbGVFcnJvcj8uKGlzcykpID8/IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgIGZ1bGwubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cbiAgZGVsZXRlIGZ1bGwuaW5zdDtcbiAgZGVsZXRlIGZ1bGwuY29udGludWU7XG4gIGlmICghY3R4Py5yZXBvcnRJbnB1dCkge1xuICAgIGRlbGV0ZSBmdWxsLmlucHV0O1xuICB9XG4gIHJldHVybiBmdWxsO1xufVxuZnVuY3Rpb24gZ2V0U2l6YWJsZU9yaWdpbihpbnB1dCkge1xuICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBTZXQpXG4gICAgcmV0dXJuIFwic2V0XCI7XG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIE1hcClcbiAgICByZXR1cm4gXCJtYXBcIjtcbiAgaWYgKGlucHV0IGluc3RhbmNlb2YgRmlsZSlcbiAgICByZXR1cm4gXCJmaWxlXCI7XG4gIHJldHVybiBcInVua25vd25cIjtcbn1cbmZ1bmN0aW9uIGdldExlbmd0aGFibGVPcmlnaW4oaW5wdXQpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKVxuICAgIHJldHVybiBcImFycmF5XCI7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gIHJldHVybiBcInVua25vd25cIjtcbn1cbmZ1bmN0aW9uIGlzc3VlKC4uLmFyZ3MpIHtcbiAgY29uc3QgW2lzcywgaW5wdXQsIGluc3RdID0gYXJncztcbiAgaWYgKHR5cGVvZiBpc3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWVzc2FnZTogaXNzLFxuICAgICAgY29kZTogXCJjdXN0b21cIixcbiAgICAgIGlucHV0LFxuICAgICAgaW5zdFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHsgLi4uaXNzIH07XG59XG5mdW5jdGlvbiBjbGVhbkVudW0ob2JqKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhvYmopLmZpbHRlcigoW2ssIF9dKSA9PiB7XG4gICAgcmV0dXJuIE51bWJlci5pc05hTihOdW1iZXIucGFyc2VJbnQoaywgMTApKTtcbiAgfSkubWFwKChlbCkgPT4gZWxbMV0pO1xufVxudmFyIENsYXNzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvciguLi5fYXJncykge1xuICB9XG59O1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vem9kQDQuMC4xL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9lcnJvcnMuanNcbnZhciBpbml0aWFsaXplciA9IChpbnN0LCBkZWYpID0+IHtcbiAgaW5zdC5uYW1lID0gXCIkWm9kRXJyb3JcIjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIFwiX3pvZFwiLCB7XG4gICAgdmFsdWU6IGluc3QuX3pvZCxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIFwiaXNzdWVzXCIsIHtcbiAgICB2YWx1ZTogZGVmLFxuICAgIGVudW1lcmFibGU6IGZhbHNlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdCwgXCJtZXNzYWdlXCIsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGVmLCBqc29uU3RyaW5naWZ5UmVwbGFjZXIsIDIpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIC8vIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdCwgXCJ0b1N0cmluZ1wiLCB7XG4gICAgdmFsdWU6ICgpID0+IGluc3QubWVzc2FnZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICB9KTtcbn07XG52YXIgJFpvZEVycm9yID0gJGNvbnN0cnVjdG9yKFwiJFpvZEVycm9yXCIsIGluaXRpYWxpemVyKTtcbnZhciAkWm9kUmVhbEVycm9yID0gJGNvbnN0cnVjdG9yKFwiJFpvZEVycm9yXCIsIGluaXRpYWxpemVyLCB7IFBhcmVudDogRXJyb3IgfSk7XG5mdW5jdGlvbiBmbGF0dGVuRXJyb3IoZXJyb3IsIG1hcHBlciA9IChpc3N1ZTIpID0+IGlzc3VlMi5tZXNzYWdlKSB7XG4gIGNvbnN0IGZpZWxkRXJyb3JzID0ge307XG4gIGNvbnN0IGZvcm1FcnJvcnMgPSBbXTtcbiAgZm9yIChjb25zdCBzdWIgb2YgZXJyb3IuaXNzdWVzKSB7XG4gICAgaWYgKHN1Yi5wYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgIGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXSA9IGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXSB8fCBbXTtcbiAgICAgIGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXS5wdXNoKG1hcHBlcihzdWIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9ybUVycm9ycy5wdXNoKG1hcHBlcihzdWIpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgZm9ybUVycm9ycywgZmllbGRFcnJvcnMgfTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKGVycm9yLCBfbWFwcGVyKSB7XG4gIGNvbnN0IG1hcHBlciA9IF9tYXBwZXIgfHwgZnVuY3Rpb24oaXNzdWUyKSB7XG4gICAgcmV0dXJuIGlzc3VlMi5tZXNzYWdlO1xuICB9O1xuICBjb25zdCBmaWVsZEVycm9ycyA9IHsgX2Vycm9yczogW10gfTtcbiAgY29uc3QgcHJvY2Vzc0Vycm9yID0gKGVycm9yMikgPT4ge1xuICAgIGZvciAoY29uc3QgaXNzdWUyIG9mIGVycm9yMi5pc3N1ZXMpIHtcbiAgICAgIGlmIChpc3N1ZTIuY29kZSA9PT0gXCJpbnZhbGlkX3VuaW9uXCIgJiYgaXNzdWUyLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgaXNzdWUyLmVycm9ycy5tYXAoKGlzc3VlcykgPT4gcHJvY2Vzc0Vycm9yKHsgaXNzdWVzIH0pKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNzdWUyLmNvZGUgPT09IFwiaW52YWxpZF9rZXlcIikge1xuICAgICAgICBwcm9jZXNzRXJyb3IoeyBpc3N1ZXM6IGlzc3VlMi5pc3N1ZXMgfSk7XG4gICAgICB9IGVsc2UgaWYgKGlzc3VlMi5jb2RlID09PSBcImludmFsaWRfZWxlbWVudFwiKSB7XG4gICAgICAgIHByb2Nlc3NFcnJvcih7IGlzc3VlczogaXNzdWUyLmlzc3VlcyB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNzdWUyLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGZpZWxkRXJyb3JzLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUyKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgY3VyciA9IGZpZWxkRXJyb3JzO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgaXNzdWUyLnBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgZWwgPSBpc3N1ZTIucGF0aFtpXTtcbiAgICAgICAgICBjb25zdCB0ZXJtaW5hbCA9IGkgPT09IGlzc3VlMi5wYXRoLmxlbmd0aCAtIDE7XG4gICAgICAgICAgaWYgKCF0ZXJtaW5hbCkge1xuICAgICAgICAgICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgY3VycltlbF0uX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZTIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VyciA9IGN1cnJbZWxdO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcHJvY2Vzc0Vycm9yKGVycm9yKTtcbiAgcmV0dXJuIGZpZWxkRXJyb3JzO1xufVxuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vem9kQDQuMC4xL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9wYXJzZS5qc1xudmFyIF9wYXJzZSA9IChfRXJyKSA9PiAoc2NoZW1hLCB2YWx1ZSwgX2N0eCwgX3BhcmFtcykgPT4ge1xuICBjb25zdCBjdHggPSBfY3R4ID8gT2JqZWN0LmFzc2lnbihfY3R4LCB7IGFzeW5jOiBmYWxzZSB9KSA6IHsgYXN5bmM6IGZhbHNlIH07XG4gIGNvbnN0IHJlc3VsdCA9IHNjaGVtYS5fem9kLnJ1bih7IHZhbHVlLCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgdGhyb3cgbmV3ICRab2RBc3luY0Vycm9yKCk7XG4gIH1cbiAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgY29uc3QgZSA9IG5ldyAoX3BhcmFtcz8uRXJyID8/IF9FcnIpKHJlc3VsdC5pc3N1ZXMubWFwKChpc3MpID0+IGZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvbmZpZygpKSkpO1xuICAgIGNhcHR1cmVTdGFja1RyYWNlKGUsIF9wYXJhbXM/LmNhbGxlZSk7XG4gICAgdGhyb3cgZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LnZhbHVlO1xufTtcbnZhciBfcGFyc2VBc3luYyA9IChfRXJyKSA9PiBhc3luYyAoc2NoZW1hLCB2YWx1ZSwgX2N0eCwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IGN0eCA9IF9jdHggPyBPYmplY3QuYXNzaWduKF9jdHgsIHsgYXN5bmM6IHRydWUgfSkgOiB7IGFzeW5jOiB0cnVlIH07XG4gIGxldCByZXN1bHQgPSBzY2hlbWEuX3pvZC5ydW4oeyB2YWx1ZSwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSlcbiAgICByZXN1bHQgPSBhd2FpdCByZXN1bHQ7XG4gIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgIGNvbnN0IGUgPSBuZXcgKHBhcmFtcz8uRXJyID8/IF9FcnIpKHJlc3VsdC5pc3N1ZXMubWFwKChpc3MpID0+IGZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvbmZpZygpKSkpO1xuICAgIGNhcHR1cmVTdGFja1RyYWNlKGUsIHBhcmFtcz8uY2FsbGVlKTtcbiAgICB0aHJvdyBlO1xuICB9XG4gIHJldHVybiByZXN1bHQudmFsdWU7XG59O1xudmFyIF9zYWZlUGFyc2UgPSAoX0VycikgPT4gKHNjaGVtYSwgdmFsdWUsIF9jdHgpID0+IHtcbiAgY29uc3QgY3R4ID0gX2N0eCA/IHsgLi4uX2N0eCwgYXN5bmM6IGZhbHNlIH0gOiB7IGFzeW5jOiBmYWxzZSB9O1xuICBjb25zdCByZXN1bHQgPSBzY2hlbWEuX3pvZC5ydW4oeyB2YWx1ZSwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgIHRocm93IG5ldyAkWm9kQXN5bmNFcnJvcigpO1xuICB9XG4gIHJldHVybiByZXN1bHQuaXNzdWVzLmxlbmd0aCA/IHtcbiAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICBlcnJvcjogbmV3IChfRXJyID8/ICRab2RFcnJvcikocmVzdWx0Lmlzc3Vlcy5tYXAoKGlzcykgPT4gZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29uZmlnKCkpKSlcbiAgfSA6IHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVzdWx0LnZhbHVlIH07XG59O1xudmFyIHNhZmVQYXJzZSA9IC8qIEBfX1BVUkVfXyAqLyBfc2FmZVBhcnNlKCRab2RSZWFsRXJyb3IpO1xudmFyIF9zYWZlUGFyc2VBc3luYyA9IChfRXJyKSA9PiBhc3luYyAoc2NoZW1hLCB2YWx1ZSwgX2N0eCkgPT4ge1xuICBjb25zdCBjdHggPSBfY3R4ID8gT2JqZWN0LmFzc2lnbihfY3R4LCB7IGFzeW5jOiB0cnVlIH0pIDogeyBhc3luYzogdHJ1ZSB9O1xuICBsZXQgcmVzdWx0ID0gc2NoZW1hLl96b2QucnVuKHsgdmFsdWUsIGlzc3VlczogW10gfSwgY3R4KTtcbiAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpXG4gICAgcmVzdWx0ID0gYXdhaXQgcmVzdWx0O1xuICByZXR1cm4gcmVzdWx0Lmlzc3Vlcy5sZW5ndGggPyB7XG4gICAgc3VjY2VzczogZmFsc2UsXG4gICAgZXJyb3I6IG5ldyBfRXJyKHJlc3VsdC5pc3N1ZXMubWFwKChpc3MpID0+IGZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvbmZpZygpKSkpXG4gIH0gOiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHJlc3VsdC52YWx1ZSB9O1xufTtcbnZhciBzYWZlUGFyc2VBc3luYyA9IC8qIEBfX1BVUkVfXyAqLyBfc2FmZVBhcnNlQXN5bmMoJFpvZFJlYWxFcnJvcik7XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS96b2RANC4wLjEvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL2NoZWNrcy5qc1xudmFyICRab2RDaGVjayA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tcIiwgKGluc3QsIGRlZikgPT4ge1xuICB2YXIgX2E7XG4gIGluc3QuX3pvZCA/PyAoaW5zdC5fem9kID0ge30pO1xuICBpbnN0Ll96b2QuZGVmID0gZGVmO1xuICAoX2EgPSBpbnN0Ll96b2QpLm9uYXR0YWNoID8/IChfYS5vbmF0dGFjaCA9IFtdKTtcbn0pO1xudmFyICRab2RDaGVja01heExlbmd0aCA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tNYXhMZW5ndGhcIiwgKGluc3QsIGRlZikgPT4ge1xuICB2YXIgX2E7XG4gICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gIChfYSA9IGluc3QuX3pvZC5kZWYpLndoZW4gPz8gKF9hLndoZW4gPSAocGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IHZhbCA9IHBheWxvYWQudmFsdWU7XG4gICAgcmV0dXJuICFudWxsaXNoKHZhbCkgJiYgdmFsLmxlbmd0aCAhPT0gdm9pZCAwO1xuICB9KTtcbiAgaW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QyKSA9PiB7XG4gICAgY29uc3QgY3VyciA9IGluc3QyLl96b2QuYmFnLm1heGltdW0gPz8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGlmIChkZWYubWF4aW11bSA8IGN1cnIpXG4gICAgICBpbnN0Mi5fem9kLmJhZy5tYXhpbXVtID0gZGVmLm1heGltdW07XG4gIH0pO1xuICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA8PSBkZWYubWF4aW11bSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvcmlnaW4gPSBnZXRMZW5ndGhhYmxlT3JpZ2luKGlucHV0KTtcbiAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgIG9yaWdpbixcbiAgICAgIGNvZGU6IFwidG9vX2JpZ1wiLFxuICAgICAgbWF4aW11bTogZGVmLm1heGltdW0sXG4gICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICBpbnB1dCxcbiAgICAgIGluc3QsXG4gICAgICBjb250aW51ZTogIWRlZi5hYm9ydFxuICAgIH0pO1xuICB9O1xufSk7XG52YXIgJFpvZENoZWNrTWluTGVuZ3RoID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RDaGVja01pbkxlbmd0aFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gIHZhciBfYTtcbiAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgKF9hID0gaW5zdC5fem9kLmRlZikud2hlbiA/PyAoX2Eud2hlbiA9IChwYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgdmFsID0gcGF5bG9hZC52YWx1ZTtcbiAgICByZXR1cm4gIW51bGxpc2godmFsKSAmJiB2YWwubGVuZ3RoICE9PSB2b2lkIDA7XG4gIH0pO1xuICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdDIpID0+IHtcbiAgICBjb25zdCBjdXJyID0gaW5zdDIuX3pvZC5iYWcubWluaW11bSA/PyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgaWYgKGRlZi5taW5pbXVtID4gY3VycilcbiAgICAgIGluc3QyLl96b2QuYmFnLm1pbmltdW0gPSBkZWYubWluaW11bTtcbiAgfSk7XG4gIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoID49IGRlZi5taW5pbXVtKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG9yaWdpbiA9IGdldExlbmd0aGFibGVPcmlnaW4oaW5wdXQpO1xuICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgb3JpZ2luLFxuICAgICAgY29kZTogXCJ0b29fc21hbGxcIixcbiAgICAgIG1pbmltdW06IGRlZi5taW5pbXVtLFxuICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgaW5wdXQsXG4gICAgICBpbnN0LFxuICAgICAgY29udGludWU6ICFkZWYuYWJvcnRcbiAgICB9KTtcbiAgfTtcbn0pO1xudmFyICRab2RDaGVja0xlbmd0aEVxdWFscyA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tMZW5ndGhFcXVhbHNcIiwgKGluc3QsIGRlZikgPT4ge1xuICB2YXIgX2E7XG4gICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gIChfYSA9IGluc3QuX3pvZC5kZWYpLndoZW4gPz8gKF9hLndoZW4gPSAocGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IHZhbCA9IHBheWxvYWQudmFsdWU7XG4gICAgcmV0dXJuICFudWxsaXNoKHZhbCkgJiYgdmFsLmxlbmd0aCAhPT0gdm9pZCAwO1xuICB9KTtcbiAgaW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QyKSA9PiB7XG4gICAgY29uc3QgYmFnID0gaW5zdDIuX3pvZC5iYWc7XG4gICAgYmFnLm1pbmltdW0gPSBkZWYubGVuZ3RoO1xuICAgIGJhZy5tYXhpbXVtID0gZGVmLmxlbmd0aDtcbiAgICBiYWcubGVuZ3RoID0gZGVmLmxlbmd0aDtcbiAgfSk7XG4gIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoID09PSBkZWYubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG9yaWdpbiA9IGdldExlbmd0aGFibGVPcmlnaW4oaW5wdXQpO1xuICAgIGNvbnN0IHRvb0JpZyA9IGxlbmd0aCA+IGRlZi5sZW5ndGg7XG4gICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICBvcmlnaW4sXG4gICAgICAuLi50b29CaWcgPyB7IGNvZGU6IFwidG9vX2JpZ1wiLCBtYXhpbXVtOiBkZWYubGVuZ3RoIH0gOiB7IGNvZGU6IFwidG9vX3NtYWxsXCIsIG1pbmltdW06IGRlZi5sZW5ndGggfSxcbiAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICBpbnN0LFxuICAgICAgY29udGludWU6ICFkZWYuYWJvcnRcbiAgICB9KTtcbiAgfTtcbn0pO1xudmFyICRab2RDaGVja092ZXJ3cml0ZSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tPdmVyd3JpdGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgIHBheWxvYWQudmFsdWUgPSBkZWYudHgocGF5bG9hZC52YWx1ZSk7XG4gIH07XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NvcmUvZG9jLmpzXG52YXIgRG9jID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihhcmdzID0gW10pIHtcbiAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICB0aGlzLmluZGVudCA9IDA7XG4gICAgaWYgKHRoaXMpXG4gICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICB9XG4gIGluZGVudGVkKGZuKSB7XG4gICAgdGhpcy5pbmRlbnQgKz0gMTtcbiAgICBmbih0aGlzKTtcbiAgICB0aGlzLmluZGVudCAtPSAxO1xuICB9XG4gIHdyaXRlKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGFyZyh0aGlzLCB7IGV4ZWN1dGlvbjogXCJzeW5jXCIgfSk7XG4gICAgICBhcmcodGhpcywgeyBleGVjdXRpb246IFwiYXN5bmNcIiB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29udGVudCA9IGFyZztcbiAgICBjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoXCJcXG5cIikuZmlsdGVyKCh4KSA9PiB4KTtcbiAgICBjb25zdCBtaW5JbmRlbnQgPSBNYXRoLm1pbiguLi5saW5lcy5tYXAoKHgpID0+IHgubGVuZ3RoIC0geC50cmltU3RhcnQoKS5sZW5ndGgpKTtcbiAgICBjb25zdCBkZWRlbnRlZCA9IGxpbmVzLm1hcCgoeCkgPT4geC5zbGljZShtaW5JbmRlbnQpKS5tYXAoKHgpID0+IFwiIFwiLnJlcGVhdCh0aGlzLmluZGVudCAqIDIpICsgeCk7XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGRlZGVudGVkKSB7XG4gICAgICB0aGlzLmNvbnRlbnQucHVzaChsaW5lKTtcbiAgICB9XG4gIH1cbiAgY29tcGlsZSgpIHtcbiAgICBjb25zdCBGID0gRnVuY3Rpb247XG4gICAgY29uc3QgYXJncyA9IHRoaXM/LmFyZ3M7XG4gICAgY29uc3QgY29udGVudCA9IHRoaXM/LmNvbnRlbnQgPz8gW2BgXTtcbiAgICBjb25zdCBsaW5lcyA9IFsuLi5jb250ZW50Lm1hcCgoeCkgPT4gYCAgJHt4fWApXTtcbiAgICByZXR1cm4gbmV3IEYoLi4uYXJncywgbGluZXMuam9pbihcIlxcblwiKSk7XG4gIH1cbn07XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS96b2RANC4wLjEvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3ZlcnNpb25zLmpzXG52YXIgdmVyc2lvbiA9IHtcbiAgbWFqb3I6IDQsXG4gIG1pbm9yOiAwLFxuICBwYXRjaDogMFxufTtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NvcmUvc2NoZW1hcy5qc1xudmFyICRab2RUeXBlID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RUeXBlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgdmFyIF9hO1xuICBpbnN0ID8/IChpbnN0ID0ge30pO1xuICBpbnN0Ll96b2QuZGVmID0gZGVmO1xuICBpbnN0Ll96b2QuYmFnID0gaW5zdC5fem9kLmJhZyB8fCB7fTtcbiAgaW5zdC5fem9kLnZlcnNpb24gPSB2ZXJzaW9uO1xuICBjb25zdCBjaGVja3MgPSBbLi4uaW5zdC5fem9kLmRlZi5jaGVja3MgPz8gW11dO1xuICBpZiAoaW5zdC5fem9kLnRyYWl0cy5oYXMoXCIkWm9kQ2hlY2tcIikpIHtcbiAgICBjaGVja3MudW5zaGlmdChpbnN0KTtcbiAgfVxuICBmb3IgKGNvbnN0IGNoIG9mIGNoZWNrcykge1xuICAgIGZvciAoY29uc3QgZm4gb2YgY2guX3pvZC5vbmF0dGFjaCkge1xuICAgICAgZm4oaW5zdCk7XG4gICAgfVxuICB9XG4gIGlmIChjaGVja3MubGVuZ3RoID09PSAwKSB7XG4gICAgKF9hID0gaW5zdC5fem9kKS5kZWZlcnJlZCA/PyAoX2EuZGVmZXJyZWQgPSBbXSk7XG4gICAgaW5zdC5fem9kLmRlZmVycmVkPy5wdXNoKCgpID0+IHtcbiAgICAgIGluc3QuX3pvZC5ydW4gPSBpbnN0Ll96b2QucGFyc2U7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcnVuQ2hlY2tzID0gKHBheWxvYWQsIGNoZWNrczIsIGN0eCkgPT4ge1xuICAgICAgbGV0IGlzQWJvcnRlZCA9IGFib3J0ZWQocGF5bG9hZCk7XG4gICAgICBsZXQgYXN5bmNSZXN1bHQ7XG4gICAgICBmb3IgKGNvbnN0IGNoIG9mIGNoZWNrczIpIHtcbiAgICAgICAgaWYgKGNoLl96b2QuZGVmLndoZW4pIHtcbiAgICAgICAgICBjb25zdCBzaG91bGRSdW4gPSBjaC5fem9kLmRlZi53aGVuKHBheWxvYWQpO1xuICAgICAgICAgIGlmICghc2hvdWxkUnVuKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBYm9ydGVkKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VyckxlbiA9IHBheWxvYWQuaXNzdWVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgXyA9IGNoLl96b2QuY2hlY2socGF5bG9hZCk7XG4gICAgICAgIGlmIChfIGluc3RhbmNlb2YgUHJvbWlzZSAmJiBjdHg/LmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgIHRocm93IG5ldyAkWm9kQXN5bmNFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhc3luY1Jlc3VsdCB8fCBfIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgIGFzeW5jUmVzdWx0ID0gKGFzeW5jUmVzdWx0ID8/IFByb21pc2UucmVzb2x2ZSgpKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IF87XG4gICAgICAgICAgICBjb25zdCBuZXh0TGVuID0gcGF5bG9hZC5pc3N1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG5leHRMZW4gPT09IGN1cnJMZW4pXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghaXNBYm9ydGVkKVxuICAgICAgICAgICAgICBpc0Fib3J0ZWQgPSBhYm9ydGVkKHBheWxvYWQsIGN1cnJMZW4pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG5leHRMZW4gPSBwYXlsb2FkLmlzc3Vlcy5sZW5ndGg7XG4gICAgICAgICAgaWYgKG5leHRMZW4gPT09IGN1cnJMZW4pXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBpZiAoIWlzQWJvcnRlZClcbiAgICAgICAgICAgIGlzQWJvcnRlZCA9IGFib3J0ZWQocGF5bG9hZCwgY3Vyckxlbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhc3luY1Jlc3VsdCkge1xuICAgICAgICByZXR1cm4gYXN5bmNSZXN1bHQudGhlbigoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbiAgICBpbnN0Ll96b2QucnVuID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gaW5zdC5fem9kLnBhcnNlKHBheWxvYWQsIGN0eCk7XG4gICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBpZiAoY3R4LmFzeW5jID09PSBmYWxzZSlcbiAgICAgICAgICB0aHJvdyBuZXcgJFpvZEFzeW5jRXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQyKSA9PiBydW5DaGVja3MocmVzdWx0MiwgY2hlY2tzLCBjdHgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBydW5DaGVja3MocmVzdWx0LCBjaGVja3MsIGN0eCk7XG4gICAgfTtcbiAgfVxuICBpbnN0W1wifnN0YW5kYXJkXCJdID0ge1xuICAgIHZhbGlkYXRlOiAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHIgPSBzYWZlUGFyc2UoaW5zdCwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gci5zdWNjZXNzID8geyB2YWx1ZTogci5kYXRhIH0gOiB7IGlzc3Vlczogci5lcnJvcj8uaXNzdWVzIH07XG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBzYWZlUGFyc2VBc3luYyhpbnN0LCB2YWx1ZSkudGhlbigocikgPT4gci5zdWNjZXNzID8geyB2YWx1ZTogci5kYXRhIH0gOiB7IGlzc3Vlczogci5lcnJvcj8uaXNzdWVzIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmVuZG9yOiBcInpvZFwiLFxuICAgIHZlcnNpb246IDFcbiAgfTtcbn0pO1xudmFyICRab2RVbmtub3duID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RVbmtub3duXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCkgPT4gcGF5bG9hZDtcbn0pO1xudmFyICRab2ROZXZlciA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kTmV2ZXJcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICBleHBlY3RlZDogXCJuZXZlclwiLFxuICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgaW5zdFxuICAgIH0pO1xuICAgIHJldHVybiBwYXlsb2FkO1xuICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVBcnJheVJlc3VsdChyZXN1bHQsIGZpbmFsLCBpbmRleCkge1xuICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICBmaW5hbC5pc3N1ZXMucHVzaCguLi5wcmVmaXhJc3N1ZXMoaW5kZXgsIHJlc3VsdC5pc3N1ZXMpKTtcbiAgfVxuICBmaW5hbC52YWx1ZVtpbmRleF0gPSByZXN1bHQudmFsdWU7XG59XG52YXIgJFpvZEFycmF5ID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RBcnJheVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgZXhwZWN0ZWQ6IFwiYXJyYXlcIixcbiAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIGluc3RcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfVxuICAgIHBheWxvYWQudmFsdWUgPSBBcnJheShpbnB1dC5sZW5ndGgpO1xuICAgIGNvbnN0IHByb21zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGlucHV0W2ldO1xuICAgICAgY29uc3QgcmVzdWx0ID0gZGVmLmVsZW1lbnQuX3pvZC5ydW4oe1xuICAgICAgICB2YWx1ZTogaXRlbSxcbiAgICAgICAgaXNzdWVzOiBbXVxuICAgICAgfSwgY3R4KTtcbiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHByb21zLnB1c2gocmVzdWx0LnRoZW4oKHJlc3VsdDIpID0+IGhhbmRsZUFycmF5UmVzdWx0KHJlc3VsdDIsIHBheWxvYWQsIGkpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVBcnJheVJlc3VsdChyZXN1bHQsIHBheWxvYWQsIGkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbXMpLnRoZW4oKCkgPT4gcGF5bG9hZCk7XG4gICAgfVxuICAgIHJldHVybiBwYXlsb2FkO1xuICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVPYmplY3RSZXN1bHQocmVzdWx0LCBmaW5hbCwga2V5KSB7XG4gIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgIGZpbmFsLmlzc3Vlcy5wdXNoKC4uLnByZWZpeElzc3VlcyhrZXksIHJlc3VsdC5pc3N1ZXMpKTtcbiAgfVxuICBmaW5hbC52YWx1ZVtrZXldID0gcmVzdWx0LnZhbHVlO1xufVxuZnVuY3Rpb24gaGFuZGxlT3B0aW9uYWxPYmplY3RSZXN1bHQocmVzdWx0LCBmaW5hbCwga2V5LCBpbnB1dCkge1xuICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICBpZiAoaW5wdXRba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoa2V5IGluIGlucHV0KSB7XG4gICAgICAgIGZpbmFsLnZhbHVlW2tleV0gPSB2b2lkIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5hbC52YWx1ZVtrZXldID0gcmVzdWx0LnZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmaW5hbC5pc3N1ZXMucHVzaCguLi5wcmVmaXhJc3N1ZXMoa2V5LCByZXN1bHQuaXNzdWVzKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHJlc3VsdC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgaWYgKGtleSBpbiBpbnB1dClcbiAgICAgIGZpbmFsLnZhbHVlW2tleV0gPSB2b2lkIDA7XG4gIH0gZWxzZSB7XG4gICAgZmluYWwudmFsdWVba2V5XSA9IHJlc3VsdC52YWx1ZTtcbiAgfVxufVxudmFyICRab2RPYmplY3QgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZE9iamVjdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgY29uc3QgX25vcm1hbGl6ZWQgPSBjYWNoZWQoKCkgPT4ge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkZWYuc2hhcGUpO1xuICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICBpZiAoIShkZWYuc2hhcGVba10gaW5zdGFuY2VvZiAkWm9kVHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGVsZW1lbnQgYXQga2V5IFwiJHtrfVwiOiBleHBlY3RlZCBhIFpvZCBzY2hlbWFgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb2tleXMgPSBvcHRpb25hbEtleXMoZGVmLnNoYXBlKTtcbiAgICByZXR1cm4ge1xuICAgICAgc2hhcGU6IGRlZi5zaGFwZSxcbiAgICAgIGtleXMsXG4gICAgICBrZXlTZXQ6IG5ldyBTZXQoa2V5cyksXG4gICAgICBudW1LZXlzOiBrZXlzLmxlbmd0aCxcbiAgICAgIG9wdGlvbmFsS2V5czogbmV3IFNldChva2V5cylcbiAgICB9O1xuICB9KTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicHJvcFZhbHVlc1wiLCAoKSA9PiB7XG4gICAgY29uc3Qgc2hhcGUgPSBkZWYuc2hhcGU7XG4gICAgY29uc3QgcHJvcFZhbHVlcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNoYXBlKSB7XG4gICAgICBjb25zdCBmaWVsZCA9IHNoYXBlW2tleV0uX3pvZDtcbiAgICAgIGlmIChmaWVsZC52YWx1ZXMpIHtcbiAgICAgICAgcHJvcFZhbHVlc1trZXldID8/IChwcm9wVmFsdWVzW2tleV0gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIGZpZWxkLnZhbHVlcylcbiAgICAgICAgICBwcm9wVmFsdWVzW2tleV0uYWRkKHYpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlcztcbiAgfSk7XG4gIGNvbnN0IGdlbmVyYXRlRmFzdHBhc3MgPSAoc2hhcGUpID0+IHtcbiAgICBjb25zdCBkb2MgPSBuZXcgRG9jKFtcInNoYXBlXCIsIFwicGF5bG9hZFwiLCBcImN0eFwiXSk7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IF9ub3JtYWxpemVkLnZhbHVlO1xuICAgIGNvbnN0IHBhcnNlU3RyID0gKGtleSkgPT4ge1xuICAgICAgY29uc3QgayA9IGVzYyhrZXkpO1xuICAgICAgcmV0dXJuIGBzaGFwZVske2t9XS5fem9kLnJ1bih7IHZhbHVlOiBpbnB1dFske2t9XSwgaXNzdWVzOiBbXSB9LCBjdHgpYDtcbiAgICB9O1xuICAgIGRvYy53cml0ZShgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO2ApO1xuICAgIGNvbnN0IGlkcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBub3JtYWxpemVkLmtleXMpIHtcbiAgICAgIGlkc1trZXldID0gYGtleV8ke2NvdW50ZXIrK31gO1xuICAgIH1cbiAgICBkb2Mud3JpdGUoYGNvbnN0IG5ld1Jlc3VsdCA9IHt9YCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2Ygbm9ybWFsaXplZC5rZXlzKSB7XG4gICAgICBpZiAobm9ybWFsaXplZC5vcHRpb25hbEtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgY29uc3QgaWQgPSBpZHNba2V5XTtcbiAgICAgICAgZG9jLndyaXRlKGBjb25zdCAke2lkfSA9ICR7cGFyc2VTdHIoa2V5KX07YCk7XG4gICAgICAgIGNvbnN0IGsgPSBlc2Moa2V5KTtcbiAgICAgICAgZG9jLndyaXRlKGBcbiAgICAgICAgaWYgKCR7aWR9Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoaW5wdXRbJHtrfV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCR7a30gaW4gaW5wdXQpIHtcbiAgICAgICAgICAgICAgbmV3UmVzdWx0WyR7a31dID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3VlcyA9IHBheWxvYWQuaXNzdWVzLmNvbmNhdChcbiAgICAgICAgICAgICAgJHtpZH0uaXNzdWVzLm1hcCgoaXNzKSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLmlzcyxcbiAgICAgICAgICAgICAgICBwYXRoOiBpc3MucGF0aCA/IFske2t9LCAuLi5pc3MucGF0aF0gOiBbJHtrfV0sXG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoJHtpZH0udmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgke2t9IGluIGlucHV0KSBuZXdSZXN1bHRbJHtrfV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3UmVzdWx0WyR7a31dID0gJHtpZH0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpZCA9IGlkc1trZXldO1xuICAgICAgICBkb2Mud3JpdGUoYGNvbnN0ICR7aWR9ID0gJHtwYXJzZVN0cihrZXkpfTtgKTtcbiAgICAgICAgZG9jLndyaXRlKGBcbiAgICAgICAgICBpZiAoJHtpZH0uaXNzdWVzLmxlbmd0aCkgcGF5bG9hZC5pc3N1ZXMgPSBwYXlsb2FkLmlzc3Vlcy5jb25jYXQoJHtpZH0uaXNzdWVzLm1hcChpc3MgPT4gKHtcbiAgICAgICAgICAgIC4uLmlzcyxcbiAgICAgICAgICAgIHBhdGg6IGlzcy5wYXRoID8gWyR7ZXNjKGtleSl9LCAuLi5pc3MucGF0aF0gOiBbJHtlc2Moa2V5KX1dXG4gICAgICAgICAgfSkpKTtgKTtcbiAgICAgICAgZG9jLndyaXRlKGBuZXdSZXN1bHRbJHtlc2Moa2V5KX1dID0gJHtpZH0udmFsdWVgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZG9jLndyaXRlKGBwYXlsb2FkLnZhbHVlID0gbmV3UmVzdWx0O2ApO1xuICAgIGRvYy53cml0ZShgcmV0dXJuIHBheWxvYWQ7YCk7XG4gICAgY29uc3QgZm4gPSBkb2MuY29tcGlsZSgpO1xuICAgIHJldHVybiAocGF5bG9hZCwgY3R4KSA9PiBmbihzaGFwZSwgcGF5bG9hZCwgY3R4KTtcbiAgfTtcbiAgbGV0IGZhc3RwYXNzO1xuICBjb25zdCBpc09iamVjdDIgPSBpc09iamVjdDtcbiAgY29uc3Qgaml0ID0gIWdsb2JhbENvbmZpZy5qaXRsZXNzO1xuICBjb25zdCBhbGxvd3NFdmFsMiA9IGFsbG93c0V2YWw7XG4gIGNvbnN0IGZhc3RFbmFibGVkID0gaml0ICYmIGFsbG93c0V2YWwyLnZhbHVlO1xuICBjb25zdCBjYXRjaGFsbCA9IGRlZi5jYXRjaGFsbDtcbiAgbGV0IHZhbHVlO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgdmFsdWUgPz8gKHZhbHVlID0gX25vcm1hbGl6ZWQudmFsdWUpO1xuICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICBpZiAoIWlzT2JqZWN0MihpbnB1dCkpIHtcbiAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICBleHBlY3RlZDogXCJvYmplY3RcIixcbiAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIGluc3RcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfVxuICAgIGNvbnN0IHByb21zID0gW107XG4gICAgaWYgKGppdCAmJiBmYXN0RW5hYmxlZCAmJiBjdHg/LmFzeW5jID09PSBmYWxzZSAmJiBjdHguaml0bGVzcyAhPT0gdHJ1ZSkge1xuICAgICAgaWYgKCFmYXN0cGFzcylcbiAgICAgICAgZmFzdHBhc3MgPSBnZW5lcmF0ZUZhc3RwYXNzKGRlZi5zaGFwZSk7XG4gICAgICBwYXlsb2FkID0gZmFzdHBhc3MocGF5bG9hZCwgY3R4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF5bG9hZC52YWx1ZSA9IHt9O1xuICAgICAgY29uc3Qgc2hhcGUgPSB2YWx1ZS5zaGFwZTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIHZhbHVlLmtleXMpIHtcbiAgICAgICAgY29uc3QgZWwgPSBzaGFwZVtrZXldO1xuICAgICAgICBjb25zdCByID0gZWwuX3pvZC5ydW4oeyB2YWx1ZTogaW5wdXRba2V5XSwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICAgICAgICBjb25zdCBpc09wdGlvbmFsID0gZWwuX3pvZC5vcHRpbiA9PT0gXCJvcHRpb25hbFwiICYmIGVsLl96b2Qub3B0b3V0ID09PSBcIm9wdGlvbmFsXCI7XG4gICAgICAgIGlmIChyIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgIHByb21zLnB1c2goci50aGVuKChyMikgPT4gaXNPcHRpb25hbCA/IGhhbmRsZU9wdGlvbmFsT2JqZWN0UmVzdWx0KHIyLCBwYXlsb2FkLCBrZXksIGlucHV0KSA6IGhhbmRsZU9iamVjdFJlc3VsdChyMiwgcGF5bG9hZCwga2V5KSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICAgICAgICBoYW5kbGVPcHRpb25hbE9iamVjdFJlc3VsdChyLCBwYXlsb2FkLCBrZXksIGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVPYmplY3RSZXN1bHQociwgcGF5bG9hZCwga2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNhdGNoYWxsKSB7XG4gICAgICByZXR1cm4gcHJvbXMubGVuZ3RoID8gUHJvbWlzZS5hbGwocHJvbXMpLnRoZW4oKCkgPT4gcGF5bG9hZCkgOiBwYXlsb2FkO1xuICAgIH1cbiAgICBjb25zdCB1bnJlY29nbml6ZWQgPSBbXTtcbiAgICBjb25zdCBrZXlTZXQgPSB2YWx1ZS5rZXlTZXQ7XG4gICAgY29uc3QgX2NhdGNoYWxsID0gY2F0Y2hhbGwuX3pvZDtcbiAgICBjb25zdCB0ID0gX2NhdGNoYWxsLmRlZi50eXBlO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGlucHV0KSkge1xuICAgICAgaWYgKGtleVNldC5oYXMoa2V5KSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAodCA9PT0gXCJuZXZlclwiKSB7XG4gICAgICAgIHVucmVjb2duaXplZC5wdXNoKGtleSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgciA9IF9jYXRjaGFsbC5ydW4oeyB2YWx1ZTogaW5wdXRba2V5XSwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICAgICAgaWYgKHIgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHByb21zLnB1c2goci50aGVuKChyMikgPT4gaGFuZGxlT2JqZWN0UmVzdWx0KHIyLCBwYXlsb2FkLCBrZXkpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVPYmplY3RSZXN1bHQociwgcGF5bG9hZCwga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHVucmVjb2duaXplZC5sZW5ndGgpIHtcbiAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICBjb2RlOiBcInVucmVjb2duaXplZF9rZXlzXCIsXG4gICAgICAgIGtleXM6IHVucmVjb2duaXplZCxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIGluc3RcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIXByb21zLmxlbmd0aClcbiAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9tcykudGhlbigoKSA9PiB7XG4gICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9KTtcbiAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlVW5pb25SZXN1bHRzKHJlc3VsdHMsIGZpbmFsLCBpbnN0LCBjdHgpIHtcbiAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZmluYWwudmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICByZXR1cm4gZmluYWw7XG4gICAgfVxuICB9XG4gIGZpbmFsLmlzc3Vlcy5wdXNoKHtcbiAgICBjb2RlOiBcImludmFsaWRfdW5pb25cIixcbiAgICBpbnB1dDogZmluYWwudmFsdWUsXG4gICAgaW5zdCxcbiAgICBlcnJvcnM6IHJlc3VsdHMubWFwKChyZXN1bHQpID0+IHJlc3VsdC5pc3N1ZXMubWFwKChpc3MpID0+IGZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvbmZpZygpKSkpXG4gIH0pO1xuICByZXR1cm4gZmluYWw7XG59XG52YXIgJFpvZFVuaW9uID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RVbmlvblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0aW5cIiwgKCkgPT4gZGVmLm9wdGlvbnMuc29tZSgobykgPT4gby5fem9kLm9wdGluID09PSBcIm9wdGlvbmFsXCIpID8gXCJvcHRpb25hbFwiIDogdm9pZCAwKTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0b3V0XCIsICgpID0+IGRlZi5vcHRpb25zLnNvbWUoKG8pID0+IG8uX3pvZC5vcHRvdXQgPT09IFwib3B0aW9uYWxcIikgPyBcIm9wdGlvbmFsXCIgOiB2b2lkIDApO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4ge1xuICAgIGlmIChkZWYub3B0aW9ucy5ldmVyeSgobykgPT4gby5fem9kLnZhbHVlcykpIHtcbiAgICAgIHJldHVybiBuZXcgU2V0KGRlZi5vcHRpb25zLmZsYXRNYXAoKG9wdGlvbikgPT4gQXJyYXkuZnJvbShvcHRpb24uX3pvZC52YWx1ZXMpKSk7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH0pO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJwYXR0ZXJuXCIsICgpID0+IHtcbiAgICBpZiAoZGVmLm9wdGlvbnMuZXZlcnkoKG8pID0+IG8uX3pvZC5wYXR0ZXJuKSkge1xuICAgICAgY29uc3QgcGF0dGVybnMgPSBkZWYub3B0aW9ucy5tYXAoKG8pID0+IG8uX3pvZC5wYXR0ZXJuKTtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBeKCR7cGF0dGVybnMubWFwKChwKSA9PiBjbGVhblJlZ2V4KHAuc291cmNlKSkuam9pbihcInxcIil9KSRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfSk7XG4gIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICBsZXQgYXN5bmMgPSBmYWxzZTtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgZm9yIChjb25zdCBvcHRpb24gb2YgZGVmLm9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG9wdGlvbi5fem9kLnJ1bih7XG4gICAgICAgIHZhbHVlOiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICBpc3N1ZXM6IFtdXG4gICAgICB9LCBjdHgpO1xuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIGFzeW5jID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFhc3luYylcbiAgICAgIHJldHVybiBoYW5kbGVVbmlvblJlc3VsdHMocmVzdWx0cywgcGF5bG9hZCwgaW5zdCwgY3R4KTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocmVzdWx0cykudGhlbigocmVzdWx0czIpID0+IHtcbiAgICAgIHJldHVybiBoYW5kbGVVbmlvblJlc3VsdHMocmVzdWx0czIsIHBheWxvYWQsIGluc3QsIGN0eCk7XG4gICAgfSk7XG4gIH07XG59KTtcbnZhciAkWm9kSW50ZXJzZWN0aW9uID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RJbnRlcnNlY3Rpb25cIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgY29uc3QgbGVmdCA9IGRlZi5sZWZ0Ll96b2QucnVuKHsgdmFsdWU6IGlucHV0LCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gICAgY29uc3QgcmlnaHQgPSBkZWYucmlnaHQuX3pvZC5ydW4oeyB2YWx1ZTogaW5wdXQsIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICBjb25zdCBhc3luYyA9IGxlZnQgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHJpZ2h0IGluc3RhbmNlb2YgUHJvbWlzZTtcbiAgICBpZiAoYXN5bmMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChbbGVmdCwgcmlnaHRdKS50aGVuKChbbGVmdDIsIHJpZ2h0Ml0pID0+IHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZUludGVyc2VjdGlvblJlc3VsdHMocGF5bG9hZCwgbGVmdDIsIHJpZ2h0Mik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZUludGVyc2VjdGlvblJlc3VsdHMocGF5bG9hZCwgbGVmdCwgcmlnaHQpO1xuICB9O1xufSk7XG5mdW5jdGlvbiBtZXJnZVZhbHVlcyhhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgfVxuICBpZiAoYSBpbnN0YW5jZW9mIERhdGUgJiYgYiBpbnN0YW5jZW9mIERhdGUgJiYgK2EgPT09ICtiKSB7XG4gICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgfVxuICBpZiAoaXNQbGFpbk9iamVjdChhKSAmJiBpc1BsYWluT2JqZWN0KGIpKSB7XG4gICAgY29uc3QgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcbiAgICBjb25zdCBzaGFyZWRLZXlzID0gT2JqZWN0LmtleXMoYSkuZmlsdGVyKChrZXkpID0+IGJLZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEpO1xuICAgIGNvbnN0IG5ld09iaiA9IHsgLi4uYSwgLi4uYiB9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXJlZEtleXMpIHtcbiAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoYVtrZXldLCBiW2tleV0pO1xuICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICBtZXJnZUVycm9yUGF0aDogW2tleSwgLi4uc2hhcmVkVmFsdWUubWVyZ2VFcnJvclBhdGhdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBuZXdPYmpba2V5XSA9IHNoYXJlZFZhbHVlLmRhdGE7XG4gICAgfVxuICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdPYmogfTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBtZXJnZUVycm9yUGF0aDogW10gfTtcbiAgICB9XG4gICAgY29uc3QgbmV3QXJyYXkgPSBbXTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IGl0ZW1BID0gYVtpbmRleF07XG4gICAgICBjb25zdCBpdGVtQiA9IGJbaW5kZXhdO1xuICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhpdGVtQSwgaXRlbUIpO1xuICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICBtZXJnZUVycm9yUGF0aDogW2luZGV4LCAuLi5zaGFyZWRWYWx1ZS5tZXJnZUVycm9yUGF0aF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIG5ld0FycmF5LnB1c2goc2hhcmVkVmFsdWUuZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdBcnJheSB9O1xuICB9XG4gIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVyZ2VFcnJvclBhdGg6IFtdIH07XG59XG5mdW5jdGlvbiBoYW5kbGVJbnRlcnNlY3Rpb25SZXN1bHRzKHJlc3VsdCwgbGVmdCwgcmlnaHQpIHtcbiAgaWYgKGxlZnQuaXNzdWVzLmxlbmd0aCkge1xuICAgIHJlc3VsdC5pc3N1ZXMucHVzaCguLi5sZWZ0Lmlzc3Vlcyk7XG4gIH1cbiAgaWYgKHJpZ2h0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICByZXN1bHQuaXNzdWVzLnB1c2goLi4ucmlnaHQuaXNzdWVzKTtcbiAgfVxuICBpZiAoYWJvcnRlZChyZXN1bHQpKVxuICAgIHJldHVybiByZXN1bHQ7XG4gIGNvbnN0IG1lcmdlZCA9IG1lcmdlVmFsdWVzKGxlZnQudmFsdWUsIHJpZ2h0LnZhbHVlKTtcbiAgaWYgKCFtZXJnZWQudmFsaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVubWVyZ2FibGUgaW50ZXJzZWN0aW9uLiBFcnJvciBwYXRoOiAke0pTT04uc3RyaW5naWZ5KG1lcmdlZC5tZXJnZUVycm9yUGF0aCl9YCk7XG4gIH1cbiAgcmVzdWx0LnZhbHVlID0gbWVyZ2VkLmRhdGE7XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgJFpvZEVudW0gPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZEVudW1cIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGNvbnN0IHZhbHVlcyA9IGdldEVudW1WYWx1ZXMoZGVmLmVudHJpZXMpO1xuICBpbnN0Ll96b2QudmFsdWVzID0gbmV3IFNldCh2YWx1ZXMpO1xuICBpbnN0Ll96b2QucGF0dGVybiA9IG5ldyBSZWdFeHAoYF4oJHt2YWx1ZXMuZmlsdGVyKChrKSA9PiBwcm9wZXJ0eUtleVR5cGVzLmhhcyh0eXBlb2YgaykpLm1hcCgobykgPT4gdHlwZW9mIG8gPT09IFwic3RyaW5nXCIgPyBlc2NhcGVSZWdleChvKSA6IG8udG9TdHJpbmcoKSkuam9pbihcInxcIil9KSRgKTtcbiAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgaWYgKGluc3QuX3pvZC52YWx1ZXMuaGFzKGlucHV0KSkge1xuICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfVxuICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgY29kZTogXCJpbnZhbGlkX3ZhbHVlXCIsXG4gICAgICB2YWx1ZXMsXG4gICAgICBpbnB1dCxcbiAgICAgIGluc3RcbiAgICB9KTtcbiAgICByZXR1cm4gcGF5bG9hZDtcbiAgfTtcbn0pO1xudmFyICRab2RUcmFuc2Zvcm0gPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZFRyYW5zZm9ybVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICBjb25zdCBfb3V0ID0gZGVmLnRyYW5zZm9ybShwYXlsb2FkLnZhbHVlLCBwYXlsb2FkKTtcbiAgICBpZiAoX2N0eC5hc3luYykge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gX291dCBpbnN0YW5jZW9mIFByb21pc2UgPyBfb3V0IDogUHJvbWlzZS5yZXNvbHZlKF9vdXQpO1xuICAgICAgcmV0dXJuIG91dHB1dC50aGVuKChvdXRwdXQyKSA9PiB7XG4gICAgICAgIHBheWxvYWQudmFsdWUgPSBvdXRwdXQyO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoX291dCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHRocm93IG5ldyAkWm9kQXN5bmNFcnJvcigpO1xuICAgIH1cbiAgICBwYXlsb2FkLnZhbHVlID0gX291dDtcbiAgICByZXR1cm4gcGF5bG9hZDtcbiAgfTtcbn0pO1xudmFyICRab2RPcHRpb25hbCA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kT3B0aW9uYWxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QuX3pvZC5vcHRpbiA9IFwib3B0aW9uYWxcIjtcbiAgaW5zdC5fem9kLm9wdG91dCA9IFwib3B0aW9uYWxcIjtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IHtcbiAgICByZXR1cm4gZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcyA/IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsuLi5kZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzLCB2b2lkIDBdKSA6IHZvaWQgMDtcbiAgfSk7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcInBhdHRlcm5cIiwgKCkgPT4ge1xuICAgIGNvbnN0IHBhdHRlcm4gPSBkZWYuaW5uZXJUeXBlLl96b2QucGF0dGVybjtcbiAgICByZXR1cm4gcGF0dGVybiA/IG5ldyBSZWdFeHAoYF4oJHtjbGVhblJlZ2V4KHBhdHRlcm4uc291cmNlKX0pPyRgKSA6IHZvaWQgMDtcbiAgfSk7XG4gIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICBpZiAoZGVmLmlubmVyVHlwZS5fem9kLm9wdGluID09PSBcIm9wdGlvbmFsXCIpIHtcbiAgICAgIHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgfVxuICAgIGlmIChwYXlsb2FkLnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH1cbiAgICByZXR1cm4gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICB9O1xufSk7XG52YXIgJFpvZE51bGxhYmxlID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2ROdWxsYWJsZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0aW5cIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLm9wdGluKTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0b3V0XCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC5vcHRvdXQpO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJwYXR0ZXJuXCIsICgpID0+IHtcbiAgICBjb25zdCBwYXR0ZXJuID0gZGVmLmlubmVyVHlwZS5fem9kLnBhdHRlcm47XG4gICAgcmV0dXJuIHBhdHRlcm4gPyBuZXcgUmVnRXhwKGBeKCR7Y2xlYW5SZWdleChwYXR0ZXJuLnNvdXJjZSl9fG51bGwpJGApIDogdm9pZCAwO1xuICB9KTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IHtcbiAgICByZXR1cm4gZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcyA/IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsuLi5kZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzLCBudWxsXSkgOiB2b2lkIDA7XG4gIH0pO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgaWYgKHBheWxvYWQudmFsdWUgPT09IG51bGwpXG4gICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICByZXR1cm4gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICB9O1xufSk7XG52YXIgJFpvZERlZmF1bHQgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZERlZmF1bHRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QuX3pvZC5vcHRpbiA9IFwib3B0aW9uYWxcIjtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXMpO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgaWYgKHBheWxvYWQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcGF5bG9hZC52YWx1ZSA9IGRlZi5kZWZhdWx0VmFsdWU7XG4gICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKHJlc3VsdDIpID0+IGhhbmRsZURlZmF1bHRSZXN1bHQocmVzdWx0MiwgZGVmKSk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVEZWZhdWx0UmVzdWx0KHJlc3VsdCwgZGVmKTtcbiAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlRGVmYXVsdFJlc3VsdChwYXlsb2FkLCBkZWYpIHtcbiAgaWYgKHBheWxvYWQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgIHBheWxvYWQudmFsdWUgPSBkZWYuZGVmYXVsdFZhbHVlO1xuICB9XG4gIHJldHVybiBwYXlsb2FkO1xufVxudmFyICRab2RQcmVmYXVsdCA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kUHJlZmF1bHRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QuX3pvZC5vcHRpbiA9IFwib3B0aW9uYWxcIjtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXMpO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgaWYgKHBheWxvYWQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcGF5bG9hZC52YWx1ZSA9IGRlZi5kZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gIH07XG59KTtcbnZhciAkWm9kTm9uT3B0aW9uYWwgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZE5vbk9wdGlvbmFsXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4ge1xuICAgIGNvbnN0IHYgPSBkZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzO1xuICAgIHJldHVybiB2ID8gbmV3IFNldChbLi4udl0uZmlsdGVyKCh4KSA9PiB4ICE9PSB2b2lkIDApKSA6IHZvaWQgMDtcbiAgfSk7XG4gIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHJldHVybiByZXN1bHQudGhlbigocmVzdWx0MikgPT4gaGFuZGxlTm9uT3B0aW9uYWxSZXN1bHQocmVzdWx0MiwgaW5zdCkpO1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlTm9uT3B0aW9uYWxSZXN1bHQocmVzdWx0LCBpbnN0KTtcbiAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlTm9uT3B0aW9uYWxSZXN1bHQocGF5bG9hZCwgaW5zdCkge1xuICBpZiAoIXBheWxvYWQuaXNzdWVzLmxlbmd0aCAmJiBwYXlsb2FkLnZhbHVlID09PSB2b2lkIDApIHtcbiAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICBleHBlY3RlZDogXCJub25vcHRpb25hbFwiLFxuICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICBpbnN0XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHBheWxvYWQ7XG59XG52YXIgJFpvZENhdGNoID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RDYXRjaFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC5fem9kLm9wdGluID0gXCJvcHRpb25hbFwiO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRvdXRcIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLm9wdG91dCk7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzKTtcbiAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQyKSA9PiB7XG4gICAgICAgIHBheWxvYWQudmFsdWUgPSByZXN1bHQyLnZhbHVlO1xuICAgICAgICBpZiAocmVzdWx0Mi5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IGRlZi5jYXRjaFZhbHVlKHtcbiAgICAgICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICBpc3N1ZXM6IHJlc3VsdDIuaXNzdWVzLm1hcCgoaXNzKSA9PiBmaW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb25maWcoKSkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwYXlsb2FkLmlzc3VlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHBheWxvYWQudmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICBwYXlsb2FkLnZhbHVlID0gZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAuLi5wYXlsb2FkLFxuICAgICAgICBlcnJvcjoge1xuICAgICAgICAgIGlzc3VlczogcmVzdWx0Lmlzc3Vlcy5tYXAoKGlzcykgPT4gZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29uZmlnKCkpKVxuICAgICAgICB9LFxuICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZVxuICAgICAgfSk7XG4gICAgICBwYXlsb2FkLmlzc3VlcyA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gcGF5bG9hZDtcbiAgfTtcbn0pO1xudmFyICRab2RQaXBlID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RQaXBlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4gZGVmLmluLl96b2QudmFsdWVzKTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0aW5cIiwgKCkgPT4gZGVmLmluLl96b2Qub3B0aW4pO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRvdXRcIiwgKCkgPT4gZGVmLm91dC5fem9kLm9wdG91dCk7XG4gIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICBjb25zdCBsZWZ0ID0gZGVmLmluLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gbGVmdC50aGVuKChsZWZ0MikgPT4gaGFuZGxlUGlwZVJlc3VsdChsZWZ0MiwgZGVmLCBjdHgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZVBpcGVSZXN1bHQobGVmdCwgZGVmLCBjdHgpO1xuICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVQaXBlUmVzdWx0KGxlZnQsIGRlZiwgY3R4KSB7XG4gIGlmIChhYm9ydGVkKGxlZnQpKSB7XG4gICAgcmV0dXJuIGxlZnQ7XG4gIH1cbiAgcmV0dXJuIGRlZi5vdXQuX3pvZC5ydW4oeyB2YWx1ZTogbGVmdC52YWx1ZSwgaXNzdWVzOiBsZWZ0Lmlzc3VlcyB9LCBjdHgpO1xufVxudmFyICRab2RSZWFkb25seSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kUmVhZG9ubHlcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcInByb3BWYWx1ZXNcIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLnByb3BWYWx1ZXMpO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcyk7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdGluXCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC5vcHRpbik7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdG91dFwiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2Qub3B0b3V0KTtcbiAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKGhhbmRsZVJlYWRvbmx5UmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZVJlYWRvbmx5UmVzdWx0KHJlc3VsdCk7XG4gIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZVJlYWRvbmx5UmVzdWx0KHBheWxvYWQpIHtcbiAgcGF5bG9hZC52YWx1ZSA9IE9iamVjdC5mcmVlemUocGF5bG9hZC52YWx1ZSk7XG4gIHJldHVybiBwYXlsb2FkO1xufVxudmFyICRab2RDdXN0b20gPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZEN1c3RvbVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF8pID0+IHtcbiAgICByZXR1cm4gcGF5bG9hZDtcbiAgfTtcbiAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgY29uc3QgciA9IGRlZi5mbihpbnB1dCk7XG4gICAgaWYgKHIgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gci50aGVuKChyMikgPT4gaGFuZGxlUmVmaW5lUmVzdWx0KHIyLCBwYXlsb2FkLCBpbnB1dCwgaW5zdCkpO1xuICAgIH1cbiAgICBoYW5kbGVSZWZpbmVSZXN1bHQociwgcGF5bG9hZCwgaW5wdXQsIGluc3QpO1xuICAgIHJldHVybjtcbiAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlUmVmaW5lUmVzdWx0KHJlc3VsdCwgcGF5bG9hZCwgaW5wdXQsIGluc3QpIHtcbiAgaWYgKCFyZXN1bHQpIHtcbiAgICBjb25zdCBfaXNzID0ge1xuICAgICAgY29kZTogXCJjdXN0b21cIixcbiAgICAgIGlucHV0LFxuICAgICAgaW5zdCxcbiAgICAgIC8vIGluY29ycG9yYXRlcyBwYXJhbXMuZXJyb3IgaW50byBpc3N1ZSByZXBvcnRpbmdcbiAgICAgIHBhdGg6IFsuLi5pbnN0Ll96b2QuZGVmLnBhdGggPz8gW11dLFxuICAgICAgLy8gaW5jb3Jwb3JhdGVzIHBhcmFtcy5lcnJvciBpbnRvIGlzc3VlIHJlcG9ydGluZ1xuICAgICAgY29udGludWU6ICFpbnN0Ll96b2QuZGVmLmFib3J0XG4gICAgICAvLyBwYXJhbXM6IGluc3QuX3pvZC5kZWYucGFyYW1zLFxuICAgIH07XG4gICAgaWYgKGluc3QuX3pvZC5kZWYucGFyYW1zKVxuICAgICAgX2lzcy5wYXJhbXMgPSBpbnN0Ll96b2QuZGVmLnBhcmFtcztcbiAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKGlzc3VlKF9pc3MpKTtcbiAgfVxufVxuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vem9kQDQuMC4xL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9yZWdpc3RyaWVzLmpzXG52YXIgJG91dHB1dCA9IFN5bWJvbChcIlpvZE91dHB1dFwiKTtcbnZhciAkaW5wdXQgPSBTeW1ib2woXCJab2RJbnB1dFwiKTtcbnZhciAkWm9kUmVnaXN0cnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX21hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5faWRtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGFkZChzY2hlbWEsIC4uLl9tZXRhKSB7XG4gICAgY29uc3QgbWV0YSA9IF9tZXRhWzBdO1xuICAgIHRoaXMuX21hcC5zZXQoc2NoZW1hLCBtZXRhKTtcbiAgICBpZiAobWV0YSAmJiB0eXBlb2YgbWV0YSA9PT0gXCJvYmplY3RcIiAmJiBcImlkXCIgaW4gbWV0YSkge1xuICAgICAgaWYgKHRoaXMuX2lkbWFwLmhhcyhtZXRhLmlkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElEICR7bWV0YS5pZH0gYWxyZWFkeSBleGlzdHMgaW4gdGhlIHJlZ2lzdHJ5YCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9pZG1hcC5zZXQobWV0YS5pZCwgc2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9pZG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVtb3ZlKHNjaGVtYSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9tYXAuZ2V0KHNjaGVtYSk7XG4gICAgaWYgKG1ldGEgJiYgdHlwZW9mIG1ldGEgPT09IFwib2JqZWN0XCIgJiYgXCJpZFwiIGluIG1ldGEpIHtcbiAgICAgIHRoaXMuX2lkbWFwLmRlbGV0ZShtZXRhLmlkKTtcbiAgICB9XG4gICAgdGhpcy5fbWFwLmRlbGV0ZShzY2hlbWEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldChzY2hlbWEpIHtcbiAgICBjb25zdCBwID0gc2NoZW1hLl96b2QucGFyZW50O1xuICAgIGlmIChwKSB7XG4gICAgICBjb25zdCBwbSA9IHsgLi4udGhpcy5nZXQocCkgPz8ge30gfTtcbiAgICAgIGRlbGV0ZSBwbS5pZDtcbiAgICAgIHJldHVybiB7IC4uLnBtLCAuLi50aGlzLl9tYXAuZ2V0KHNjaGVtYSkgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX21hcC5nZXQoc2NoZW1hKTtcbiAgfVxuICBoYXMoc2NoZW1hKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5oYXMoc2NoZW1hKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJlZ2lzdHJ5KCkge1xuICByZXR1cm4gbmV3ICRab2RSZWdpc3RyeSgpO1xufVxudmFyIGdsb2JhbFJlZ2lzdHJ5ID0gLyogQF9fUFVSRV9fICovIHJlZ2lzdHJ5KCk7XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS96b2RANC4wLjEvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL2FwaS5qc1xuZnVuY3Rpb24gX3Vua25vd24oQ2xhc3MyKSB7XG4gIHJldHVybiBuZXcgQ2xhc3MyKHtcbiAgICB0eXBlOiBcInVua25vd25cIlxuICB9KTtcbn1cbmZ1bmN0aW9uIF9uZXZlcihDbGFzczIsIHBhcmFtcykge1xuICByZXR1cm4gbmV3IENsYXNzMih7XG4gICAgdHlwZTogXCJuZXZlclwiLFxuICAgIC4uLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufVxuZnVuY3Rpb24gX21heExlbmd0aChtYXhpbXVtLCBwYXJhbXMpIHtcbiAgY29uc3QgY2ggPSBuZXcgJFpvZENoZWNrTWF4TGVuZ3RoKHtcbiAgICBjaGVjazogXCJtYXhfbGVuZ3RoXCIsXG4gICAgLi4ubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgbWF4aW11bVxuICB9KTtcbiAgcmV0dXJuIGNoO1xufVxuZnVuY3Rpb24gX21pbkxlbmd0aChtaW5pbXVtLCBwYXJhbXMpIHtcbiAgcmV0dXJuIG5ldyAkWm9kQ2hlY2tNaW5MZW5ndGgoe1xuICAgIGNoZWNrOiBcIm1pbl9sZW5ndGhcIixcbiAgICAuLi5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICBtaW5pbXVtXG4gIH0pO1xufVxuZnVuY3Rpb24gX2xlbmd0aChsZW5ndGgsIHBhcmFtcykge1xuICByZXR1cm4gbmV3ICRab2RDaGVja0xlbmd0aEVxdWFscyh7XG4gICAgY2hlY2s6IFwibGVuZ3RoX2VxdWFsc1wiLFxuICAgIC4uLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIGxlbmd0aFxuICB9KTtcbn1cbmZ1bmN0aW9uIF9vdmVyd3JpdGUodHgpIHtcbiAgcmV0dXJuIG5ldyAkWm9kQ2hlY2tPdmVyd3JpdGUoe1xuICAgIGNoZWNrOiBcIm92ZXJ3cml0ZVwiLFxuICAgIHR4XG4gIH0pO1xufVxuZnVuY3Rpb24gX2FycmF5KENsYXNzMiwgZWxlbWVudCwgcGFyYW1zKSB7XG4gIHJldHVybiBuZXcgQ2xhc3MyKHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgZWxlbWVudCxcbiAgICAvLyBnZXQgZWxlbWVudCgpIHtcbiAgICAvLyAgIHJldHVybiBlbGVtZW50O1xuICAgIC8vIH0sXG4gICAgLi4ubm9ybWFsaXplUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59XG5mdW5jdGlvbiBfcmVmaW5lKENsYXNzMiwgZm4sIF9wYXJhbXMpIHtcbiAgY29uc3Qgc2NoZW1hID0gbmV3IENsYXNzMih7XG4gICAgdHlwZTogXCJjdXN0b21cIixcbiAgICBjaGVjazogXCJjdXN0b21cIixcbiAgICBmbixcbiAgICAuLi5ub3JtYWxpemVQYXJhbXMoX3BhcmFtcylcbiAgfSk7XG4gIHJldHVybiBzY2hlbWE7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS96b2RANC4wLjEvbm9kZV9tb2R1bGVzL3pvZC92NC9jbGFzc2ljL2Vycm9ycy5qc1xudmFyIGluaXRpYWxpemVyMiA9IChpbnN0LCBpc3N1ZXMpID0+IHtcbiAgJFpvZEVycm9yLmluaXQoaW5zdCwgaXNzdWVzKTtcbiAgaW5zdC5uYW1lID0gXCJab2RFcnJvclwiO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnN0LCB7XG4gICAgZm9ybWF0OiB7XG4gICAgICB2YWx1ZTogKG1hcHBlcikgPT4gZm9ybWF0RXJyb3IoaW5zdCwgbWFwcGVyKVxuICAgICAgLy8gZW51bWVyYWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICBmbGF0dGVuOiB7XG4gICAgICB2YWx1ZTogKG1hcHBlcikgPT4gZmxhdHRlbkVycm9yKGluc3QsIG1hcHBlcilcbiAgICAgIC8vIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgYWRkSXNzdWU6IHtcbiAgICAgIHZhbHVlOiAoaXNzdWUyKSA9PiBpbnN0Lmlzc3Vlcy5wdXNoKGlzc3VlMilcbiAgICAgIC8vIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgYWRkSXNzdWVzOiB7XG4gICAgICB2YWx1ZTogKGlzc3VlczIpID0+IGluc3QuaXNzdWVzLnB1c2goLi4uaXNzdWVzMilcbiAgICAgIC8vIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgaXNFbXB0eToge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gaW5zdC5pc3N1ZXMubGVuZ3RoID09PSAwO1xuICAgICAgfVxuICAgICAgLy8gZW51bWVyYWJsZTogZmFsc2UsXG4gICAgfVxuICB9KTtcbn07XG52YXIgWm9kRXJyb3IgPSAkY29uc3RydWN0b3IoXCJab2RFcnJvclwiLCBpbml0aWFsaXplcjIpO1xudmFyIFpvZFJlYWxFcnJvciA9ICRjb25zdHJ1Y3RvcihcIlpvZEVycm9yXCIsIGluaXRpYWxpemVyMiwge1xuICBQYXJlbnQ6IEVycm9yXG59KTtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NsYXNzaWMvcGFyc2UuanNcbnZhciBwYXJzZSA9IC8qIEBfX1BVUkVfXyAqLyBfcGFyc2UoWm9kUmVhbEVycm9yKTtcbnZhciBwYXJzZUFzeW5jID0gLyogQF9fUFVSRV9fICovIF9wYXJzZUFzeW5jKFpvZFJlYWxFcnJvcik7XG52YXIgc2FmZVBhcnNlMiA9IC8qIEBfX1BVUkVfXyAqLyBfc2FmZVBhcnNlKFpvZFJlYWxFcnJvcik7XG52YXIgc2FmZVBhcnNlQXN5bmMyID0gLyogQF9fUFVSRV9fICovIF9zYWZlUGFyc2VBc3luYyhab2RSZWFsRXJyb3IpO1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vem9kQDQuMC4xL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9zY2hlbWFzLmpzXG52YXIgWm9kVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2RUeXBlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0LmRlZiA9IGRlZjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIFwiX2RlZlwiLCB7IHZhbHVlOiBkZWYgfSk7XG4gIGluc3QuY2hlY2sgPSAoLi4uY2hlY2tzKSA9PiB7XG4gICAgcmV0dXJuIGluc3QuY2xvbmUoXG4gICAgICB7XG4gICAgICAgIC4uLmRlZixcbiAgICAgICAgY2hlY2tzOiBbXG4gICAgICAgICAgLi4uZGVmLmNoZWNrcyA/PyBbXSxcbiAgICAgICAgICAuLi5jaGVja3MubWFwKChjaCkgPT4gdHlwZW9mIGNoID09PSBcImZ1bmN0aW9uXCIgPyB7IF96b2Q6IHsgY2hlY2s6IGNoLCBkZWY6IHsgY2hlY2s6IFwiY3VzdG9tXCIgfSwgb25hdHRhY2g6IFtdIH0gfSA6IGNoKVxuICAgICAgICBdXG4gICAgICB9XG4gICAgICAvLyB7IHBhcmVudDogdHJ1ZSB9XG4gICAgKTtcbiAgfTtcbiAgaW5zdC5jbG9uZSA9IChkZWYyLCBwYXJhbXMpID0+IGNsb25lKGluc3QsIGRlZjIsIHBhcmFtcyk7XG4gIGluc3QuYnJhbmQgPSAoKSA9PiBpbnN0O1xuICBpbnN0LnJlZ2lzdGVyID0gKHJlZywgbWV0YSkgPT4ge1xuICAgIHJlZy5hZGQoaW5zdCwgbWV0YSk7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH07XG4gIGluc3QucGFyc2UgPSAoZGF0YSwgcGFyYW1zKSA9PiBwYXJzZShpbnN0LCBkYXRhLCBwYXJhbXMsIHsgY2FsbGVlOiBpbnN0LnBhcnNlIH0pO1xuICBpbnN0LnNhZmVQYXJzZSA9IChkYXRhLCBwYXJhbXMpID0+IHNhZmVQYXJzZTIoaW5zdCwgZGF0YSwgcGFyYW1zKTtcbiAgaW5zdC5wYXJzZUFzeW5jID0gYXN5bmMgKGRhdGEsIHBhcmFtcykgPT4gcGFyc2VBc3luYyhpbnN0LCBkYXRhLCBwYXJhbXMsIHsgY2FsbGVlOiBpbnN0LnBhcnNlQXN5bmMgfSk7XG4gIGluc3Quc2FmZVBhcnNlQXN5bmMgPSBhc3luYyAoZGF0YSwgcGFyYW1zKSA9PiBzYWZlUGFyc2VBc3luYzIoaW5zdCwgZGF0YSwgcGFyYW1zKTtcbiAgaW5zdC5zcGEgPSBpbnN0LnNhZmVQYXJzZUFzeW5jO1xuICBpbnN0LnJlZmluZSA9IChjaGVjazIsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhyZWZpbmUoY2hlY2syLCBwYXJhbXMpKTtcbiAgaW5zdC5zdXBlclJlZmluZSA9IChyZWZpbmVtZW50KSA9PiBpbnN0LmNoZWNrKHN1cGVyUmVmaW5lKHJlZmluZW1lbnQpKTtcbiAgaW5zdC5vdmVyd3JpdGUgPSAoZm4pID0+IGluc3QuY2hlY2soX292ZXJ3cml0ZShmbikpO1xuICBpbnN0Lm9wdGlvbmFsID0gKCkgPT4gb3B0aW9uYWwoaW5zdCk7XG4gIGluc3QubnVsbGFibGUgPSAoKSA9PiBudWxsYWJsZShpbnN0KTtcbiAgaW5zdC5udWxsaXNoID0gKCkgPT4gb3B0aW9uYWwobnVsbGFibGUoaW5zdCkpO1xuICBpbnN0Lm5vbm9wdGlvbmFsID0gKHBhcmFtcykgPT4gbm9ub3B0aW9uYWwoaW5zdCwgcGFyYW1zKTtcbiAgaW5zdC5hcnJheSA9ICgpID0+IGFycmF5KGluc3QpO1xuICBpbnN0Lm9yID0gKGFyZykgPT4gdW5pb24oW2luc3QsIGFyZ10pO1xuICBpbnN0LmFuZCA9IChhcmcpID0+IGludGVyc2VjdGlvbihpbnN0LCBhcmcpO1xuICBpbnN0LnRyYW5zZm9ybSA9ICh0eCkgPT4gcGlwZShpbnN0LCB0cmFuc2Zvcm0odHgpKTtcbiAgaW5zdC5kZWZhdWx0ID0gKGRlZjIpID0+IF9kZWZhdWx0KGluc3QsIGRlZjIpO1xuICBpbnN0LnByZWZhdWx0ID0gKGRlZjIpID0+IHByZWZhdWx0KGluc3QsIGRlZjIpO1xuICBpbnN0LmNhdGNoID0gKHBhcmFtcykgPT4gX2NhdGNoKGluc3QsIHBhcmFtcyk7XG4gIGluc3QucGlwZSA9ICh0YXJnZXQpID0+IHBpcGUoaW5zdCwgdGFyZ2V0KTtcbiAgaW5zdC5yZWFkb25seSA9ICgpID0+IHJlYWRvbmx5KGluc3QpO1xuICBpbnN0LmRlc2NyaWJlID0gKGRlc2NyaXB0aW9uKSA9PiB7XG4gICAgY29uc3QgY2wgPSBpbnN0LmNsb25lKCk7XG4gICAgZ2xvYmFsUmVnaXN0cnkuYWRkKGNsLCB7IGRlc2NyaXB0aW9uIH0pO1xuICAgIHJldHVybiBjbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIFwiZGVzY3JpcHRpb25cIiwge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBnbG9iYWxSZWdpc3RyeS5nZXQoaW5zdCk/LmRlc2NyaXB0aW9uO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBpbnN0Lm1ldGEgPSAoLi4uYXJncykgPT4ge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGdsb2JhbFJlZ2lzdHJ5LmdldChpbnN0KTtcbiAgICB9XG4gICAgY29uc3QgY2wgPSBpbnN0LmNsb25lKCk7XG4gICAgZ2xvYmFsUmVnaXN0cnkuYWRkKGNsLCBhcmdzWzBdKTtcbiAgICByZXR1cm4gY2w7XG4gIH07XG4gIGluc3QuaXNPcHRpb25hbCA9ICgpID0+IGluc3Quc2FmZVBhcnNlKHZvaWQgMCkuc3VjY2VzcztcbiAgaW5zdC5pc051bGxhYmxlID0gKCkgPT4gaW5zdC5zYWZlUGFyc2UobnVsbCkuc3VjY2VzcztcbiAgcmV0dXJuIGluc3Q7XG59KTtcbnZhciBab2RVbmtub3duID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZFVua25vd25cIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVW5rbm93bi5pbml0KGluc3QsIGRlZik7XG4gIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5mdW5jdGlvbiB1bmtub3duKCkge1xuICByZXR1cm4gX3Vua25vd24oWm9kVW5rbm93bik7XG59XG52YXIgWm9kTmV2ZXIgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kTmV2ZXJcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kTmV2ZXIuaW5pdChpbnN0LCBkZWYpO1xuICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZnVuY3Rpb24gbmV2ZXIocGFyYW1zKSB7XG4gIHJldHVybiBfbmV2ZXIoWm9kTmV2ZXIsIHBhcmFtcyk7XG59XG52YXIgWm9kQXJyYXkgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kQXJyYXlcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kQXJyYXkuaW5pdChpbnN0LCBkZWYpO1xuICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC5lbGVtZW50ID0gZGVmLmVsZW1lbnQ7XG4gIGluc3QubWluID0gKG1pbkxlbmd0aCwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKF9taW5MZW5ndGgobWluTGVuZ3RoLCBwYXJhbXMpKTtcbiAgaW5zdC5ub25lbXB0eSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soX21pbkxlbmd0aCgxLCBwYXJhbXMpKTtcbiAgaW5zdC5tYXggPSAobWF4TGVuZ3RoLCBwYXJhbXMpID0+IGluc3QuY2hlY2soX21heExlbmd0aChtYXhMZW5ndGgsIHBhcmFtcykpO1xuICBpbnN0Lmxlbmd0aCA9IChsZW4sIHBhcmFtcykgPT4gaW5zdC5jaGVjayhfbGVuZ3RoKGxlbiwgcGFyYW1zKSk7XG4gIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5lbGVtZW50O1xufSk7XG5mdW5jdGlvbiBhcnJheShlbGVtZW50LCBwYXJhbXMpIHtcbiAgcmV0dXJuIF9hcnJheShab2RBcnJheSwgZWxlbWVudCwgcGFyYW1zKTtcbn1cbnZhciBab2RPYmplY3QgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kT2JqZWN0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZE9iamVjdC5pbml0KGluc3QsIGRlZik7XG4gIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICB1dGlsX2V4cG9ydHMuZGVmaW5lTGF6eShpbnN0LCBcInNoYXBlXCIsICgpID0+IGRlZi5zaGFwZSk7XG4gIGluc3Qua2V5b2YgPSAoKSA9PiBfZW51bShPYmplY3Qua2V5cyhpbnN0Ll96b2QuZGVmLnNoYXBlKSk7XG4gIGluc3QuY2F0Y2hhbGwgPSAoY2F0Y2hhbGwpID0+IGluc3QuY2xvbmUoeyAuLi5pbnN0Ll96b2QuZGVmLCBjYXRjaGFsbCB9KTtcbiAgaW5zdC5wYXNzdGhyb3VnaCA9ICgpID0+IGluc3QuY2xvbmUoeyAuLi5pbnN0Ll96b2QuZGVmLCBjYXRjaGFsbDogdW5rbm93bigpIH0pO1xuICBpbnN0Lmxvb3NlID0gKCkgPT4gaW5zdC5jbG9uZSh7IC4uLmluc3QuX3pvZC5kZWYsIGNhdGNoYWxsOiB1bmtub3duKCkgfSk7XG4gIGluc3Quc3RyaWN0ID0gKCkgPT4gaW5zdC5jbG9uZSh7IC4uLmluc3QuX3pvZC5kZWYsIGNhdGNoYWxsOiBuZXZlcigpIH0pO1xuICBpbnN0LnN0cmlwID0gKCkgPT4gaW5zdC5jbG9uZSh7IC4uLmluc3QuX3pvZC5kZWYsIGNhdGNoYWxsOiB2b2lkIDAgfSk7XG4gIGluc3QuZXh0ZW5kID0gKGluY29taW5nKSA9PiB7XG4gICAgcmV0dXJuIHV0aWxfZXhwb3J0cy5leHRlbmQoaW5zdCwgaW5jb21pbmcpO1xuICB9O1xuICBpbnN0Lm1lcmdlID0gKG90aGVyKSA9PiB1dGlsX2V4cG9ydHMubWVyZ2UoaW5zdCwgb3RoZXIpO1xuICBpbnN0LnBpY2sgPSAobWFzaykgPT4gdXRpbF9leHBvcnRzLnBpY2soaW5zdCwgbWFzayk7XG4gIGluc3Qub21pdCA9IChtYXNrKSA9PiB1dGlsX2V4cG9ydHMub21pdChpbnN0LCBtYXNrKTtcbiAgaW5zdC5wYXJ0aWFsID0gKC4uLmFyZ3MpID0+IHV0aWxfZXhwb3J0cy5wYXJ0aWFsKFpvZE9wdGlvbmFsLCBpbnN0LCBhcmdzWzBdKTtcbiAgaW5zdC5yZXF1aXJlZCA9ICguLi5hcmdzKSA9PiB1dGlsX2V4cG9ydHMucmVxdWlyZWQoWm9kTm9uT3B0aW9uYWwsIGluc3QsIGFyZ3NbMF0pO1xufSk7XG52YXIgWm9kVW5pb24gPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kVW5pb25cIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVW5pb24uaW5pdChpbnN0LCBkZWYpO1xuICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC5vcHRpb25zID0gZGVmLm9wdGlvbnM7XG59KTtcbmZ1bmN0aW9uIHVuaW9uKG9wdGlvbnMsIHBhcmFtcykge1xuICByZXR1cm4gbmV3IFpvZFVuaW9uKHtcbiAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgb3B0aW9ucyxcbiAgICAuLi51dGlsX2V4cG9ydHMubm9ybWFsaXplUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59XG52YXIgWm9kSW50ZXJzZWN0aW9uID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZEludGVyc2VjdGlvblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RJbnRlcnNlY3Rpb24uaW5pdChpbnN0LCBkZWYpO1xuICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZnVuY3Rpb24gaW50ZXJzZWN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiBuZXcgWm9kSW50ZXJzZWN0aW9uKHtcbiAgICB0eXBlOiBcImludGVyc2VjdGlvblwiLFxuICAgIGxlZnQsXG4gICAgcmlnaHRcbiAgfSk7XG59XG52YXIgWm9kRW51bSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2RFbnVtXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZEVudW0uaW5pdChpbnN0LCBkZWYpO1xuICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC5lbnVtID0gZGVmLmVudHJpZXM7XG4gIGluc3Qub3B0aW9ucyA9IE9iamVjdC52YWx1ZXMoZGVmLmVudHJpZXMpO1xuICBjb25zdCBrZXlzID0gbmV3IFNldChPYmplY3Qua2V5cyhkZWYuZW50cmllcykpO1xuICBpbnN0LmV4dHJhY3QgPSAodmFsdWVzLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBuZXdFbnRyaWVzID0ge307XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmIChrZXlzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgbmV3RW50cmllc1t2YWx1ZV0gPSBkZWYuZW50cmllc1t2YWx1ZV07XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXkgJHt2YWx1ZX0gbm90IGZvdW5kIGluIGVudW1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBab2RFbnVtKHtcbiAgICAgIC4uLmRlZixcbiAgICAgIGNoZWNrczogW10sXG4gICAgICAuLi51dGlsX2V4cG9ydHMubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICBlbnRyaWVzOiBuZXdFbnRyaWVzXG4gICAgfSk7XG4gIH07XG4gIGluc3QuZXhjbHVkZSA9ICh2YWx1ZXMsIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IG5ld0VudHJpZXMgPSB7IC4uLmRlZi5lbnRyaWVzIH07XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmIChrZXlzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgZGVsZXRlIG5ld0VudHJpZXNbdmFsdWVdO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ICR7dmFsdWV9IG5vdCBmb3VuZCBpbiBlbnVtYCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgWm9kRW51bSh7XG4gICAgICAuLi5kZWYsXG4gICAgICBjaGVja3M6IFtdLFxuICAgICAgLi4udXRpbF9leHBvcnRzLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgZW50cmllczogbmV3RW50cmllc1xuICAgIH0pO1xuICB9O1xufSk7XG5mdW5jdGlvbiBfZW51bSh2YWx1ZXMsIHBhcmFtcykge1xuICBjb25zdCBlbnRyaWVzID0gQXJyYXkuaXNBcnJheSh2YWx1ZXMpID8gT2JqZWN0LmZyb21FbnRyaWVzKHZhbHVlcy5tYXAoKHYpID0+IFt2LCB2XSkpIDogdmFsdWVzO1xuICByZXR1cm4gbmV3IFpvZEVudW0oe1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIGVudHJpZXMsXG4gICAgLi4udXRpbF9leHBvcnRzLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufVxudmFyIFpvZFRyYW5zZm9ybSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2RUcmFuc2Zvcm1cIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVHJhbnNmb3JtLmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgcGF5bG9hZC5hZGRJc3N1ZSA9IChpc3N1ZTIpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaXNzdWUyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2godXRpbF9leHBvcnRzLmlzc3VlKGlzc3VlMiwgcGF5bG9hZC52YWx1ZSwgZGVmKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBfaXNzdWUgPSBpc3N1ZTI7XG4gICAgICAgIGlmIChfaXNzdWUuZmF0YWwpXG4gICAgICAgICAgX2lzc3VlLmNvbnRpbnVlID0gZmFsc2U7XG4gICAgICAgIF9pc3N1ZS5jb2RlID8/IChfaXNzdWUuY29kZSA9IFwiY3VzdG9tXCIpO1xuICAgICAgICBfaXNzdWUuaW5wdXQgPz8gKF9pc3N1ZS5pbnB1dCA9IHBheWxvYWQudmFsdWUpO1xuICAgICAgICBfaXNzdWUuaW5zdCA/PyAoX2lzc3VlLmluc3QgPSBpbnN0KTtcbiAgICAgICAgX2lzc3VlLmNvbnRpbnVlID8/IChfaXNzdWUuY29udGludWUgPSB0cnVlKTtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh1dGlsX2V4cG9ydHMuaXNzdWUoX2lzc3VlKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvdXRwdXQgPSBkZWYudHJhbnNmb3JtKHBheWxvYWQudmFsdWUsIHBheWxvYWQpO1xuICAgIGlmIChvdXRwdXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gb3V0cHV0LnRoZW4oKG91dHB1dDIpID0+IHtcbiAgICAgICAgcGF5bG9hZC52YWx1ZSA9IG91dHB1dDI7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHBheWxvYWQudmFsdWUgPSBvdXRwdXQ7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG4gIH07XG59KTtcbmZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICByZXR1cm4gbmV3IFpvZFRyYW5zZm9ybSh7XG4gICAgdHlwZTogXCJ0cmFuc2Zvcm1cIixcbiAgICB0cmFuc2Zvcm06IGZuXG4gIH0pO1xufVxudmFyIFpvZE9wdGlvbmFsID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZE9wdGlvbmFsXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZE9wdGlvbmFsLmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5pbm5lclR5cGU7XG59KTtcbmZ1bmN0aW9uIG9wdGlvbmFsKGlubmVyVHlwZSkge1xuICByZXR1cm4gbmV3IFpvZE9wdGlvbmFsKHtcbiAgICB0eXBlOiBcIm9wdGlvbmFsXCIsXG4gICAgaW5uZXJUeXBlXG4gIH0pO1xufVxudmFyIFpvZE51bGxhYmxlID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZE51bGxhYmxlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZE51bGxhYmxlLmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5pbm5lclR5cGU7XG59KTtcbmZ1bmN0aW9uIG51bGxhYmxlKGlubmVyVHlwZSkge1xuICByZXR1cm4gbmV3IFpvZE51bGxhYmxlKHtcbiAgICB0eXBlOiBcIm51bGxhYmxlXCIsXG4gICAgaW5uZXJUeXBlXG4gIH0pO1xufVxudmFyIFpvZERlZmF1bHQgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kRGVmYXVsdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2REZWZhdWx0LmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5pbm5lclR5cGU7XG4gIGluc3QucmVtb3ZlRGVmYXVsdCA9IGluc3QudW53cmFwO1xufSk7XG5mdW5jdGlvbiBfZGVmYXVsdChpbm5lclR5cGUsIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gbmV3IFpvZERlZmF1bHQoe1xuICAgIHR5cGU6IFwiZGVmYXVsdFwiLFxuICAgIGlubmVyVHlwZSxcbiAgICBnZXQgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGRlZmF1bHRWYWx1ZSgpIDogZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgfSk7XG59XG52YXIgWm9kUHJlZmF1bHQgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kUHJlZmF1bHRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kUHJlZmF1bHQuaW5pdChpbnN0LCBkZWYpO1xuICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0Ll96b2QuZGVmLmlubmVyVHlwZTtcbn0pO1xuZnVuY3Rpb24gcHJlZmF1bHQoaW5uZXJUeXBlLCBkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBab2RQcmVmYXVsdCh7XG4gICAgdHlwZTogXCJwcmVmYXVsdFwiLFxuICAgIGlubmVyVHlwZSxcbiAgICBnZXQgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGRlZmF1bHRWYWx1ZSgpIDogZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgfSk7XG59XG52YXIgWm9kTm9uT3B0aW9uYWwgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kTm9uT3B0aW9uYWxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kTm9uT3B0aW9uYWwuaW5pdChpbnN0LCBkZWYpO1xuICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0Ll96b2QuZGVmLmlubmVyVHlwZTtcbn0pO1xuZnVuY3Rpb24gbm9ub3B0aW9uYWwoaW5uZXJUeXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIG5ldyBab2ROb25PcHRpb25hbCh7XG4gICAgdHlwZTogXCJub25vcHRpb25hbFwiLFxuICAgIGlubmVyVHlwZSxcbiAgICAuLi51dGlsX2V4cG9ydHMubm9ybWFsaXplUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59XG52YXIgWm9kQ2F0Y2ggPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kQ2F0Y2hcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kQ2F0Y2guaW5pdChpbnN0LCBkZWYpO1xuICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0Ll96b2QuZGVmLmlubmVyVHlwZTtcbiAgaW5zdC5yZW1vdmVDYXRjaCA9IGluc3QudW53cmFwO1xufSk7XG5mdW5jdGlvbiBfY2F0Y2goaW5uZXJUeXBlLCBjYXRjaFZhbHVlKSB7XG4gIHJldHVybiBuZXcgWm9kQ2F0Y2goe1xuICAgIHR5cGU6IFwiY2F0Y2hcIixcbiAgICBpbm5lclR5cGUsXG4gICAgY2F0Y2hWYWx1ZTogdHlwZW9mIGNhdGNoVmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGNhdGNoVmFsdWUgOiAoKSA9PiBjYXRjaFZhbHVlXG4gIH0pO1xufVxudmFyIFpvZFBpcGUgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kUGlwZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RQaXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QuaW4gPSBkZWYuaW47XG4gIGluc3Qub3V0ID0gZGVmLm91dDtcbn0pO1xuZnVuY3Rpb24gcGlwZShpbl8sIG91dCkge1xuICByZXR1cm4gbmV3IFpvZFBpcGUoe1xuICAgIHR5cGU6IFwicGlwZVwiLFxuICAgIGluOiBpbl8sXG4gICAgb3V0XG4gICAgLy8gLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgfSk7XG59XG52YXIgWm9kUmVhZG9ubHkgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kUmVhZG9ubHlcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kUmVhZG9ubHkuaW5pdChpbnN0LCBkZWYpO1xuICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZnVuY3Rpb24gcmVhZG9ubHkoaW5uZXJUeXBlKSB7XG4gIHJldHVybiBuZXcgWm9kUmVhZG9ubHkoe1xuICAgIHR5cGU6IFwicmVhZG9ubHlcIixcbiAgICBpbm5lclR5cGVcbiAgfSk7XG59XG52YXIgWm9kQ3VzdG9tID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZEN1c3RvbVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RDdXN0b20uaW5pdChpbnN0LCBkZWYpO1xuICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZnVuY3Rpb24gY2hlY2soZm4pIHtcbiAgY29uc3QgY2ggPSBuZXcgJFpvZENoZWNrKHtcbiAgICBjaGVjazogXCJjdXN0b21cIlxuICAgIC8vIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gIH0pO1xuICBjaC5fem9kLmNoZWNrID0gZm47XG4gIHJldHVybiBjaDtcbn1cbmZ1bmN0aW9uIHJlZmluZShmbiwgX3BhcmFtcyA9IHt9KSB7XG4gIHJldHVybiBfcmVmaW5lKFpvZEN1c3RvbSwgZm4sIF9wYXJhbXMpO1xufVxuZnVuY3Rpb24gc3VwZXJSZWZpbmUoZm4pIHtcbiAgY29uc3QgY2ggPSBjaGVjaygocGF5bG9hZCkgPT4ge1xuICAgIHBheWxvYWQuYWRkSXNzdWUgPSAoaXNzdWUyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGlzc3VlMiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHV0aWxfZXhwb3J0cy5pc3N1ZShpc3N1ZTIsIHBheWxvYWQudmFsdWUsIGNoLl96b2QuZGVmKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBfaXNzdWUgPSBpc3N1ZTI7XG4gICAgICAgIGlmIChfaXNzdWUuZmF0YWwpXG4gICAgICAgICAgX2lzc3VlLmNvbnRpbnVlID0gZmFsc2U7XG4gICAgICAgIF9pc3N1ZS5jb2RlID8/IChfaXNzdWUuY29kZSA9IFwiY3VzdG9tXCIpO1xuICAgICAgICBfaXNzdWUuaW5wdXQgPz8gKF9pc3N1ZS5pbnB1dCA9IHBheWxvYWQudmFsdWUpO1xuICAgICAgICBfaXNzdWUuaW5zdCA/PyAoX2lzc3VlLmluc3QgPSBjaCk7XG4gICAgICAgIF9pc3N1ZS5jb250aW51ZSA/PyAoX2lzc3VlLmNvbnRpbnVlID0gIWNoLl96b2QuZGVmLmFib3J0KTtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh1dGlsX2V4cG9ydHMuaXNzdWUoX2lzc3VlKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gZm4ocGF5bG9hZC52YWx1ZSwgcGF5bG9hZCk7XG4gIH0pO1xuICByZXR1cm4gY2g7XG59XG5cbi8vIHNyYy9vcGVuYXBpLnRzXG52YXIgcGF0aHMgPSB7fTtcbmZ1bmN0aW9uIGdldFR5cGVGcm9tWm9kVHlwZSh6b2RUeXBlKSB7XG4gIHN3aXRjaCAoem9kVHlwZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgY2FzZSBcIlpvZFN0cmluZ1wiOlxuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgY2FzZSBcIlpvZE51bWJlclwiOlxuICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgY2FzZSBcIlpvZEJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBcImJvb2xlYW5cIjtcbiAgICBjYXNlIFwiWm9kT2JqZWN0XCI6XG4gICAgICByZXR1cm4gXCJvYmplY3RcIjtcbiAgICBjYXNlIFwiWm9kQXJyYXlcIjpcbiAgICAgIHJldHVybiBcImFycmF5XCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9XG59XG5mdW5jdGlvbiBnZXRQYXJhbWV0ZXJzKG9wdGlvbnMpIHtcbiAgY29uc3QgcGFyYW1ldGVycyA9IFtdO1xuICBpZiAob3B0aW9ucy5tZXRhZGF0YT8ub3BlbmFwaT8ucGFyYW1ldGVycykge1xuICAgIHBhcmFtZXRlcnMucHVzaCguLi5vcHRpb25zLm1ldGFkYXRhLm9wZW5hcGkucGFyYW1ldGVycyk7XG4gICAgcmV0dXJuIHBhcmFtZXRlcnM7XG4gIH1cbiAgaWYgKG9wdGlvbnMucXVlcnkgaW5zdGFuY2VvZiBab2RPYmplY3QpIHtcbiAgICBPYmplY3QuZW50cmllcyhvcHRpb25zLnF1ZXJ5LnNoYXBlKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFpvZE9iamVjdCkge1xuICAgICAgICBwYXJhbWV0ZXJzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICBpbjogXCJxdWVyeVwiLFxuICAgICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgdHlwZTogZ2V0VHlwZUZyb21ab2RUeXBlKHZhbHVlKSxcbiAgICAgICAgICAgIC4uLlwibWluTGVuZ3RoXCIgaW4gdmFsdWUgJiYgdmFsdWUubWluTGVuZ3RoID8ge1xuICAgICAgICAgICAgICBtaW5MZW5ndGg6IHZhbHVlLm1pbkxlbmd0aFxuICAgICAgICAgICAgfSA6IHt9LFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHZhbHVlLmRlc2NyaXB0aW9uXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcGFyYW1ldGVycztcbn1cbmZ1bmN0aW9uIGdldFJlcXVlc3RCb2R5KG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMubWV0YWRhdGE/Lm9wZW5hcGk/LnJlcXVlc3RCb2R5KSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubWV0YWRhdGEub3BlbmFwaS5yZXF1ZXN0Qm9keTtcbiAgfVxuICBpZiAoIW9wdGlvbnMuYm9keSkgcmV0dXJuIHZvaWQgMDtcbiAgaWYgKG9wdGlvbnMuYm9keSBpbnN0YW5jZW9mIFpvZE9iamVjdCB8fCBvcHRpb25zLmJvZHkgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgIGNvbnN0IHNoYXBlID0gb3B0aW9ucy5ib2R5LnNoYXBlO1xuICAgIGlmICghc2hhcGUpIHJldHVybiB2b2lkIDA7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IHt9O1xuICAgIGNvbnN0IHJlcXVpcmVkMiA9IFtdO1xuICAgIE9iamVjdC5lbnRyaWVzKHNoYXBlKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFpvZE9iamVjdCkge1xuICAgICAgICBwcm9wZXJ0aWVzW2tleV0gPSB7XG4gICAgICAgICAgdHlwZTogZ2V0VHlwZUZyb21ab2RUeXBlKHZhbHVlKSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogdmFsdWUuZGVzY3JpcHRpb25cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkpIHtcbiAgICAgICAgICByZXF1aXJlZDIucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlcXVpcmVkOiBvcHRpb25zLmJvZHkgaW5zdGFuY2VvZiBab2RPcHRpb25hbCA/IGZhbHNlIDogb3B0aW9ucy5ib2R5ID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgY29udGVudDoge1xuICAgICAgICBcImFwcGxpY2F0aW9uL2pzb25cIjoge1xuICAgICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgICByZXF1aXJlZDogcmVxdWlyZWQyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gZ2V0UmVzcG9uc2UocmVzcG9uc2VzKSB7XG4gIHJldHVybiB7XG4gICAgXCI0MDBcIjoge1xuICAgICAgY29udGVudDoge1xuICAgICAgICBcImFwcGxpY2F0aW9uL2pzb25cIjoge1xuICAgICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiBbXCJtZXNzYWdlXCJdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVzY3JpcHRpb246IFwiQmFkIFJlcXVlc3QuIFVzdWFsbHkgZHVlIHRvIG1pc3NpbmcgcGFyYW1ldGVycywgb3IgaW52YWxpZCBwYXJhbWV0ZXJzLlwiXG4gICAgfSxcbiAgICBcIjQwMVwiOiB7XG4gICAgICBjb250ZW50OiB7XG4gICAgICAgIFwiYXBwbGljYXRpb24vanNvblwiOiB7XG4gICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVxdWlyZWQ6IFtcIm1lc3NhZ2VcIl1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZXNjcmlwdGlvbjogXCJVbmF1dGhvcml6ZWQuIER1ZSB0byBtaXNzaW5nIG9yIGludmFsaWQgYXV0aGVudGljYXRpb24uXCJcbiAgICB9LFxuICAgIFwiNDAzXCI6IHtcbiAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgXCJhcHBsaWNhdGlvbi9qc29uXCI6IHtcbiAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZXNjcmlwdGlvbjogXCJGb3JiaWRkZW4uIFlvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGFjY2VzcyB0aGlzIHJlc291cmNlIG9yIHRvIHBlcmZvcm0gdGhpcyBhY3Rpb24uXCJcbiAgICB9LFxuICAgIFwiNDA0XCI6IHtcbiAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgXCJhcHBsaWNhdGlvbi9qc29uXCI6IHtcbiAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZXNjcmlwdGlvbjogXCJOb3QgRm91bmQuIFRoZSByZXF1ZXN0ZWQgcmVzb3VyY2Ugd2FzIG5vdCBmb3VuZC5cIlxuICAgIH0sXG4gICAgXCI0MjlcIjoge1xuICAgICAgY29udGVudDoge1xuICAgICAgICBcImFwcGxpY2F0aW9uL2pzb25cIjoge1xuICAgICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlRvbyBNYW55IFJlcXVlc3RzLiBZb3UgaGF2ZSBleGNlZWRlZCB0aGUgcmF0ZSBsaW1pdC4gVHJ5IGFnYWluIGxhdGVyLlwiXG4gICAgfSxcbiAgICBcIjUwMFwiOiB7XG4gICAgICBjb250ZW50OiB7XG4gICAgICAgIFwiYXBwbGljYXRpb24vanNvblwiOiB7XG4gICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVzY3JpcHRpb246IFwiSW50ZXJuYWwgU2VydmVyIEVycm9yLiBUaGlzIGlzIGEgcHJvYmxlbSB3aXRoIHRoZSBzZXJ2ZXIgdGhhdCB5b3UgY2Fubm90IGZpeC5cIlxuICAgIH0sXG4gICAgLi4ucmVzcG9uc2VzXG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0b3IoZW5kcG9pbnRzLCBjb25maWcyKSB7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSB7XG4gICAgc2NoZW1hczoge31cbiAgfTtcbiAgT2JqZWN0LmVudHJpZXMoZW5kcG9pbnRzKS5mb3JFYWNoKChbXywgdmFsdWVdKSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHZhbHVlLm9wdGlvbnM7XG4gICAgaWYgKG9wdGlvbnMubWV0YWRhdGE/LlNFUlZFUl9PTkxZKSByZXR1cm47XG4gICAgaWYgKG9wdGlvbnMubWV0aG9kID09PSBcIkdFVFwiKSB7XG4gICAgICBwYXRoc1t2YWx1ZS5wYXRoXSA9IHtcbiAgICAgICAgZ2V0OiB7XG4gICAgICAgICAgdGFnczogW1wiRGVmYXVsdFwiLCAuLi5vcHRpb25zLm1ldGFkYXRhPy5vcGVuYXBpPy50YWdzIHx8IFtdXSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogb3B0aW9ucy5tZXRhZGF0YT8ub3BlbmFwaT8uZGVzY3JpcHRpb24sXG4gICAgICAgICAgb3BlcmF0aW9uSWQ6IG9wdGlvbnMubWV0YWRhdGE/Lm9wZW5hcGk/Lm9wZXJhdGlvbklkLFxuICAgICAgICAgIHNlY3VyaXR5OiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGJlYXJlckF1dGg6IFtdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwYXJhbWV0ZXJzOiBnZXRQYXJhbWV0ZXJzKG9wdGlvbnMpLFxuICAgICAgICAgIHJlc3BvbnNlczogZ2V0UmVzcG9uc2Uob3B0aW9ucy5tZXRhZGF0YT8ub3BlbmFwaT8ucmVzcG9uc2VzKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5tZXRob2QgPT09IFwiUE9TVFwiKSB7XG4gICAgICBjb25zdCBib2R5ID0gZ2V0UmVxdWVzdEJvZHkob3B0aW9ucyk7XG4gICAgICBwYXRoc1t2YWx1ZS5wYXRoXSA9IHtcbiAgICAgICAgcG9zdDoge1xuICAgICAgICAgIHRhZ3M6IFtcIkRlZmF1bHRcIiwgLi4ub3B0aW9ucy5tZXRhZGF0YT8ub3BlbmFwaT8udGFncyB8fCBbXV0sXG4gICAgICAgICAgZGVzY3JpcHRpb246IG9wdGlvbnMubWV0YWRhdGE/Lm9wZW5hcGk/LmRlc2NyaXB0aW9uLFxuICAgICAgICAgIG9wZXJhdGlvbklkOiBvcHRpb25zLm1ldGFkYXRhPy5vcGVuYXBpPy5vcGVyYXRpb25JZCxcbiAgICAgICAgICBzZWN1cml0eTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBiZWFyZXJBdXRoOiBbXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgcGFyYW1ldGVyczogZ2V0UGFyYW1ldGVycyhvcHRpb25zKSxcbiAgICAgICAgICAuLi5ib2R5ID8geyByZXF1ZXN0Qm9keTogYm9keSB9IDoge1xuICAgICAgICAgICAgcmVxdWVzdEJvZHk6IHtcbiAgICAgICAgICAgICAgLy9zZXQgYm9keSBub25lXG4gICAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICBcImFwcGxpY2F0aW9uL2pzb25cIjoge1xuICAgICAgICAgICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNwb25zZXM6IGdldFJlc3BvbnNlKG9wdGlvbnMubWV0YWRhdGE/Lm9wZW5hcGk/LnJlc3BvbnNlcylcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCByZXMgPSB7XG4gICAgb3BlbmFwaTogXCIzLjEuMVwiLFxuICAgIGluZm86IHtcbiAgICAgIHRpdGxlOiBcIkJldHRlciBBdXRoXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJBUEkgUmVmZXJlbmNlIGZvciB5b3VyIEJldHRlciBBdXRoIEluc3RhbmNlXCIsXG4gICAgICB2ZXJzaW9uOiBcIjEuMS4wXCJcbiAgICB9LFxuICAgIGNvbXBvbmVudHMsXG4gICAgc2VjdXJpdHk6IFtcbiAgICAgIHtcbiAgICAgICAgYXBpS2V5Q29va2llOiBbXVxuICAgICAgfVxuICAgIF0sXG4gICAgc2VydmVyczogW1xuICAgICAge1xuICAgICAgICB1cmw6IGNvbmZpZzI/LnVybFxuICAgICAgfVxuICAgIF0sXG4gICAgdGFnczogW1xuICAgICAge1xuICAgICAgICBuYW1lOiBcIkRlZmF1bHRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRGVmYXVsdCBlbmRwb2ludHMgdGhhdCBhcmUgaW5jbHVkZWQgd2l0aCBCZXR0ZXIgQXV0aCBieSBkZWZhdWx0LiBUaGVzZSBlbmRwb2ludHMgYXJlIG5vdCBwYXJ0IG9mIGFueSBwbHVnaW4uXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHBhdGhzXG4gIH07XG4gIHJldHVybiByZXM7XG59XG52YXIgZ2V0SFRNTCA9IChhcGlSZWZlcmVuY2UsIGNvbmZpZzIpID0+IGA8IWRvY3R5cGUgaHRtbD5cbjxodG1sPlxuICA8aGVhZD5cbiAgICA8dGl0bGU+U2NhbGFyIEFQSSBSZWZlcmVuY2U8L3RpdGxlPlxuICAgIDxtZXRhIGNoYXJzZXQ9XCJ1dGYtOFwiIC8+XG4gICAgPG1ldGFcbiAgICAgIG5hbWU9XCJ2aWV3cG9ydFwiXG4gICAgICBjb250ZW50PVwid2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTFcIiAvPlxuICA8L2hlYWQ+XG4gIDxib2R5PlxuICAgIDxzY3JpcHRcbiAgICAgIGlkPVwiYXBpLXJlZmVyZW5jZVwiXG4gICAgICB0eXBlPVwiYXBwbGljYXRpb24vanNvblwiPlxuICAgICR7SlNPTi5zdHJpbmdpZnkoYXBpUmVmZXJlbmNlKX1cbiAgICA8L3NjcmlwdD5cblx0IDxzY3JpcHQ+XG4gICAgICB2YXIgY29uZmlndXJhdGlvbiA9IHtcblx0ICBcdGZhdmljb246ICR7Y29uZmlnMj8ubG9nbyA/IGBkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCwke2VuY29kZVVSSUNvbXBvbmVudChjb25maWcyLmxvZ28pfWAgOiB2b2lkIDB9ICxcblx0ICAgXHR0aGVtZTogJHtjb25maWcyPy50aGVtZSB8fCBcInNhdHVyblwifSxcbiAgICAgICAgbWV0YURhdGE6IHtcblx0XHRcdHRpdGxlOiAke2NvbmZpZzI/LnRpdGxlIHx8IFwiT3BlbiBBUEkgUmVmZXJlbmNlXCJ9LFxuXHRcdFx0ZGVzY3JpcHRpb246ICR7Y29uZmlnMj8uZGVzY3JpcHRpb24gfHwgXCJCZXR0ZXIgQ2FsbCBPcGVuIEFQSVwifSxcblx0XHR9XG4gICAgICB9XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXBpLXJlZmVyZW5jZScpLmRhdGFzZXQuY29uZmlndXJhdGlvbiA9XG4gICAgICAgIEpTT04uc3RyaW5naWZ5KGNvbmZpZ3VyYXRpb24pXG4gICAgPC9zY3JpcHQ+XG5cdCAgPHNjcmlwdCBzcmM9XCJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0BzY2FsYXIvYXBpLXJlZmVyZW5jZVwiPjwvc2NyaXB0PlxuICA8L2JvZHk+XG48L2h0bWw+YDtcblxuLy8gc3JjL3JvdXRlci50c1xudmFyIGNyZWF0ZVJvdXRlciA9IChlbmRwb2ludHMsIGNvbmZpZzIpID0+IHtcbiAgaWYgKCFjb25maWcyPy5vcGVuYXBpPy5kaXNhYmxlZCkge1xuICAgIGNvbnN0IG9wZW5hcGkgPSB7XG4gICAgICBwYXRoOiBcIi9hcGkvcmVmZXJlbmNlXCIsXG4gICAgICAuLi5jb25maWcyPy5vcGVuYXBpXG4gICAgfTtcbiAgICBlbmRwb2ludHNbXCJvcGVuYXBpXCJdID0gY3JlYXRlRW5kcG9pbnQyKFxuICAgICAgb3BlbmFwaS5wYXRoLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCJcbiAgICAgIH0sXG4gICAgICBhc3luYyAoYykgPT4ge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBhd2FpdCBnZW5lcmF0b3IoZW5kcG9pbnRzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShnZXRIVE1MKHNjaGVtYSwgb3BlbmFwaS5zY2FsYXIpLCB7XG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L2h0bWxcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBjb25zdCByb3V0ZXIgPSBjcmVhdGVSb3UzUm91dGVyKCk7XG4gIGNvbnN0IG1pZGRsZXdhcmVSb3V0ZXIgPSBjcmVhdGVSb3UzUm91dGVyKCk7XG4gIGZvciAoY29uc3QgZW5kcG9pbnQgb2YgT2JqZWN0LnZhbHVlcyhlbmRwb2ludHMpKSB7XG4gICAgaWYgKCFlbmRwb2ludC5vcHRpb25zKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGVuZHBvaW50Lm9wdGlvbnM/Lm1ldGFkYXRhPy5TRVJWRVJfT05MWSkgY29udGludWU7XG4gICAgY29uc3QgbWV0aG9kcyA9IEFycmF5LmlzQXJyYXkoZW5kcG9pbnQub3B0aW9ucz8ubWV0aG9kKSA/IGVuZHBvaW50Lm9wdGlvbnMubWV0aG9kIDogW2VuZHBvaW50Lm9wdGlvbnM/Lm1ldGhvZF07XG4gICAgZm9yIChjb25zdCBtZXRob2Qgb2YgbWV0aG9kcykge1xuICAgICAgYWRkUm91dGUocm91dGVyLCBtZXRob2QsIGVuZHBvaW50LnBhdGgsIGVuZHBvaW50KTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbmZpZzI/LnJvdXRlck1pZGRsZXdhcmU/Lmxlbmd0aCkge1xuICAgIGZvciAoY29uc3QgeyBwYXRoLCBtaWRkbGV3YXJlIH0gb2YgY29uZmlnMi5yb3V0ZXJNaWRkbGV3YXJlKSB7XG4gICAgICBhZGRSb3V0ZShtaWRkbGV3YXJlUm91dGVyLCBcIipcIiwgcGF0aCwgbWlkZGxld2FyZSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHByb2Nlc3NSZXF1ZXN0ID0gYXN5bmMgKHJlcXVlc3QpID0+IHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBjb25zdCBwYXRoID0gY29uZmlnMj8uYmFzZVBhdGggPyB1cmwucGF0aG5hbWUuc3BsaXQoY29uZmlnMi5iYXNlUGF0aCkucmVkdWNlKChhY2MsIGN1cnIsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoaW5kZXggIT09IDApIHtcbiAgICAgICAgaWYgKGluZGV4ID4gMSkge1xuICAgICAgICAgIGFjYy5wdXNoKGAke2NvbmZpZzIuYmFzZVBhdGh9JHtjdXJyfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjYy5wdXNoKGN1cnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKS5qb2luKFwiXCIpIDogdXJsLnBhdGhuYW1lO1xuICAgIGlmICghcGF0aD8ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHsgc3RhdHVzOiA0MDQsIHN0YXR1c1RleHQ6IFwiTm90IEZvdW5kXCIgfSk7XG4gICAgfVxuICAgIGNvbnN0IHJvdXRlID0gZmluZFJvdXRlKHJvdXRlciwgcmVxdWVzdC5tZXRob2QsIHBhdGgpO1xuICAgIGlmICghcm91dGU/LmRhdGEpIHtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwgeyBzdGF0dXM6IDQwNCwgc3RhdHVzVGV4dDogXCJOb3QgRm91bmRcIiB9KTtcbiAgICB9XG4gICAgY29uc3QgcXVlcnkgPSB7fTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGlmIChrZXkgaW4gcXVlcnkpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocXVlcnlba2V5XSkpIHtcbiAgICAgICAgICBxdWVyeVtrZXldLnB1c2godmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHF1ZXJ5W2tleV0gPSBbcXVlcnlba2V5XSwgdmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgaGFuZGxlciA9IHJvdXRlLmRhdGE7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIHBhdGgsXG4gICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgICAgcGFyYW1zOiByb3V0ZS5wYXJhbXMgPyBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJvdXRlLnBhcmFtcykpIDoge30sXG4gICAgICByZXF1ZXN0LFxuICAgICAgYm9keTogaGFuZGxlci5vcHRpb25zLmRpc2FibGVCb2R5ID8gdm9pZCAwIDogYXdhaXQgZ2V0Qm9keShoYW5kbGVyLm9wdGlvbnMuY2xvbmVSZXF1ZXN0ID8gcmVxdWVzdC5jbG9uZSgpIDogcmVxdWVzdCksXG4gICAgICBxdWVyeSxcbiAgICAgIF9mbGFnOiBcInJvdXRlclwiLFxuICAgICAgYXNSZXNwb25zZTogdHJ1ZSxcbiAgICAgIGNvbnRleHQ6IGNvbmZpZzI/LnJvdXRlckNvbnRleHRcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtaWRkbGV3YXJlUm91dGVzID0gZmluZEFsbFJvdXRlcyhtaWRkbGV3YXJlUm91dGVyLCBcIipcIiwgcGF0aCk7XG4gICAgICBpZiAobWlkZGxld2FyZVJvdXRlcz8ubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoY29uc3QgeyBkYXRhOiBtaWRkbGV3YXJlLCBwYXJhbXMgfSBvZiBtaWRkbGV3YXJlUm91dGVzKSB7XG4gICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgbWlkZGxld2FyZSh7XG4gICAgICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgYXNSZXNwb25zZTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgUmVzcG9uc2UpIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlcihjb250ZXh0KTtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGNvbmZpZzI/Lm9uRXJyb3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBlcnJvclJlc3BvbnNlID0gYXdhaXQgY29uZmlnMi5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgICBpZiAoZXJyb3JSZXNwb25zZSBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9SZXNwb25zZShlcnJvclJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICAgIGlmIChpc0FQSUVycm9yKGVycm9yMikpIHtcbiAgICAgICAgICAgIHJldHVybiB0b1Jlc3BvbnNlKGVycm9yMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGVycm9yMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZzI/LnRocm93RXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAoaXNBUElFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIHRvUmVzcG9uc2UoZXJyb3IpO1xuICAgICAgfVxuICAgICAgY29uc29sZS5lcnJvcihgIyBTRVJWRVJfRVJST1I6IGAsIGVycm9yKTtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgc3RhdHVzVGV4dDogXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIlxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIGhhbmRsZXI6IGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgICBjb25zdCBvblJlcSA9IGF3YWl0IGNvbmZpZzI/Lm9uUmVxdWVzdD8uKHJlcXVlc3QpO1xuICAgICAgaWYgKG9uUmVxIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIG9uUmVxO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVxID0gb25SZXEgaW5zdGFuY2VvZiBSZXF1ZXN0ID8gb25SZXEgOiByZXF1ZXN0O1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgcHJvY2Vzc1JlcXVlc3QocmVxKTtcbiAgICAgIGNvbnN0IG9uUmVzID0gYXdhaXQgY29uZmlnMj8ub25SZXNwb25zZT8uKHJlcyk7XG4gICAgICBpZiAob25SZXMgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gb25SZXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgZW5kcG9pbnRzXG4gIH07XG59O1xuZXhwb3J0IHtcbiAgQVBJRXJyb3IsXG4gIF9zdGF0dXNDb2RlLFxuICBjcmVhdGVFbmRwb2ludDIgYXMgY3JlYXRlRW5kcG9pbnQsXG4gIGNyZWF0ZUludGVybmFsQ29udGV4dCxcbiAgY3JlYXRlTWlkZGxld2FyZSxcbiAgY3JlYXRlUm91dGVyLFxuICBnZW5lcmF0b3IsXG4gIGdldENvb2tpZUtleSxcbiAgZ2V0SFRNTCxcbiAgaGlkZUludGVybmFsU3RhY2tGcmFtZXMsXG4gIG1ha2VFcnJvckZvckhpZGVTdGFja0ZyYW1lLFxuICBwYXJzZUNvb2tpZXMsXG4gIHNlcmlhbGl6ZUNvb2tpZSxcbiAgc2VyaWFsaXplU2lnbmVkQ29va2llLFxuICB0b1Jlc3BvbnNlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/better-call/dist/index.js\n");

/***/ })

};
;