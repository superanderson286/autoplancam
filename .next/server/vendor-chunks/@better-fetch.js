"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@better-fetch";
exports.ids = ["vendor-chunks/@better-fetch"];
exports.modules = {

/***/ "(ssr)/./node_modules/@better-fetch/fetch/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@better-fetch/fetch/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BetterFetchError: () => (/* binding */ BetterFetchError),\n/* harmony export */   ValidationError: () => (/* binding */ ValidationError),\n/* harmony export */   applySchemaPlugin: () => (/* binding */ applySchemaPlugin),\n/* harmony export */   betterFetch: () => (/* binding */ betterFetch),\n/* harmony export */   bodyParser: () => (/* binding */ bodyParser),\n/* harmony export */   createFetch: () => (/* binding */ createFetch),\n/* harmony export */   createRetryStrategy: () => (/* binding */ createRetryStrategy),\n/* harmony export */   createSchema: () => (/* binding */ createSchema),\n/* harmony export */   detectContentType: () => (/* binding */ detectContentType),\n/* harmony export */   detectResponseType: () => (/* binding */ detectResponseType),\n/* harmony export */   getBody: () => (/* binding */ getBody),\n/* harmony export */   getFetch: () => (/* binding */ getFetch),\n/* harmony export */   getHeaders: () => (/* binding */ getHeaders),\n/* harmony export */   getMethod: () => (/* binding */ getMethod),\n/* harmony export */   getTimeout: () => (/* binding */ getTimeout),\n/* harmony export */   getURL: () => (/* binding */ getURL),\n/* harmony export */   initializePlugins: () => (/* binding */ initializePlugins),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isJSONParsable: () => (/* binding */ isJSONParsable),\n/* harmony export */   isJSONSerializable: () => (/* binding */ isJSONSerializable),\n/* harmony export */   isPayloadMethod: () => (/* binding */ isPayloadMethod),\n/* harmony export */   isRouteMethod: () => (/* binding */ isRouteMethod),\n/* harmony export */   jsonParse: () => (/* binding */ jsonParse),\n/* harmony export */   methods: () => (/* binding */ methods),\n/* harmony export */   parseStandardSchema: () => (/* binding */ parseStandardSchema)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// src/error.ts\nvar BetterFetchError = class extends Error {\n  constructor(status, statusText, error) {\n    super(statusText || status.toString(), {\n      cause: error\n    });\n    this.status = status;\n    this.statusText = statusText;\n    this.error = error;\n  }\n};\n\n// src/plugins.ts\nvar initializePlugins = async (url, options) => {\n  var _a, _b, _c, _d, _e, _f;\n  let opts = options || {};\n  const hooks = {\n    onRequest: [options == null ? void 0 : options.onRequest],\n    onResponse: [options == null ? void 0 : options.onResponse],\n    onSuccess: [options == null ? void 0 : options.onSuccess],\n    onError: [options == null ? void 0 : options.onError],\n    onRetry: [options == null ? void 0 : options.onRetry]\n  };\n  if (!options || !(options == null ? void 0 : options.plugins)) {\n    return {\n      url,\n      options: opts,\n      hooks\n    };\n  }\n  for (const plugin of (options == null ? void 0 : options.plugins) || []) {\n    if (plugin.init) {\n      const pluginRes = await ((_a = plugin.init) == null ? void 0 : _a.call(plugin, url.toString(), options));\n      opts = pluginRes.options || opts;\n      url = pluginRes.url;\n    }\n    hooks.onRequest.push((_b = plugin.hooks) == null ? void 0 : _b.onRequest);\n    hooks.onResponse.push((_c = plugin.hooks) == null ? void 0 : _c.onResponse);\n    hooks.onSuccess.push((_d = plugin.hooks) == null ? void 0 : _d.onSuccess);\n    hooks.onError.push((_e = plugin.hooks) == null ? void 0 : _e.onError);\n    hooks.onRetry.push((_f = plugin.hooks) == null ? void 0 : _f.onRetry);\n  }\n  return {\n    url,\n    options: opts,\n    hooks\n  };\n};\n\n// src/retry.ts\nvar LinearRetryStrategy = class {\n  constructor(options) {\n    this.options = options;\n  }\n  shouldAttemptRetry(attempt, response) {\n    if (this.options.shouldRetry) {\n      return Promise.resolve(\n        attempt < this.options.attempts && this.options.shouldRetry(response)\n      );\n    }\n    return Promise.resolve(attempt < this.options.attempts);\n  }\n  getDelay() {\n    return this.options.delay;\n  }\n};\nvar ExponentialRetryStrategy = class {\n  constructor(options) {\n    this.options = options;\n  }\n  shouldAttemptRetry(attempt, response) {\n    if (this.options.shouldRetry) {\n      return Promise.resolve(\n        attempt < this.options.attempts && this.options.shouldRetry(response)\n      );\n    }\n    return Promise.resolve(attempt < this.options.attempts);\n  }\n  getDelay(attempt) {\n    const delay = Math.min(\n      this.options.maxDelay,\n      this.options.baseDelay * 2 ** attempt\n    );\n    return delay;\n  }\n};\nfunction createRetryStrategy(options) {\n  if (typeof options === \"number\") {\n    return new LinearRetryStrategy({\n      type: \"linear\",\n      attempts: options,\n      delay: 1e3\n    });\n  }\n  switch (options.type) {\n    case \"linear\":\n      return new LinearRetryStrategy(options);\n    case \"exponential\":\n      return new ExponentialRetryStrategy(options);\n    default:\n      throw new Error(\"Invalid retry strategy\");\n  }\n}\n\n// src/auth.ts\nvar getAuthHeader = async (options) => {\n  const headers = {};\n  const getValue = async (value) => typeof value === \"function\" ? await value() : value;\n  if (options == null ? void 0 : options.auth) {\n    if (options.auth.type === \"Bearer\") {\n      const token = await getValue(options.auth.token);\n      if (!token) {\n        return headers;\n      }\n      headers[\"authorization\"] = `Bearer ${token}`;\n    } else if (options.auth.type === \"Basic\") {\n      const username = getValue(options.auth.username);\n      const password = getValue(options.auth.password);\n      if (!username || !password) {\n        return headers;\n      }\n      headers[\"authorization\"] = `Basic ${btoa(`${username}:${password}`)}`;\n    } else if (options.auth.type === \"Custom\") {\n      const value = getValue(options.auth.value);\n      if (!value) {\n        return headers;\n      }\n      headers[\"authorization\"] = `${getValue(options.auth.prefix)} ${value}`;\n    }\n  }\n  return headers;\n};\n\n// src/utils.ts\nvar JSON_RE = /^application\\/(?:[\\w!#$%&*.^`~-]*\\+)?json(;.+)?$/i;\nfunction detectResponseType(request) {\n  const _contentType = request.headers.get(\"content-type\");\n  const textTypes = /* @__PURE__ */ new Set([\n    \"image/svg\",\n    \"application/xml\",\n    \"application/xhtml\",\n    \"application/html\"\n  ]);\n  if (!_contentType) {\n    return \"json\";\n  }\n  const contentType = _contentType.split(\";\").shift() || \"\";\n  if (JSON_RE.test(contentType)) {\n    return \"json\";\n  }\n  if (textTypes.has(contentType) || contentType.startsWith(\"text/\")) {\n    return \"text\";\n  }\n  return \"blob\";\n}\nfunction isJSONParsable(value) {\n  try {\n    JSON.parse(value);\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\nfunction isJSONSerializable(value) {\n  if (value === void 0) {\n    return false;\n  }\n  const t = typeof value;\n  if (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) {\n    return true;\n  }\n  if (t !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return true;\n  }\n  if (value.buffer) {\n    return false;\n  }\n  return value.constructor && value.constructor.name === \"Object\" || typeof value.toJSON === \"function\";\n}\nfunction jsonParse(text) {\n  try {\n    return JSON.parse(text);\n  } catch (error) {\n    return text;\n  }\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction getFetch(options) {\n  if (options == null ? void 0 : options.customFetchImpl) {\n    return options.customFetchImpl;\n  }\n  if (typeof globalThis !== \"undefined\" && isFunction(globalThis.fetch)) {\n    return globalThis.fetch;\n  }\n  if (typeof window !== \"undefined\" && isFunction(window.fetch)) {\n    return window.fetch;\n  }\n  throw new Error(\"No fetch implementation found\");\n}\nfunction isPayloadMethod(method) {\n  if (!method) {\n    return false;\n  }\n  const payloadMethod = [\"POST\", \"PUT\", \"PATCH\", \"DELETE\"];\n  return payloadMethod.includes(method.toUpperCase());\n}\nfunction isRouteMethod(method) {\n  const routeMethod = [\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"];\n  if (!method) {\n    return false;\n  }\n  return routeMethod.includes(method.toUpperCase());\n}\nasync function getHeaders(opts) {\n  const headers = new Headers(opts == null ? void 0 : opts.headers);\n  const authHeader = await getAuthHeader(opts);\n  for (const [key, value] of Object.entries(authHeader || {})) {\n    headers.set(key, value);\n  }\n  if (!headers.has(\"content-type\")) {\n    const t = detectContentType(opts == null ? void 0 : opts.body);\n    if (t) {\n      headers.set(\"content-type\", t);\n    }\n  }\n  return headers;\n}\nfunction getURL(url, options) {\n  if (url.startsWith(\"@\")) {\n    const m = url.toString().split(\"@\")[1].split(\"/\")[0];\n    if (methods.includes(m)) {\n      url = url.replace(`@${m}/`, \"/\");\n    }\n  }\n  let _url;\n  try {\n    if (url.startsWith(\"http\")) {\n      _url = url;\n    } else {\n      let baseURL = options == null ? void 0 : options.baseURL;\n      if (baseURL && !(baseURL == null ? void 0 : baseURL.endsWith(\"/\"))) {\n        baseURL = baseURL + \"/\";\n      }\n      if (url.startsWith(\"/\")) {\n        _url = new URL(url.substring(1), baseURL);\n      } else {\n        _url = new URL(url, options == null ? void 0 : options.baseURL);\n      }\n    }\n  } catch (e) {\n    if (e instanceof TypeError) {\n      if (!(options == null ? void 0 : options.baseURL)) {\n        throw TypeError(\n          `Invalid URL ${url}. Are you passing in a relative url but not setting the baseURL?`\n        );\n      }\n      throw TypeError(\n        `Invalid URL ${url}. Please validate that you are passing the correct input.`\n      );\n    }\n    throw e;\n  }\n  if (options == null ? void 0 : options.params) {\n    if (Array.isArray(options == null ? void 0 : options.params)) {\n      const params = (options == null ? void 0 : options.params) ? Array.isArray(options.params) ? `/${options.params.join(\"/\")}` : `/${Object.values(options.params).join(\"/\")}` : \"\";\n      _url = _url.toString().split(\"/:\")[0];\n      _url = `${_url.toString()}${params}`;\n    } else {\n      for (const [key, value] of Object.entries(options == null ? void 0 : options.params)) {\n        _url = _url.toString().replace(`:${key}`, String(value));\n      }\n    }\n  }\n  const __url = new URL(_url);\n  const queryParams = options == null ? void 0 : options.query;\n  if (queryParams) {\n    for (const [key, value] of Object.entries(queryParams)) {\n      __url.searchParams.append(key, String(value));\n    }\n  }\n  return __url;\n}\nfunction detectContentType(body) {\n  if (isJSONSerializable(body)) {\n    return \"application/json\";\n  }\n  return null;\n}\nfunction getBody(options) {\n  if (!(options == null ? void 0 : options.body)) {\n    return null;\n  }\n  const headers = new Headers(options == null ? void 0 : options.headers);\n  if (isJSONSerializable(options.body) && !headers.has(\"content-type\")) {\n    for (const [key, value] of Object.entries(options == null ? void 0 : options.body)) {\n      if (value instanceof Date) {\n        options.body[key] = value.toISOString();\n      }\n    }\n    return JSON.stringify(options.body);\n  }\n  return options.body;\n}\nfunction getMethod(url, options) {\n  var _a;\n  if (options == null ? void 0 : options.method) {\n    return options.method.toUpperCase();\n  }\n  if (url.startsWith(\"@\")) {\n    const pMethod = (_a = url.split(\"@\")[1]) == null ? void 0 : _a.split(\"/\")[0];\n    if (!methods.includes(pMethod)) {\n      return (options == null ? void 0 : options.body) ? \"POST\" : \"GET\";\n    }\n    return pMethod.toUpperCase();\n  }\n  return (options == null ? void 0 : options.body) ? \"POST\" : \"GET\";\n}\nfunction getTimeout(options, controller) {\n  let abortTimeout;\n  if (!(options == null ? void 0 : options.signal) && (options == null ? void 0 : options.timeout)) {\n    abortTimeout = setTimeout(() => controller == null ? void 0 : controller.abort(), options == null ? void 0 : options.timeout);\n  }\n  return {\n    abortTimeout,\n    clearTimeout: () => {\n      if (abortTimeout) {\n        clearTimeout(abortTimeout);\n      }\n    }\n  };\n}\nfunction bodyParser(data, responseType) {\n  if (responseType === \"json\") {\n    return JSON.parse(data);\n  }\n  return data;\n}\nvar ValidationError = class _ValidationError extends Error {\n  constructor(issues, message) {\n    super(message || JSON.stringify(issues, null, 2));\n    this.issues = issues;\n    Object.setPrototypeOf(this, _ValidationError.prototype);\n  }\n};\nasync function parseStandardSchema(schema, input) {\n  let result = await schema[\"~standard\"].validate(input);\n  if (result.issues) {\n    throw new ValidationError(result.issues);\n  }\n  return result.value;\n}\n\n// src/create-fetch/schema.ts\nvar methods = [\"get\", \"post\", \"put\", \"patch\", \"delete\"];\nvar createSchema = (schema, config) => {\n  return {\n    schema,\n    config\n  };\n};\n\n// src/create-fetch/index.ts\nvar applySchemaPlugin = (config) => ({\n  id: \"apply-schema\",\n  name: \"Apply Schema\",\n  version: \"1.0.0\",\n  async init(url, options) {\n    var _a, _b, _c, _d;\n    const schema = ((_b = (_a = config.plugins) == null ? void 0 : _a.find(\n      (plugin) => {\n        var _a2;\n        return ((_a2 = plugin.schema) == null ? void 0 : _a2.config) ? url.startsWith(plugin.schema.config.baseURL || \"\") || url.startsWith(plugin.schema.config.prefix || \"\") : false;\n      }\n    )) == null ? void 0 : _b.schema) || config.schema;\n    if (schema) {\n      let urlKey = url;\n      if ((_c = schema.config) == null ? void 0 : _c.prefix) {\n        if (urlKey.startsWith(schema.config.prefix)) {\n          urlKey = urlKey.replace(schema.config.prefix, \"\");\n          if (schema.config.baseURL) {\n            url = url.replace(schema.config.prefix, schema.config.baseURL);\n          }\n        }\n      }\n      if ((_d = schema.config) == null ? void 0 : _d.baseURL) {\n        if (urlKey.startsWith(schema.config.baseURL)) {\n          urlKey = urlKey.replace(schema.config.baseURL, \"\");\n        }\n      }\n      const keySchema = schema.schema[urlKey];\n      if (keySchema) {\n        let opts = __spreadProps(__spreadValues({}, options), {\n          method: keySchema.method,\n          output: keySchema.output\n        });\n        if (!(options == null ? void 0 : options.disableValidation)) {\n          opts = __spreadProps(__spreadValues({}, opts), {\n            body: keySchema.input ? await parseStandardSchema(keySchema.input, options == null ? void 0 : options.body) : options == null ? void 0 : options.body,\n            params: keySchema.params ? await parseStandardSchema(keySchema.params, options == null ? void 0 : options.params) : options == null ? void 0 : options.params,\n            query: keySchema.query ? await parseStandardSchema(keySchema.query, options == null ? void 0 : options.query) : options == null ? void 0 : options.query\n          });\n        }\n        return {\n          url,\n          options: opts\n        };\n      }\n    }\n    return {\n      url,\n      options\n    };\n  }\n});\nvar createFetch = (config) => {\n  async function $fetch(url, options) {\n    const opts = __spreadProps(__spreadValues(__spreadValues({}, config), options), {\n      plugins: [...(config == null ? void 0 : config.plugins) || [], applySchemaPlugin(config || {})]\n    });\n    if (config == null ? void 0 : config.catchAllError) {\n      try {\n        return await betterFetch(url, opts);\n      } catch (error) {\n        return {\n          data: null,\n          error: {\n            status: 500,\n            statusText: \"Fetch Error\",\n            message: \"Fetch related error. Captured by catchAllError option. See error property for more details.\",\n            error\n          }\n        };\n      }\n    }\n    return await betterFetch(url, opts);\n  }\n  return $fetch;\n};\n\n// src/url.ts\nfunction getURL2(url, option) {\n  let { baseURL, params, query } = option || {\n    query: {},\n    params: {},\n    baseURL: \"\"\n  };\n  let basePath = url.startsWith(\"http\") ? url.split(\"/\").slice(0, 3).join(\"/\") : baseURL || \"\";\n  if (url.startsWith(\"@\")) {\n    const m = url.toString().split(\"@\")[1].split(\"/\")[0];\n    if (methods.includes(m)) {\n      url = url.replace(`@${m}/`, \"/\");\n    }\n  }\n  if (!basePath.endsWith(\"/\")) basePath += \"/\";\n  let [path, urlQuery] = url.replace(basePath, \"\").split(\"?\");\n  const queryParams = new URLSearchParams(urlQuery);\n  for (const [key, value] of Object.entries(query || {})) {\n    if (value == null) continue;\n    queryParams.set(key, String(value));\n  }\n  if (params) {\n    if (Array.isArray(params)) {\n      const paramPaths = path.split(\"/\").filter((p) => p.startsWith(\":\"));\n      for (const [index, key] of paramPaths.entries()) {\n        const value = params[index];\n        path = path.replace(key, value);\n      }\n    } else {\n      for (const [key, value] of Object.entries(params)) {\n        path = path.replace(`:${key}`, String(value));\n      }\n    }\n  }\n  path = path.split(\"/\").map(encodeURIComponent).join(\"/\");\n  if (path.startsWith(\"/\")) path = path.slice(1);\n  let queryParamString = queryParams.toString();\n  queryParamString = queryParamString.length > 0 ? `?${queryParamString}`.replace(/\\+/g, \"%20\") : \"\";\n  if (!basePath.startsWith(\"http\")) {\n    return `${basePath}${path}${queryParamString}`;\n  }\n  const _url = new URL(`${path}${queryParamString}`, basePath);\n  return _url;\n}\n\n// src/fetch.ts\nvar betterFetch = async (url, options) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h;\n  const {\n    hooks,\n    url: __url,\n    options: opts\n  } = await initializePlugins(url, options);\n  const fetch = getFetch(opts);\n  const controller = new AbortController();\n  const signal = (_a = opts.signal) != null ? _a : controller.signal;\n  const _url = getURL2(__url, opts);\n  const body = getBody(opts);\n  const headers = await getHeaders(opts);\n  const method = getMethod(__url, opts);\n  let context = __spreadProps(__spreadValues({}, opts), {\n    url: _url,\n    headers,\n    body,\n    method,\n    signal\n  });\n  for (const onRequest of hooks.onRequest) {\n    if (onRequest) {\n      const res = await onRequest(context);\n      if (res instanceof Object) {\n        context = res;\n      }\n    }\n  }\n  if (\"pipeTo\" in context && typeof context.pipeTo === \"function\" || typeof ((_b = options == null ? void 0 : options.body) == null ? void 0 : _b.pipe) === \"function\") {\n    if (!(\"duplex\" in context)) {\n      context.duplex = \"half\";\n    }\n  }\n  const { clearTimeout: clearTimeout2 } = getTimeout(opts, controller);\n  let response = await fetch(context.url, context);\n  clearTimeout2();\n  const responseContext = {\n    response,\n    request: context\n  };\n  for (const onResponse of hooks.onResponse) {\n    if (onResponse) {\n      const r = await onResponse(__spreadProps(__spreadValues({}, responseContext), {\n        response: ((_c = options == null ? void 0 : options.hookOptions) == null ? void 0 : _c.cloneResponse) ? response.clone() : response\n      }));\n      if (r instanceof Response) {\n        response = r;\n      } else if (r instanceof Object) {\n        response = r.response;\n      }\n    }\n  }\n  if (response.ok) {\n    const hasBody = context.method !== \"HEAD\";\n    if (!hasBody) {\n      return {\n        data: \"\",\n        error: null\n      };\n    }\n    const responseType = detectResponseType(response);\n    const successContext = {\n      data: \"\",\n      response,\n      request: context\n    };\n    if (responseType === \"json\" || responseType === \"text\") {\n      const text = await response.text();\n      const parser2 = (_d = context.jsonParser) != null ? _d : jsonParse;\n      const data = await parser2(text);\n      successContext.data = data;\n    } else {\n      successContext.data = await response[responseType]();\n    }\n    if (context == null ? void 0 : context.output) {\n      if (context.output && !context.disableValidation) {\n        successContext.data = await parseStandardSchema(\n          context.output,\n          successContext.data\n        );\n      }\n    }\n    for (const onSuccess of hooks.onSuccess) {\n      if (onSuccess) {\n        await onSuccess(__spreadProps(__spreadValues({}, successContext), {\n          response: ((_e = options == null ? void 0 : options.hookOptions) == null ? void 0 : _e.cloneResponse) ? response.clone() : response\n        }));\n      }\n    }\n    if (options == null ? void 0 : options.throw) {\n      return successContext.data;\n    }\n    return {\n      data: successContext.data,\n      error: null\n    };\n  }\n  const parser = (_f = options == null ? void 0 : options.jsonParser) != null ? _f : jsonParse;\n  const responseText = await response.text();\n  const isJSONResponse = isJSONParsable(responseText);\n  const errorObject = isJSONResponse ? await parser(responseText) : null;\n  const errorContext = {\n    response,\n    responseText,\n    request: context,\n    error: __spreadProps(__spreadValues({}, errorObject), {\n      status: response.status,\n      statusText: response.statusText\n    })\n  };\n  for (const onError of hooks.onError) {\n    if (onError) {\n      await onError(__spreadProps(__spreadValues({}, errorContext), {\n        response: ((_g = options == null ? void 0 : options.hookOptions) == null ? void 0 : _g.cloneResponse) ? response.clone() : response\n      }));\n    }\n  }\n  if (options == null ? void 0 : options.retry) {\n    const retryStrategy = createRetryStrategy(options.retry);\n    const _retryAttempt = (_h = options.retryAttempt) != null ? _h : 0;\n    if (await retryStrategy.shouldAttemptRetry(_retryAttempt, response)) {\n      for (const onRetry of hooks.onRetry) {\n        if (onRetry) {\n          await onRetry(responseContext);\n        }\n      }\n      const delay = retryStrategy.getDelay(_retryAttempt);\n      await new Promise((resolve) => setTimeout(resolve, delay));\n      return await betterFetch(url, __spreadProps(__spreadValues({}, options), {\n        retryAttempt: _retryAttempt + 1\n      }));\n    }\n  }\n  if (options == null ? void 0 : options.throw) {\n    throw new BetterFetchError(\n      response.status,\n      response.statusText,\n      isJSONResponse ? errorObject : responseText\n    );\n  }\n  return {\n    data: null,\n    error: __spreadProps(__spreadValues({}, errorObject), {\n      status: response.status,\n      statusText: response.statusText\n    })\n  };\n};\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJldHRlci1mZXRjaC9mZXRjaC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTTtBQUNqRCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRLFNBQVMsR0FBRyxTQUFTLEdBQUc7QUFDMUUs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UztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQTJCRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXV0b3BsYW5jYW0vLi9ub2RlX21vZHVsZXMvQGJldHRlci1mZXRjaC9mZXRjaC9kaXN0L2luZGV4LmpzPzU5YjYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG5cbi8vIHNyYy9lcnJvci50c1xudmFyIEJldHRlckZldGNoRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc3RhdHVzLCBzdGF0dXNUZXh0LCBlcnJvcikge1xuICAgIHN1cGVyKHN0YXR1c1RleHQgfHwgc3RhdHVzLnRvU3RyaW5nKCksIHtcbiAgICAgIGNhdXNlOiBlcnJvclxuICAgIH0pO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQ7XG4gICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICB9XG59O1xuXG4vLyBzcmMvcGx1Z2lucy50c1xudmFyIGluaXRpYWxpemVQbHVnaW5zID0gYXN5bmMgKHVybCwgb3B0aW9ucykgPT4ge1xuICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgbGV0IG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBob29rcyA9IHtcbiAgICBvblJlcXVlc3Q6IFtvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm9uUmVxdWVzdF0sXG4gICAgb25SZXNwb25zZTogW29wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMub25SZXNwb25zZV0sXG4gICAgb25TdWNjZXNzOiBbb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5vblN1Y2Nlc3NdLFxuICAgIG9uRXJyb3I6IFtvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm9uRXJyb3JdLFxuICAgIG9uUmV0cnk6IFtvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm9uUmV0cnldXG4gIH07XG4gIGlmICghb3B0aW9ucyB8fCAhKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucGx1Z2lucykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXJsLFxuICAgICAgb3B0aW9uczogb3B0cyxcbiAgICAgIGhvb2tzXG4gICAgfTtcbiAgfVxuICBmb3IgKGNvbnN0IHBsdWdpbiBvZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wbHVnaW5zKSB8fCBbXSkge1xuICAgIGlmIChwbHVnaW4uaW5pdCkge1xuICAgICAgY29uc3QgcGx1Z2luUmVzID0gYXdhaXQgKChfYSA9IHBsdWdpbi5pbml0KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChwbHVnaW4sIHVybC50b1N0cmluZygpLCBvcHRpb25zKSk7XG4gICAgICBvcHRzID0gcGx1Z2luUmVzLm9wdGlvbnMgfHwgb3B0cztcbiAgICAgIHVybCA9IHBsdWdpblJlcy51cmw7XG4gICAgfVxuICAgIGhvb2tzLm9uUmVxdWVzdC5wdXNoKChfYiA9IHBsdWdpbi5ob29rcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm9uUmVxdWVzdCk7XG4gICAgaG9va3Mub25SZXNwb25zZS5wdXNoKChfYyA9IHBsdWdpbi5ob29rcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLm9uUmVzcG9uc2UpO1xuICAgIGhvb2tzLm9uU3VjY2Vzcy5wdXNoKChfZCA9IHBsdWdpbi5ob29rcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLm9uU3VjY2Vzcyk7XG4gICAgaG9va3Mub25FcnJvci5wdXNoKChfZSA9IHBsdWdpbi5ob29rcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLm9uRXJyb3IpO1xuICAgIGhvb2tzLm9uUmV0cnkucHVzaCgoX2YgPSBwbHVnaW4uaG9va3MpID09IG51bGwgPyB2b2lkIDAgOiBfZi5vblJldHJ5KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHVybCxcbiAgICBvcHRpb25zOiBvcHRzLFxuICAgIGhvb2tzXG4gIH07XG59O1xuXG4vLyBzcmMvcmV0cnkudHNcbnZhciBMaW5lYXJSZXRyeVN0cmF0ZWd5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBzaG91bGRBdHRlbXB0UmV0cnkoYXR0ZW1wdCwgcmVzcG9uc2UpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNob3VsZFJldHJ5KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICBhdHRlbXB0IDwgdGhpcy5vcHRpb25zLmF0dGVtcHRzICYmIHRoaXMub3B0aW9ucy5zaG91bGRSZXRyeShyZXNwb25zZSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYXR0ZW1wdCA8IHRoaXMub3B0aW9ucy5hdHRlbXB0cyk7XG4gIH1cbiAgZ2V0RGVsYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5kZWxheTtcbiAgfVxufTtcbnZhciBFeHBvbmVudGlhbFJldHJ5U3RyYXRlZ3kgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIHNob3VsZEF0dGVtcHRSZXRyeShhdHRlbXB0LCByZXNwb25zZSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvdWxkUmV0cnkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgIGF0dGVtcHQgPCB0aGlzLm9wdGlvbnMuYXR0ZW1wdHMgJiYgdGhpcy5vcHRpb25zLnNob3VsZFJldHJ5KHJlc3BvbnNlKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhdHRlbXB0IDwgdGhpcy5vcHRpb25zLmF0dGVtcHRzKTtcbiAgfVxuICBnZXREZWxheShhdHRlbXB0KSB7XG4gICAgY29uc3QgZGVsYXkgPSBNYXRoLm1pbihcbiAgICAgIHRoaXMub3B0aW9ucy5tYXhEZWxheSxcbiAgICAgIHRoaXMub3B0aW9ucy5iYXNlRGVsYXkgKiAyICoqIGF0dGVtcHRcbiAgICApO1xuICAgIHJldHVybiBkZWxheTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVJldHJ5U3RyYXRlZ3kob3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gbmV3IExpbmVhclJldHJ5U3RyYXRlZ3koe1xuICAgICAgdHlwZTogXCJsaW5lYXJcIixcbiAgICAgIGF0dGVtcHRzOiBvcHRpb25zLFxuICAgICAgZGVsYXk6IDFlM1xuICAgIH0pO1xuICB9XG4gIHN3aXRjaCAob3B0aW9ucy50eXBlKSB7XG4gICAgY2FzZSBcImxpbmVhclwiOlxuICAgICAgcmV0dXJuIG5ldyBMaW5lYXJSZXRyeVN0cmF0ZWd5KG9wdGlvbnMpO1xuICAgIGNhc2UgXCJleHBvbmVudGlhbFwiOlxuICAgICAgcmV0dXJuIG5ldyBFeHBvbmVudGlhbFJldHJ5U3RyYXRlZ3kob3B0aW9ucyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmV0cnkgc3RyYXRlZ3lcIik7XG4gIH1cbn1cblxuLy8gc3JjL2F1dGgudHNcbnZhciBnZXRBdXRoSGVhZGVyID0gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICBjb25zdCBnZXRWYWx1ZSA9IGFzeW5jICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBhd2FpdCB2YWx1ZSgpIDogdmFsdWU7XG4gIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmF1dGgpIHtcbiAgICBpZiAob3B0aW9ucy5hdXRoLnR5cGUgPT09IFwiQmVhcmVyXCIpIHtcbiAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgZ2V0VmFsdWUob3B0aW9ucy5hdXRoLnRva2VuKTtcbiAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgICB9XG4gICAgICBoZWFkZXJzW1wiYXV0aG9yaXphdGlvblwiXSA9IGBCZWFyZXIgJHt0b2tlbn1gO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5hdXRoLnR5cGUgPT09IFwiQmFzaWNcIikge1xuICAgICAgY29uc3QgdXNlcm5hbWUgPSBnZXRWYWx1ZShvcHRpb25zLmF1dGgudXNlcm5hbWUpO1xuICAgICAgY29uc3QgcGFzc3dvcmQgPSBnZXRWYWx1ZShvcHRpb25zLmF1dGgucGFzc3dvcmQpO1xuICAgICAgaWYgKCF1c2VybmFtZSB8fCAhcGFzc3dvcmQpIHtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgICB9XG4gICAgICBoZWFkZXJzW1wiYXV0aG9yaXphdGlvblwiXSA9IGBCYXNpYyAke2J0b2EoYCR7dXNlcm5hbWV9OiR7cGFzc3dvcmR9YCl9YDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYXV0aC50eXBlID09PSBcIkN1c3RvbVwiKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGdldFZhbHVlKG9wdGlvbnMuYXV0aC52YWx1ZSk7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgICAgfVxuICAgICAgaGVhZGVyc1tcImF1dGhvcml6YXRpb25cIl0gPSBgJHtnZXRWYWx1ZShvcHRpb25zLmF1dGgucHJlZml4KX0gJHt2YWx1ZX1gO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGVhZGVycztcbn07XG5cbi8vIHNyYy91dGlscy50c1xudmFyIEpTT05fUkUgPSAvXmFwcGxpY2F0aW9uXFwvKD86W1xcdyEjJCUmKi5eYH4tXSpcXCspP2pzb24oOy4rKT8kL2k7XG5mdW5jdGlvbiBkZXRlY3RSZXNwb25zZVR5cGUocmVxdWVzdCkge1xuICBjb25zdCBfY29udGVudFR5cGUgPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xuICBjb25zdCB0ZXh0VHlwZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gICAgXCJpbWFnZS9zdmdcIixcbiAgICBcImFwcGxpY2F0aW9uL3htbFwiLFxuICAgIFwiYXBwbGljYXRpb24veGh0bWxcIixcbiAgICBcImFwcGxpY2F0aW9uL2h0bWxcIlxuICBdKTtcbiAgaWYgKCFfY29udGVudFR5cGUpIHtcbiAgICByZXR1cm4gXCJqc29uXCI7XG4gIH1cbiAgY29uc3QgY29udGVudFR5cGUgPSBfY29udGVudFR5cGUuc3BsaXQoXCI7XCIpLnNoaWZ0KCkgfHwgXCJcIjtcbiAgaWYgKEpTT05fUkUudGVzdChjb250ZW50VHlwZSkpIHtcbiAgICByZXR1cm4gXCJqc29uXCI7XG4gIH1cbiAgaWYgKHRleHRUeXBlcy5oYXMoY29udGVudFR5cGUpIHx8IGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoXCJ0ZXh0L1wiKSkge1xuICAgIHJldHVybiBcInRleHRcIjtcbiAgfVxuICByZXR1cm4gXCJibG9iXCI7XG59XG5mdW5jdGlvbiBpc0pTT05QYXJzYWJsZSh2YWx1ZSkge1xuICB0cnkge1xuICAgIEpTT04ucGFyc2UodmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gaXNKU09OU2VyaWFsaXphYmxlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHQgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0ID09PSBcInN0cmluZ1wiIHx8IHQgPT09IFwibnVtYmVyXCIgfHwgdCA9PT0gXCJib29sZWFuXCIgfHwgdCA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZS5idWZmZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiT2JqZWN0XCIgfHwgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24ganNvblBhcnNlKHRleHQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxufVxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBnZXRGZXRjaChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmN1c3RvbUZldGNoSW1wbCkge1xuICAgIHJldHVybiBvcHRpb25zLmN1c3RvbUZldGNoSW1wbDtcbiAgfVxuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgJiYgaXNGdW5jdGlvbihnbG9iYWxUaGlzLmZldGNoKSkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLmZldGNoO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIGlzRnVuY3Rpb24od2luZG93LmZldGNoKSkge1xuICAgIHJldHVybiB3aW5kb3cuZmV0Y2g7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZmV0Y2ggaW1wbGVtZW50YXRpb24gZm91bmRcIik7XG59XG5mdW5jdGlvbiBpc1BheWxvYWRNZXRob2QobWV0aG9kKSB7XG4gIGlmICghbWV0aG9kKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHBheWxvYWRNZXRob2QgPSBbXCJQT1NUXCIsIFwiUFVUXCIsIFwiUEFUQ0hcIiwgXCJERUxFVEVcIl07XG4gIHJldHVybiBwYXlsb2FkTWV0aG9kLmluY2x1ZGVzKG1ldGhvZC50b1VwcGVyQ2FzZSgpKTtcbn1cbmZ1bmN0aW9uIGlzUm91dGVNZXRob2QobWV0aG9kKSB7XG4gIGNvbnN0IHJvdXRlTWV0aG9kID0gW1wiR0VUXCIsIFwiUE9TVFwiLCBcIlBVVFwiLCBcIlBBVENIXCIsIFwiREVMRVRFXCJdO1xuICBpZiAoIW1ldGhvZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gcm91dGVNZXRob2QuaW5jbHVkZXMobWV0aG9kLnRvVXBwZXJDYXNlKCkpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0SGVhZGVycyhvcHRzKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmhlYWRlcnMpO1xuICBjb25zdCBhdXRoSGVhZGVyID0gYXdhaXQgZ2V0QXV0aEhlYWRlcihvcHRzKTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXV0aEhlYWRlciB8fCB7fSkpIHtcbiAgICBoZWFkZXJzLnNldChrZXksIHZhbHVlKTtcbiAgfVxuICBpZiAoIWhlYWRlcnMuaGFzKFwiY29udGVudC10eXBlXCIpKSB7XG4gICAgY29uc3QgdCA9IGRldGVjdENvbnRlbnRUeXBlKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuYm9keSk7XG4gICAgaWYgKHQpIHtcbiAgICAgIGhlYWRlcnMuc2V0KFwiY29udGVudC10eXBlXCIsIHQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGVhZGVycztcbn1cbmZ1bmN0aW9uIGdldFVSTCh1cmwsIG9wdGlvbnMpIHtcbiAgaWYgKHVybC5zdGFydHNXaXRoKFwiQFwiKSkge1xuICAgIGNvbnN0IG0gPSB1cmwudG9TdHJpbmcoKS5zcGxpdChcIkBcIilbMV0uc3BsaXQoXCIvXCIpWzBdO1xuICAgIGlmIChtZXRob2RzLmluY2x1ZGVzKG0pKSB7XG4gICAgICB1cmwgPSB1cmwucmVwbGFjZShgQCR7bX0vYCwgXCIvXCIpO1xuICAgIH1cbiAgfVxuICBsZXQgX3VybDtcbiAgdHJ5IHtcbiAgICBpZiAodXJsLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgICBfdXJsID0gdXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgYmFzZVVSTCA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuYmFzZVVSTDtcbiAgICAgIGlmIChiYXNlVVJMICYmICEoYmFzZVVSTCA9PSBudWxsID8gdm9pZCAwIDogYmFzZVVSTC5lbmRzV2l0aChcIi9cIikpKSB7XG4gICAgICAgIGJhc2VVUkwgPSBiYXNlVVJMICsgXCIvXCI7XG4gICAgICB9XG4gICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgIF91cmwgPSBuZXcgVVJMKHVybC5zdWJzdHJpbmcoMSksIGJhc2VVUkwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3VybCA9IG5ldyBVUkwodXJsLCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmJhc2VVUkwpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICBpZiAoIShvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmJhc2VVUkwpKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcbiAgICAgICAgICBgSW52YWxpZCBVUkwgJHt1cmx9LiBBcmUgeW91IHBhc3NpbmcgaW4gYSByZWxhdGl2ZSB1cmwgYnV0IG5vdCBzZXR0aW5nIHRoZSBiYXNlVVJMP2BcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRocm93IFR5cGVFcnJvcihcbiAgICAgICAgYEludmFsaWQgVVJMICR7dXJsfS4gUGxlYXNlIHZhbGlkYXRlIHRoYXQgeW91IGFyZSBwYXNzaW5nIHRoZSBjb3JyZWN0IGlucHV0LmBcbiAgICAgICk7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyYW1zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wYXJhbXMpKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wYXJhbXMpID8gQXJyYXkuaXNBcnJheShvcHRpb25zLnBhcmFtcykgPyBgLyR7b3B0aW9ucy5wYXJhbXMuam9pbihcIi9cIil9YCA6IGAvJHtPYmplY3QudmFsdWVzKG9wdGlvbnMucGFyYW1zKS5qb2luKFwiL1wiKX1gIDogXCJcIjtcbiAgICAgIF91cmwgPSBfdXJsLnRvU3RyaW5nKCkuc3BsaXQoXCIvOlwiKVswXTtcbiAgICAgIF91cmwgPSBgJHtfdXJsLnRvU3RyaW5nKCl9JHtwYXJhbXN9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wYXJhbXMpKSB7XG4gICAgICAgIF91cmwgPSBfdXJsLnRvU3RyaW5nKCkucmVwbGFjZShgOiR7a2V5fWAsIFN0cmluZyh2YWx1ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBfX3VybCA9IG5ldyBVUkwoX3VybCk7XG4gIGNvbnN0IHF1ZXJ5UGFyYW1zID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5xdWVyeTtcbiAgaWYgKHF1ZXJ5UGFyYW1zKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocXVlcnlQYXJhbXMpKSB7XG4gICAgICBfX3VybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgU3RyaW5nKHZhbHVlKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBfX3VybDtcbn1cbmZ1bmN0aW9uIGRldGVjdENvbnRlbnRUeXBlKGJvZHkpIHtcbiAgaWYgKGlzSlNPTlNlcmlhbGl6YWJsZShib2R5KSkge1xuICAgIHJldHVybiBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldEJvZHkob3B0aW9ucykge1xuICBpZiAoIShvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmJvZHkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycyk7XG4gIGlmIChpc0pTT05TZXJpYWxpemFibGUob3B0aW9ucy5ib2R5KSAmJiAhaGVhZGVycy5oYXMoXCJjb250ZW50LXR5cGVcIikpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmJvZHkpKSB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIG9wdGlvbnMuYm9keVtrZXldID0gdmFsdWUudG9JU09TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuYm9keSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnMuYm9keTtcbn1cbmZ1bmN0aW9uIGdldE1ldGhvZCh1cmwsIG9wdGlvbnMpIHtcbiAgdmFyIF9hO1xuICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5tZXRob2QpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5tZXRob2QudG9VcHBlckNhc2UoKTtcbiAgfVxuICBpZiAodXJsLnN0YXJ0c1dpdGgoXCJAXCIpKSB7XG4gICAgY29uc3QgcE1ldGhvZCA9IChfYSA9IHVybC5zcGxpdChcIkBcIilbMV0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5zcGxpdChcIi9cIilbMF07XG4gICAgaWYgKCFtZXRob2RzLmluY2x1ZGVzKHBNZXRob2QpKSB7XG4gICAgICByZXR1cm4gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuYm9keSkgPyBcIlBPU1RcIiA6IFwiR0VUXCI7XG4gICAgfVxuICAgIHJldHVybiBwTWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gIH1cbiAgcmV0dXJuIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmJvZHkpID8gXCJQT1NUXCIgOiBcIkdFVFwiO1xufVxuZnVuY3Rpb24gZ2V0VGltZW91dChvcHRpb25zLCBjb250cm9sbGVyKSB7XG4gIGxldCBhYm9ydFRpbWVvdXQ7XG4gIGlmICghKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsKSAmJiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50aW1lb3V0KSkge1xuICAgIGFib3J0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5hYm9ydCgpLCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnRpbWVvdXQpO1xuICB9XG4gIHJldHVybiB7XG4gICAgYWJvcnRUaW1lb3V0LFxuICAgIGNsZWFyVGltZW91dDogKCkgPT4ge1xuICAgICAgaWYgKGFib3J0VGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoYWJvcnRUaW1lb3V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBib2R5UGFyc2VyKGRhdGEsIHJlc3BvbnNlVHlwZSkge1xuICBpZiAocmVzcG9uc2VUeXBlID09PSBcImpzb25cIikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxudmFyIFZhbGlkYXRpb25FcnJvciA9IGNsYXNzIF9WYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGlzc3VlcywgbWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UgfHwgSlNPTi5zdHJpbmdpZnkoaXNzdWVzLCBudWxsLCAyKSk7XG4gICAgdGhpcy5pc3N1ZXMgPSBpc3N1ZXM7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIF9WYWxpZGF0aW9uRXJyb3IucHJvdG90eXBlKTtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIHBhcnNlU3RhbmRhcmRTY2hlbWEoc2NoZW1hLCBpbnB1dCkge1xuICBsZXQgcmVzdWx0ID0gYXdhaXQgc2NoZW1hW1wifnN0YW5kYXJkXCJdLnZhbGlkYXRlKGlucHV0KTtcbiAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKHJlc3VsdC5pc3N1ZXMpO1xuICB9XG4gIHJldHVybiByZXN1bHQudmFsdWU7XG59XG5cbi8vIHNyYy9jcmVhdGUtZmV0Y2gvc2NoZW1hLnRzXG52YXIgbWV0aG9kcyA9IFtcImdldFwiLCBcInBvc3RcIiwgXCJwdXRcIiwgXCJwYXRjaFwiLCBcImRlbGV0ZVwiXTtcbnZhciBjcmVhdGVTY2hlbWEgPSAoc2NoZW1hLCBjb25maWcpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBzY2hlbWEsXG4gICAgY29uZmlnXG4gIH07XG59O1xuXG4vLyBzcmMvY3JlYXRlLWZldGNoL2luZGV4LnRzXG52YXIgYXBwbHlTY2hlbWFQbHVnaW4gPSAoY29uZmlnKSA9PiAoe1xuICBpZDogXCJhcHBseS1zY2hlbWFcIixcbiAgbmFtZTogXCJBcHBseSBTY2hlbWFcIixcbiAgdmVyc2lvbjogXCIxLjAuMFwiLFxuICBhc3luYyBpbml0KHVybCwgb3B0aW9ucykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBjb25zdCBzY2hlbWEgPSAoKF9iID0gKF9hID0gY29uZmlnLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5maW5kKFxuICAgICAgKHBsdWdpbikgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICByZXR1cm4gKChfYTIgPSBwbHVnaW4uc2NoZW1hKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNvbmZpZykgPyB1cmwuc3RhcnRzV2l0aChwbHVnaW4uc2NoZW1hLmNvbmZpZy5iYXNlVVJMIHx8IFwiXCIpIHx8IHVybC5zdGFydHNXaXRoKHBsdWdpbi5zY2hlbWEuY29uZmlnLnByZWZpeCB8fCBcIlwiKSA6IGZhbHNlO1xuICAgICAgfVxuICAgICkpID09IG51bGwgPyB2b2lkIDAgOiBfYi5zY2hlbWEpIHx8IGNvbmZpZy5zY2hlbWE7XG4gICAgaWYgKHNjaGVtYSkge1xuICAgICAgbGV0IHVybEtleSA9IHVybDtcbiAgICAgIGlmICgoX2MgPSBzY2hlbWEuY29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogX2MucHJlZml4KSB7XG4gICAgICAgIGlmICh1cmxLZXkuc3RhcnRzV2l0aChzY2hlbWEuY29uZmlnLnByZWZpeCkpIHtcbiAgICAgICAgICB1cmxLZXkgPSB1cmxLZXkucmVwbGFjZShzY2hlbWEuY29uZmlnLnByZWZpeCwgXCJcIik7XG4gICAgICAgICAgaWYgKHNjaGVtYS5jb25maWcuYmFzZVVSTCkge1xuICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2Uoc2NoZW1hLmNvbmZpZy5wcmVmaXgsIHNjaGVtYS5jb25maWcuYmFzZVVSTCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoKF9kID0gc2NoZW1hLmNvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmJhc2VVUkwpIHtcbiAgICAgICAgaWYgKHVybEtleS5zdGFydHNXaXRoKHNjaGVtYS5jb25maWcuYmFzZVVSTCkpIHtcbiAgICAgICAgICB1cmxLZXkgPSB1cmxLZXkucmVwbGFjZShzY2hlbWEuY29uZmlnLmJhc2VVUkwsIFwiXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBrZXlTY2hlbWEgPSBzY2hlbWEuc2NoZW1hW3VybEtleV07XG4gICAgICBpZiAoa2V5U2NoZW1hKSB7XG4gICAgICAgIGxldCBvcHRzID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgICAgICBtZXRob2Q6IGtleVNjaGVtYS5tZXRob2QsXG4gICAgICAgICAgb3V0cHV0OiBrZXlTY2hlbWEub3V0cHV0XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIShvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRpc2FibGVWYWxpZGF0aW9uKSkge1xuICAgICAgICAgIG9wdHMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRzKSwge1xuICAgICAgICAgICAgYm9keToga2V5U2NoZW1hLmlucHV0ID8gYXdhaXQgcGFyc2VTdGFuZGFyZFNjaGVtYShrZXlTY2hlbWEuaW5wdXQsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuYm9keSkgOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmJvZHksXG4gICAgICAgICAgICBwYXJhbXM6IGtleVNjaGVtYS5wYXJhbXMgPyBhd2FpdCBwYXJzZVN0YW5kYXJkU2NoZW1hKGtleVNjaGVtYS5wYXJhbXMsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyYW1zKSA6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyYW1zLFxuICAgICAgICAgICAgcXVlcnk6IGtleVNjaGVtYS5xdWVyeSA/IGF3YWl0IHBhcnNlU3RhbmRhcmRTY2hlbWEoa2V5U2NoZW1hLnF1ZXJ5LCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnF1ZXJ5KSA6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucXVlcnlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICBvcHRpb25zOiBvcHRzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB1cmwsXG4gICAgICBvcHRpb25zXG4gICAgfTtcbiAgfVxufSk7XG52YXIgY3JlYXRlRmV0Y2ggPSAoY29uZmlnKSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uICRmZXRjaCh1cmwsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRzID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgY29uZmlnKSwgb3B0aW9ucyksIHtcbiAgICAgIHBsdWdpbnM6IFsuLi4oY29uZmlnID09IG51bGwgPyB2b2lkIDAgOiBjb25maWcucGx1Z2lucykgfHwgW10sIGFwcGx5U2NoZW1hUGx1Z2luKGNvbmZpZyB8fCB7fSldXG4gICAgfSk7XG4gICAgaWYgKGNvbmZpZyA9PSBudWxsID8gdm9pZCAwIDogY29uZmlnLmNhdGNoQWxsRXJyb3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBiZXR0ZXJGZXRjaCh1cmwsIG9wdHMpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IFwiRmV0Y2ggRXJyb3JcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiRmV0Y2ggcmVsYXRlZCBlcnJvci4gQ2FwdHVyZWQgYnkgY2F0Y2hBbGxFcnJvciBvcHRpb24uIFNlZSBlcnJvciBwcm9wZXJ0eSBmb3IgbW9yZSBkZXRhaWxzLlwiLFxuICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBiZXR0ZXJGZXRjaCh1cmwsIG9wdHMpO1xuICB9XG4gIHJldHVybiAkZmV0Y2g7XG59O1xuXG4vLyBzcmMvdXJsLnRzXG5mdW5jdGlvbiBnZXRVUkwyKHVybCwgb3B0aW9uKSB7XG4gIGxldCB7IGJhc2VVUkwsIHBhcmFtcywgcXVlcnkgfSA9IG9wdGlvbiB8fCB7XG4gICAgcXVlcnk6IHt9LFxuICAgIHBhcmFtczoge30sXG4gICAgYmFzZVVSTDogXCJcIlxuICB9O1xuICBsZXQgYmFzZVBhdGggPSB1cmwuc3RhcnRzV2l0aChcImh0dHBcIikgPyB1cmwuc3BsaXQoXCIvXCIpLnNsaWNlKDAsIDMpLmpvaW4oXCIvXCIpIDogYmFzZVVSTCB8fCBcIlwiO1xuICBpZiAodXJsLnN0YXJ0c1dpdGgoXCJAXCIpKSB7XG4gICAgY29uc3QgbSA9IHVybC50b1N0cmluZygpLnNwbGl0KFwiQFwiKVsxXS5zcGxpdChcIi9cIilbMF07XG4gICAgaWYgKG1ldGhvZHMuaW5jbHVkZXMobSkpIHtcbiAgICAgIHVybCA9IHVybC5yZXBsYWNlKGBAJHttfS9gLCBcIi9cIik7XG4gICAgfVxuICB9XG4gIGlmICghYmFzZVBhdGguZW5kc1dpdGgoXCIvXCIpKSBiYXNlUGF0aCArPSBcIi9cIjtcbiAgbGV0IFtwYXRoLCB1cmxRdWVyeV0gPSB1cmwucmVwbGFjZShiYXNlUGF0aCwgXCJcIikuc3BsaXQoXCI/XCIpO1xuICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXModXJsUXVlcnkpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhxdWVyeSB8fCB7fSkpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgY29udGludWU7XG4gICAgcXVlcnlQYXJhbXMuc2V0KGtleSwgU3RyaW5nKHZhbHVlKSk7XG4gIH1cbiAgaWYgKHBhcmFtcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICAgIGNvbnN0IHBhcmFtUGF0aHMgPSBwYXRoLnNwbGl0KFwiL1wiKS5maWx0ZXIoKHApID0+IHAuc3RhcnRzV2l0aChcIjpcIikpO1xuICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGtleV0gb2YgcGFyYW1QYXRocy5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXNbaW5kZXhdO1xuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbXMpKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoYDoke2tleX1gLCBTdHJpbmcodmFsdWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGF0aCA9IHBhdGguc3BsaXQoXCIvXCIpLm1hcChlbmNvZGVVUklDb21wb25lbnQpLmpvaW4oXCIvXCIpO1xuICBpZiAocGF0aC5zdGFydHNXaXRoKFwiL1wiKSkgcGF0aCA9IHBhdGguc2xpY2UoMSk7XG4gIGxldCBxdWVyeVBhcmFtU3RyaW5nID0gcXVlcnlQYXJhbXMudG9TdHJpbmcoKTtcbiAgcXVlcnlQYXJhbVN0cmluZyA9IHF1ZXJ5UGFyYW1TdHJpbmcubGVuZ3RoID4gMCA/IGA/JHtxdWVyeVBhcmFtU3RyaW5nfWAucmVwbGFjZSgvXFwrL2csIFwiJTIwXCIpIDogXCJcIjtcbiAgaWYgKCFiYXNlUGF0aC5zdGFydHNXaXRoKFwiaHR0cFwiKSkge1xuICAgIHJldHVybiBgJHtiYXNlUGF0aH0ke3BhdGh9JHtxdWVyeVBhcmFtU3RyaW5nfWA7XG4gIH1cbiAgY29uc3QgX3VybCA9IG5ldyBVUkwoYCR7cGF0aH0ke3F1ZXJ5UGFyYW1TdHJpbmd9YCwgYmFzZVBhdGgpO1xuICByZXR1cm4gX3VybDtcbn1cblxuLy8gc3JjL2ZldGNoLnRzXG52YXIgYmV0dGVyRmV0Y2ggPSBhc3luYyAodXJsLCBvcHRpb25zKSA9PiB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gIGNvbnN0IHtcbiAgICBob29rcyxcbiAgICB1cmw6IF9fdXJsLFxuICAgIG9wdGlvbnM6IG9wdHNcbiAgfSA9IGF3YWl0IGluaXRpYWxpemVQbHVnaW5zKHVybCwgb3B0aW9ucyk7XG4gIGNvbnN0IGZldGNoID0gZ2V0RmV0Y2gob3B0cyk7XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gIGNvbnN0IHNpZ25hbCA9IChfYSA9IG9wdHMuc2lnbmFsKSAhPSBudWxsID8gX2EgOiBjb250cm9sbGVyLnNpZ25hbDtcbiAgY29uc3QgX3VybCA9IGdldFVSTDIoX191cmwsIG9wdHMpO1xuICBjb25zdCBib2R5ID0gZ2V0Qm9keShvcHRzKTtcbiAgY29uc3QgaGVhZGVycyA9IGF3YWl0IGdldEhlYWRlcnMob3B0cyk7XG4gIGNvbnN0IG1ldGhvZCA9IGdldE1ldGhvZChfX3VybCwgb3B0cyk7XG4gIGxldCBjb250ZXh0ID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0cyksIHtcbiAgICB1cmw6IF91cmwsXG4gICAgaGVhZGVycyxcbiAgICBib2R5LFxuICAgIG1ldGhvZCxcbiAgICBzaWduYWxcbiAgfSk7XG4gIGZvciAoY29uc3Qgb25SZXF1ZXN0IG9mIGhvb2tzLm9uUmVxdWVzdCkge1xuICAgIGlmIChvblJlcXVlc3QpIHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IG9uUmVxdWVzdChjb250ZXh0KTtcbiAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgY29udGV4dCA9IHJlcztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKFwicGlwZVRvXCIgaW4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5waXBlVG8gPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgKChfYiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuYm9keSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnBpcGUpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBpZiAoIShcImR1cGxleFwiIGluIGNvbnRleHQpKSB7XG4gICAgICBjb250ZXh0LmR1cGxleCA9IFwiaGFsZlwiO1xuICAgIH1cbiAgfVxuICBjb25zdCB7IGNsZWFyVGltZW91dDogY2xlYXJUaW1lb3V0MiB9ID0gZ2V0VGltZW91dChvcHRzLCBjb250cm9sbGVyKTtcbiAgbGV0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goY29udGV4dC51cmwsIGNvbnRleHQpO1xuICBjbGVhclRpbWVvdXQyKCk7XG4gIGNvbnN0IHJlc3BvbnNlQ29udGV4dCA9IHtcbiAgICByZXNwb25zZSxcbiAgICByZXF1ZXN0OiBjb250ZXh0XG4gIH07XG4gIGZvciAoY29uc3Qgb25SZXNwb25zZSBvZiBob29rcy5vblJlc3BvbnNlKSB7XG4gICAgaWYgKG9uUmVzcG9uc2UpIHtcbiAgICAgIGNvbnN0IHIgPSBhd2FpdCBvblJlc3BvbnNlKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHJlc3BvbnNlQ29udGV4dCksIHtcbiAgICAgICAgcmVzcG9uc2U6ICgoX2MgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmhvb2tPcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2xvbmVSZXNwb25zZSkgPyByZXNwb25zZS5jbG9uZSgpIDogcmVzcG9uc2VcbiAgICAgIH0pKTtcbiAgICAgIGlmIChyIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgcmVzcG9uc2UgPSByO1xuICAgICAgfSBlbHNlIGlmIChyIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIHJlc3BvbnNlID0gci5yZXNwb25zZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgY29uc3QgaGFzQm9keSA9IGNvbnRleHQubWV0aG9kICE9PSBcIkhFQURcIjtcbiAgICBpZiAoIWhhc0JvZHkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IFwiXCIsXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZVR5cGUgPSBkZXRlY3RSZXNwb25zZVR5cGUocmVzcG9uc2UpO1xuICAgIGNvbnN0IHN1Y2Nlc3NDb250ZXh0ID0ge1xuICAgICAgZGF0YTogXCJcIixcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgcmVxdWVzdDogY29udGV4dFxuICAgIH07XG4gICAgaWYgKHJlc3BvbnNlVHlwZSA9PT0gXCJqc29uXCIgfHwgcmVzcG9uc2VUeXBlID09PSBcInRleHRcIikge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIGNvbnN0IHBhcnNlcjIgPSAoX2QgPSBjb250ZXh0Lmpzb25QYXJzZXIpICE9IG51bGwgPyBfZCA6IGpzb25QYXJzZTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwYXJzZXIyKHRleHQpO1xuICAgICAgc3VjY2Vzc0NvbnRleHQuZGF0YSA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1Y2Nlc3NDb250ZXh0LmRhdGEgPSBhd2FpdCByZXNwb25zZVtyZXNwb25zZVR5cGVdKCk7XG4gICAgfVxuICAgIGlmIChjb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZXh0Lm91dHB1dCkge1xuICAgICAgaWYgKGNvbnRleHQub3V0cHV0ICYmICFjb250ZXh0LmRpc2FibGVWYWxpZGF0aW9uKSB7XG4gICAgICAgIHN1Y2Nlc3NDb250ZXh0LmRhdGEgPSBhd2FpdCBwYXJzZVN0YW5kYXJkU2NoZW1hKFxuICAgICAgICAgIGNvbnRleHQub3V0cHV0LFxuICAgICAgICAgIHN1Y2Nlc3NDb250ZXh0LmRhdGFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBvblN1Y2Nlc3Mgb2YgaG9va3Mub25TdWNjZXNzKSB7XG4gICAgICBpZiAob25TdWNjZXNzKSB7XG4gICAgICAgIGF3YWl0IG9uU3VjY2VzcyhfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBzdWNjZXNzQ29udGV4dCksIHtcbiAgICAgICAgICByZXNwb25zZTogKChfZSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaG9va09wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfZS5jbG9uZVJlc3BvbnNlKSA/IHJlc3BvbnNlLmNsb25lKCkgOiByZXNwb25zZVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnRocm93KSB7XG4gICAgICByZXR1cm4gc3VjY2Vzc0NvbnRleHQuZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHN1Y2Nlc3NDb250ZXh0LmRhdGEsXG4gICAgICBlcnJvcjogbnVsbFxuICAgIH07XG4gIH1cbiAgY29uc3QgcGFyc2VyID0gKF9mID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5qc29uUGFyc2VyKSAhPSBudWxsID8gX2YgOiBqc29uUGFyc2U7XG4gIGNvbnN0IHJlc3BvbnNlVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgY29uc3QgaXNKU09OUmVzcG9uc2UgPSBpc0pTT05QYXJzYWJsZShyZXNwb25zZVRleHQpO1xuICBjb25zdCBlcnJvck9iamVjdCA9IGlzSlNPTlJlc3BvbnNlID8gYXdhaXQgcGFyc2VyKHJlc3BvbnNlVGV4dCkgOiBudWxsO1xuICBjb25zdCBlcnJvckNvbnRleHQgPSB7XG4gICAgcmVzcG9uc2UsXG4gICAgcmVzcG9uc2VUZXh0LFxuICAgIHJlcXVlc3Q6IGNvbnRleHQsXG4gICAgZXJyb3I6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGVycm9yT2JqZWN0KSwge1xuICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0XG4gICAgfSlcbiAgfTtcbiAgZm9yIChjb25zdCBvbkVycm9yIG9mIGhvb2tzLm9uRXJyb3IpIHtcbiAgICBpZiAob25FcnJvcikge1xuICAgICAgYXdhaXQgb25FcnJvcihfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBlcnJvckNvbnRleHQpLCB7XG4gICAgICAgIHJlc3BvbnNlOiAoKF9nID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5ob29rT3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLmNsb25lUmVzcG9uc2UpID8gcmVzcG9uc2UuY2xvbmUoKSA6IHJlc3BvbnNlXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnJldHJ5KSB7XG4gICAgY29uc3QgcmV0cnlTdHJhdGVneSA9IGNyZWF0ZVJldHJ5U3RyYXRlZ3kob3B0aW9ucy5yZXRyeSk7XG4gICAgY29uc3QgX3JldHJ5QXR0ZW1wdCA9IChfaCA9IG9wdGlvbnMucmV0cnlBdHRlbXB0KSAhPSBudWxsID8gX2ggOiAwO1xuICAgIGlmIChhd2FpdCByZXRyeVN0cmF0ZWd5LnNob3VsZEF0dGVtcHRSZXRyeShfcmV0cnlBdHRlbXB0LCByZXNwb25zZSkpIHtcbiAgICAgIGZvciAoY29uc3Qgb25SZXRyeSBvZiBob29rcy5vblJldHJ5KSB7XG4gICAgICAgIGlmIChvblJldHJ5KSB7XG4gICAgICAgICAgYXdhaXQgb25SZXRyeShyZXNwb25zZUNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBkZWxheSA9IHJldHJ5U3RyYXRlZ3kuZ2V0RGVsYXkoX3JldHJ5QXR0ZW1wdCk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICAgICAgcmV0dXJuIGF3YWl0IGJldHRlckZldGNoKHVybCwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgICAgcmV0cnlBdHRlbXB0OiBfcmV0cnlBdHRlbXB0ICsgMVxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50aHJvdykge1xuICAgIHRocm93IG5ldyBCZXR0ZXJGZXRjaEVycm9yKFxuICAgICAgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgIGlzSlNPTlJlc3BvbnNlID8gZXJyb3JPYmplY3QgOiByZXNwb25zZVRleHRcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF0YTogbnVsbCxcbiAgICBlcnJvcjogX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgZXJyb3JPYmplY3QpLCB7XG4gICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICB9KVxuICB9O1xufTtcbmV4cG9ydCB7XG4gIEJldHRlckZldGNoRXJyb3IsXG4gIFZhbGlkYXRpb25FcnJvcixcbiAgYXBwbHlTY2hlbWFQbHVnaW4sXG4gIGJldHRlckZldGNoLFxuICBib2R5UGFyc2VyLFxuICBjcmVhdGVGZXRjaCxcbiAgY3JlYXRlUmV0cnlTdHJhdGVneSxcbiAgY3JlYXRlU2NoZW1hLFxuICBkZXRlY3RDb250ZW50VHlwZSxcbiAgZGV0ZWN0UmVzcG9uc2VUeXBlLFxuICBnZXRCb2R5LFxuICBnZXRGZXRjaCxcbiAgZ2V0SGVhZGVycyxcbiAgZ2V0TWV0aG9kLFxuICBnZXRUaW1lb3V0LFxuICBnZXRVUkwsXG4gIGluaXRpYWxpemVQbHVnaW5zLFxuICBpc0Z1bmN0aW9uLFxuICBpc0pTT05QYXJzYWJsZSxcbiAgaXNKU09OU2VyaWFsaXphYmxlLFxuICBpc1BheWxvYWRNZXRob2QsXG4gIGlzUm91dGVNZXRob2QsXG4gIGpzb25QYXJzZSxcbiAgbWV0aG9kcyxcbiAgcGFyc2VTdGFuZGFyZFNjaGVtYVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@better-fetch/fetch/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@better-fetch/fetch/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@better-fetch/fetch/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BetterFetchError: () => (/* binding */ BetterFetchError),\n/* harmony export */   ValidationError: () => (/* binding */ ValidationError),\n/* harmony export */   applySchemaPlugin: () => (/* binding */ applySchemaPlugin),\n/* harmony export */   betterFetch: () => (/* binding */ betterFetch),\n/* harmony export */   bodyParser: () => (/* binding */ bodyParser),\n/* harmony export */   createFetch: () => (/* binding */ createFetch),\n/* harmony export */   createRetryStrategy: () => (/* binding */ createRetryStrategy),\n/* harmony export */   createSchema: () => (/* binding */ createSchema),\n/* harmony export */   detectContentType: () => (/* binding */ detectContentType),\n/* harmony export */   detectResponseType: () => (/* binding */ detectResponseType),\n/* harmony export */   getBody: () => (/* binding */ getBody),\n/* harmony export */   getFetch: () => (/* binding */ getFetch),\n/* harmony export */   getHeaders: () => (/* binding */ getHeaders),\n/* harmony export */   getMethod: () => (/* binding */ getMethod),\n/* harmony export */   getTimeout: () => (/* binding */ getTimeout),\n/* harmony export */   getURL: () => (/* binding */ getURL),\n/* harmony export */   initializePlugins: () => (/* binding */ initializePlugins),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isJSONParsable: () => (/* binding */ isJSONParsable),\n/* harmony export */   isJSONSerializable: () => (/* binding */ isJSONSerializable),\n/* harmony export */   isPayloadMethod: () => (/* binding */ isPayloadMethod),\n/* harmony export */   isRouteMethod: () => (/* binding */ isRouteMethod),\n/* harmony export */   jsonParse: () => (/* binding */ jsonParse),\n/* harmony export */   methods: () => (/* binding */ methods),\n/* harmony export */   parseStandardSchema: () => (/* binding */ parseStandardSchema)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// src/error.ts\nvar BetterFetchError = class extends Error {\n  constructor(status, statusText, error) {\n    super(statusText || status.toString(), {\n      cause: error\n    });\n    this.status = status;\n    this.statusText = statusText;\n    this.error = error;\n  }\n};\n\n// src/plugins.ts\nvar initializePlugins = async (url, options) => {\n  var _a, _b, _c, _d, _e, _f;\n  let opts = options || {};\n  const hooks = {\n    onRequest: [options == null ? void 0 : options.onRequest],\n    onResponse: [options == null ? void 0 : options.onResponse],\n    onSuccess: [options == null ? void 0 : options.onSuccess],\n    onError: [options == null ? void 0 : options.onError],\n    onRetry: [options == null ? void 0 : options.onRetry]\n  };\n  if (!options || !(options == null ? void 0 : options.plugins)) {\n    return {\n      url,\n      options: opts,\n      hooks\n    };\n  }\n  for (const plugin of (options == null ? void 0 : options.plugins) || []) {\n    if (plugin.init) {\n      const pluginRes = await ((_a = plugin.init) == null ? void 0 : _a.call(plugin, url.toString(), options));\n      opts = pluginRes.options || opts;\n      url = pluginRes.url;\n    }\n    hooks.onRequest.push((_b = plugin.hooks) == null ? void 0 : _b.onRequest);\n    hooks.onResponse.push((_c = plugin.hooks) == null ? void 0 : _c.onResponse);\n    hooks.onSuccess.push((_d = plugin.hooks) == null ? void 0 : _d.onSuccess);\n    hooks.onError.push((_e = plugin.hooks) == null ? void 0 : _e.onError);\n    hooks.onRetry.push((_f = plugin.hooks) == null ? void 0 : _f.onRetry);\n  }\n  return {\n    url,\n    options: opts,\n    hooks\n  };\n};\n\n// src/retry.ts\nvar LinearRetryStrategy = class {\n  constructor(options) {\n    this.options = options;\n  }\n  shouldAttemptRetry(attempt, response) {\n    if (this.options.shouldRetry) {\n      return Promise.resolve(\n        attempt < this.options.attempts && this.options.shouldRetry(response)\n      );\n    }\n    return Promise.resolve(attempt < this.options.attempts);\n  }\n  getDelay() {\n    return this.options.delay;\n  }\n};\nvar ExponentialRetryStrategy = class {\n  constructor(options) {\n    this.options = options;\n  }\n  shouldAttemptRetry(attempt, response) {\n    if (this.options.shouldRetry) {\n      return Promise.resolve(\n        attempt < this.options.attempts && this.options.shouldRetry(response)\n      );\n    }\n    return Promise.resolve(attempt < this.options.attempts);\n  }\n  getDelay(attempt) {\n    const delay = Math.min(\n      this.options.maxDelay,\n      this.options.baseDelay * 2 ** attempt\n    );\n    return delay;\n  }\n};\nfunction createRetryStrategy(options) {\n  if (typeof options === \"number\") {\n    return new LinearRetryStrategy({\n      type: \"linear\",\n      attempts: options,\n      delay: 1e3\n    });\n  }\n  switch (options.type) {\n    case \"linear\":\n      return new LinearRetryStrategy(options);\n    case \"exponential\":\n      return new ExponentialRetryStrategy(options);\n    default:\n      throw new Error(\"Invalid retry strategy\");\n  }\n}\n\n// src/auth.ts\nvar getAuthHeader = async (options) => {\n  const headers = {};\n  const getValue = async (value) => typeof value === \"function\" ? await value() : value;\n  if (options == null ? void 0 : options.auth) {\n    if (options.auth.type === \"Bearer\") {\n      const token = await getValue(options.auth.token);\n      if (!token) {\n        return headers;\n      }\n      headers[\"authorization\"] = `Bearer ${token}`;\n    } else if (options.auth.type === \"Basic\") {\n      const username = getValue(options.auth.username);\n      const password = getValue(options.auth.password);\n      if (!username || !password) {\n        return headers;\n      }\n      headers[\"authorization\"] = `Basic ${btoa(`${username}:${password}`)}`;\n    } else if (options.auth.type === \"Custom\") {\n      const value = getValue(options.auth.value);\n      if (!value) {\n        return headers;\n      }\n      headers[\"authorization\"] = `${getValue(options.auth.prefix)} ${value}`;\n    }\n  }\n  return headers;\n};\n\n// src/utils.ts\nvar JSON_RE = /^application\\/(?:[\\w!#$%&*.^`~-]*\\+)?json(;.+)?$/i;\nfunction detectResponseType(request) {\n  const _contentType = request.headers.get(\"content-type\");\n  const textTypes = /* @__PURE__ */ new Set([\n    \"image/svg\",\n    \"application/xml\",\n    \"application/xhtml\",\n    \"application/html\"\n  ]);\n  if (!_contentType) {\n    return \"json\";\n  }\n  const contentType = _contentType.split(\";\").shift() || \"\";\n  if (JSON_RE.test(contentType)) {\n    return \"json\";\n  }\n  if (textTypes.has(contentType) || contentType.startsWith(\"text/\")) {\n    return \"text\";\n  }\n  return \"blob\";\n}\nfunction isJSONParsable(value) {\n  try {\n    JSON.parse(value);\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\nfunction isJSONSerializable(value) {\n  if (value === void 0) {\n    return false;\n  }\n  const t = typeof value;\n  if (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) {\n    return true;\n  }\n  if (t !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return true;\n  }\n  if (value.buffer) {\n    return false;\n  }\n  return value.constructor && value.constructor.name === \"Object\" || typeof value.toJSON === \"function\";\n}\nfunction jsonParse(text) {\n  try {\n    return JSON.parse(text);\n  } catch (error) {\n    return text;\n  }\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction getFetch(options) {\n  if (options == null ? void 0 : options.customFetchImpl) {\n    return options.customFetchImpl;\n  }\n  if (typeof globalThis !== \"undefined\" && isFunction(globalThis.fetch)) {\n    return globalThis.fetch;\n  }\n  if (typeof window !== \"undefined\" && isFunction(window.fetch)) {\n    return window.fetch;\n  }\n  throw new Error(\"No fetch implementation found\");\n}\nfunction isPayloadMethod(method) {\n  if (!method) {\n    return false;\n  }\n  const payloadMethod = [\"POST\", \"PUT\", \"PATCH\", \"DELETE\"];\n  return payloadMethod.includes(method.toUpperCase());\n}\nfunction isRouteMethod(method) {\n  const routeMethod = [\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"];\n  if (!method) {\n    return false;\n  }\n  return routeMethod.includes(method.toUpperCase());\n}\nasync function getHeaders(opts) {\n  const headers = new Headers(opts == null ? void 0 : opts.headers);\n  const authHeader = await getAuthHeader(opts);\n  for (const [key, value] of Object.entries(authHeader || {})) {\n    headers.set(key, value);\n  }\n  if (!headers.has(\"content-type\")) {\n    const t = detectContentType(opts == null ? void 0 : opts.body);\n    if (t) {\n      headers.set(\"content-type\", t);\n    }\n  }\n  return headers;\n}\nfunction getURL(url, options) {\n  if (url.startsWith(\"@\")) {\n    const m = url.toString().split(\"@\")[1].split(\"/\")[0];\n    if (methods.includes(m)) {\n      url = url.replace(`@${m}/`, \"/\");\n    }\n  }\n  let _url;\n  try {\n    if (url.startsWith(\"http\")) {\n      _url = url;\n    } else {\n      let baseURL = options == null ? void 0 : options.baseURL;\n      if (baseURL && !(baseURL == null ? void 0 : baseURL.endsWith(\"/\"))) {\n        baseURL = baseURL + \"/\";\n      }\n      if (url.startsWith(\"/\")) {\n        _url = new URL(url.substring(1), baseURL);\n      } else {\n        _url = new URL(url, options == null ? void 0 : options.baseURL);\n      }\n    }\n  } catch (e) {\n    if (e instanceof TypeError) {\n      if (!(options == null ? void 0 : options.baseURL)) {\n        throw TypeError(\n          `Invalid URL ${url}. Are you passing in a relative url but not setting the baseURL?`\n        );\n      }\n      throw TypeError(\n        `Invalid URL ${url}. Please validate that you are passing the correct input.`\n      );\n    }\n    throw e;\n  }\n  if (options == null ? void 0 : options.params) {\n    if (Array.isArray(options == null ? void 0 : options.params)) {\n      const params = (options == null ? void 0 : options.params) ? Array.isArray(options.params) ? `/${options.params.join(\"/\")}` : `/${Object.values(options.params).join(\"/\")}` : \"\";\n      _url = _url.toString().split(\"/:\")[0];\n      _url = `${_url.toString()}${params}`;\n    } else {\n      for (const [key, value] of Object.entries(options == null ? void 0 : options.params)) {\n        _url = _url.toString().replace(`:${key}`, String(value));\n      }\n    }\n  }\n  const __url = new URL(_url);\n  const queryParams = options == null ? void 0 : options.query;\n  if (queryParams) {\n    for (const [key, value] of Object.entries(queryParams)) {\n      __url.searchParams.append(key, String(value));\n    }\n  }\n  return __url;\n}\nfunction detectContentType(body) {\n  if (isJSONSerializable(body)) {\n    return \"application/json\";\n  }\n  return null;\n}\nfunction getBody(options) {\n  if (!(options == null ? void 0 : options.body)) {\n    return null;\n  }\n  const headers = new Headers(options == null ? void 0 : options.headers);\n  if (isJSONSerializable(options.body) && !headers.has(\"content-type\")) {\n    for (const [key, value] of Object.entries(options == null ? void 0 : options.body)) {\n      if (value instanceof Date) {\n        options.body[key] = value.toISOString();\n      }\n    }\n    return JSON.stringify(options.body);\n  }\n  return options.body;\n}\nfunction getMethod(url, options) {\n  var _a;\n  if (options == null ? void 0 : options.method) {\n    return options.method.toUpperCase();\n  }\n  if (url.startsWith(\"@\")) {\n    const pMethod = (_a = url.split(\"@\")[1]) == null ? void 0 : _a.split(\"/\")[0];\n    if (!methods.includes(pMethod)) {\n      return (options == null ? void 0 : options.body) ? \"POST\" : \"GET\";\n    }\n    return pMethod.toUpperCase();\n  }\n  return (options == null ? void 0 : options.body) ? \"POST\" : \"GET\";\n}\nfunction getTimeout(options, controller) {\n  let abortTimeout;\n  if (!(options == null ? void 0 : options.signal) && (options == null ? void 0 : options.timeout)) {\n    abortTimeout = setTimeout(() => controller == null ? void 0 : controller.abort(), options == null ? void 0 : options.timeout);\n  }\n  return {\n    abortTimeout,\n    clearTimeout: () => {\n      if (abortTimeout) {\n        clearTimeout(abortTimeout);\n      }\n    }\n  };\n}\nfunction bodyParser(data, responseType) {\n  if (responseType === \"json\") {\n    return JSON.parse(data);\n  }\n  return data;\n}\nvar ValidationError = class _ValidationError extends Error {\n  constructor(issues, message) {\n    super(message || JSON.stringify(issues, null, 2));\n    this.issues = issues;\n    Object.setPrototypeOf(this, _ValidationError.prototype);\n  }\n};\nasync function parseStandardSchema(schema, input) {\n  let result = await schema[\"~standard\"].validate(input);\n  if (result.issues) {\n    throw new ValidationError(result.issues);\n  }\n  return result.value;\n}\n\n// src/create-fetch/schema.ts\nvar methods = [\"get\", \"post\", \"put\", \"patch\", \"delete\"];\nvar createSchema = (schema, config) => {\n  return {\n    schema,\n    config\n  };\n};\n\n// src/create-fetch/index.ts\nvar applySchemaPlugin = (config) => ({\n  id: \"apply-schema\",\n  name: \"Apply Schema\",\n  version: \"1.0.0\",\n  async init(url, options) {\n    var _a, _b, _c, _d;\n    const schema = ((_b = (_a = config.plugins) == null ? void 0 : _a.find(\n      (plugin) => {\n        var _a2;\n        return ((_a2 = plugin.schema) == null ? void 0 : _a2.config) ? url.startsWith(plugin.schema.config.baseURL || \"\") || url.startsWith(plugin.schema.config.prefix || \"\") : false;\n      }\n    )) == null ? void 0 : _b.schema) || config.schema;\n    if (schema) {\n      let urlKey = url;\n      if ((_c = schema.config) == null ? void 0 : _c.prefix) {\n        if (urlKey.startsWith(schema.config.prefix)) {\n          urlKey = urlKey.replace(schema.config.prefix, \"\");\n          if (schema.config.baseURL) {\n            url = url.replace(schema.config.prefix, schema.config.baseURL);\n          }\n        }\n      }\n      if ((_d = schema.config) == null ? void 0 : _d.baseURL) {\n        if (urlKey.startsWith(schema.config.baseURL)) {\n          urlKey = urlKey.replace(schema.config.baseURL, \"\");\n        }\n      }\n      const keySchema = schema.schema[urlKey];\n      if (keySchema) {\n        let opts = __spreadProps(__spreadValues({}, options), {\n          method: keySchema.method,\n          output: keySchema.output\n        });\n        if (!(options == null ? void 0 : options.disableValidation)) {\n          opts = __spreadProps(__spreadValues({}, opts), {\n            body: keySchema.input ? await parseStandardSchema(keySchema.input, options == null ? void 0 : options.body) : options == null ? void 0 : options.body,\n            params: keySchema.params ? await parseStandardSchema(keySchema.params, options == null ? void 0 : options.params) : options == null ? void 0 : options.params,\n            query: keySchema.query ? await parseStandardSchema(keySchema.query, options == null ? void 0 : options.query) : options == null ? void 0 : options.query\n          });\n        }\n        return {\n          url,\n          options: opts\n        };\n      }\n    }\n    return {\n      url,\n      options\n    };\n  }\n});\nvar createFetch = (config) => {\n  async function $fetch(url, options) {\n    const opts = __spreadProps(__spreadValues(__spreadValues({}, config), options), {\n      plugins: [...(config == null ? void 0 : config.plugins) || [], applySchemaPlugin(config || {})]\n    });\n    if (config == null ? void 0 : config.catchAllError) {\n      try {\n        return await betterFetch(url, opts);\n      } catch (error) {\n        return {\n          data: null,\n          error: {\n            status: 500,\n            statusText: \"Fetch Error\",\n            message: \"Fetch related error. Captured by catchAllError option. See error property for more details.\",\n            error\n          }\n        };\n      }\n    }\n    return await betterFetch(url, opts);\n  }\n  return $fetch;\n};\n\n// src/url.ts\nfunction getURL2(url, option) {\n  let { baseURL, params, query } = option || {\n    query: {},\n    params: {},\n    baseURL: \"\"\n  };\n  let basePath = url.startsWith(\"http\") ? url.split(\"/\").slice(0, 3).join(\"/\") : baseURL || \"\";\n  if (url.startsWith(\"@\")) {\n    const m = url.toString().split(\"@\")[1].split(\"/\")[0];\n    if (methods.includes(m)) {\n      url = url.replace(`@${m}/`, \"/\");\n    }\n  }\n  if (!basePath.endsWith(\"/\")) basePath += \"/\";\n  let [path, urlQuery] = url.replace(basePath, \"\").split(\"?\");\n  const queryParams = new URLSearchParams(urlQuery);\n  for (const [key, value] of Object.entries(query || {})) {\n    if (value == null) continue;\n    queryParams.set(key, String(value));\n  }\n  if (params) {\n    if (Array.isArray(params)) {\n      const paramPaths = path.split(\"/\").filter((p) => p.startsWith(\":\"));\n      for (const [index, key] of paramPaths.entries()) {\n        const value = params[index];\n        path = path.replace(key, value);\n      }\n    } else {\n      for (const [key, value] of Object.entries(params)) {\n        path = path.replace(`:${key}`, String(value));\n      }\n    }\n  }\n  path = path.split(\"/\").map(encodeURIComponent).join(\"/\");\n  if (path.startsWith(\"/\")) path = path.slice(1);\n  let queryParamString = queryParams.toString();\n  queryParamString = queryParamString.length > 0 ? `?${queryParamString}`.replace(/\\+/g, \"%20\") : \"\";\n  if (!basePath.startsWith(\"http\")) {\n    return `${basePath}${path}${queryParamString}`;\n  }\n  const _url = new URL(`${path}${queryParamString}`, basePath);\n  return _url;\n}\n\n// src/fetch.ts\nvar betterFetch = async (url, options) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h;\n  const {\n    hooks,\n    url: __url,\n    options: opts\n  } = await initializePlugins(url, options);\n  const fetch = getFetch(opts);\n  const controller = new AbortController();\n  const signal = (_a = opts.signal) != null ? _a : controller.signal;\n  const _url = getURL2(__url, opts);\n  const body = getBody(opts);\n  const headers = await getHeaders(opts);\n  const method = getMethod(__url, opts);\n  let context = __spreadProps(__spreadValues({}, opts), {\n    url: _url,\n    headers,\n    body,\n    method,\n    signal\n  });\n  for (const onRequest of hooks.onRequest) {\n    if (onRequest) {\n      const res = await onRequest(context);\n      if (res instanceof Object) {\n        context = res;\n      }\n    }\n  }\n  if (\"pipeTo\" in context && typeof context.pipeTo === \"function\" || typeof ((_b = options == null ? void 0 : options.body) == null ? void 0 : _b.pipe) === \"function\") {\n    if (!(\"duplex\" in context)) {\n      context.duplex = \"half\";\n    }\n  }\n  const { clearTimeout: clearTimeout2 } = getTimeout(opts, controller);\n  let response = await fetch(context.url, context);\n  clearTimeout2();\n  const responseContext = {\n    response,\n    request: context\n  };\n  for (const onResponse of hooks.onResponse) {\n    if (onResponse) {\n      const r = await onResponse(__spreadProps(__spreadValues({}, responseContext), {\n        response: ((_c = options == null ? void 0 : options.hookOptions) == null ? void 0 : _c.cloneResponse) ? response.clone() : response\n      }));\n      if (r instanceof Response) {\n        response = r;\n      } else if (r instanceof Object) {\n        response = r.response;\n      }\n    }\n  }\n  if (response.ok) {\n    const hasBody = context.method !== \"HEAD\";\n    if (!hasBody) {\n      return {\n        data: \"\",\n        error: null\n      };\n    }\n    const responseType = detectResponseType(response);\n    const successContext = {\n      data: \"\",\n      response,\n      request: context\n    };\n    if (responseType === \"json\" || responseType === \"text\") {\n      const text = await response.text();\n      const parser2 = (_d = context.jsonParser) != null ? _d : jsonParse;\n      const data = await parser2(text);\n      successContext.data = data;\n    } else {\n      successContext.data = await response[responseType]();\n    }\n    if (context == null ? void 0 : context.output) {\n      if (context.output && !context.disableValidation) {\n        successContext.data = await parseStandardSchema(\n          context.output,\n          successContext.data\n        );\n      }\n    }\n    for (const onSuccess of hooks.onSuccess) {\n      if (onSuccess) {\n        await onSuccess(__spreadProps(__spreadValues({}, successContext), {\n          response: ((_e = options == null ? void 0 : options.hookOptions) == null ? void 0 : _e.cloneResponse) ? response.clone() : response\n        }));\n      }\n    }\n    if (options == null ? void 0 : options.throw) {\n      return successContext.data;\n    }\n    return {\n      data: successContext.data,\n      error: null\n    };\n  }\n  const parser = (_f = options == null ? void 0 : options.jsonParser) != null ? _f : jsonParse;\n  const responseText = await response.text();\n  const isJSONResponse = isJSONParsable(responseText);\n  const errorObject = isJSONResponse ? await parser(responseText) : null;\n  const errorContext = {\n    response,\n    responseText,\n    request: context,\n    error: __spreadProps(__spreadValues({}, errorObject), {\n      status: response.status,\n      statusText: response.statusText\n    })\n  };\n  for (const onError of hooks.onError) {\n    if (onError) {\n      await onError(__spreadProps(__spreadValues({}, errorContext), {\n        response: ((_g = options == null ? void 0 : options.hookOptions) == null ? void 0 : _g.cloneResponse) ? response.clone() : response\n      }));\n    }\n  }\n  if (options == null ? void 0 : options.retry) {\n    const retryStrategy = createRetryStrategy(options.retry);\n    const _retryAttempt = (_h = options.retryAttempt) != null ? _h : 0;\n    if (await retryStrategy.shouldAttemptRetry(_retryAttempt, response)) {\n      for (const onRetry of hooks.onRetry) {\n        if (onRetry) {\n          await onRetry(responseContext);\n        }\n      }\n      const delay = retryStrategy.getDelay(_retryAttempt);\n      await new Promise((resolve) => setTimeout(resolve, delay));\n      return await betterFetch(url, __spreadProps(__spreadValues({}, options), {\n        retryAttempt: _retryAttempt + 1\n      }));\n    }\n  }\n  if (options == null ? void 0 : options.throw) {\n    throw new BetterFetchError(\n      response.status,\n      response.statusText,\n      isJSONResponse ? errorObject : responseText\n    );\n  }\n  return {\n    data: null,\n    error: __spreadProps(__spreadValues({}, errorObject), {\n      status: response.status,\n      statusText: response.statusText\n    })\n  };\n};\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGJldHRlci1mZXRjaC9mZXRjaC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTTtBQUNqRCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRLFNBQVMsR0FBRyxTQUFTLEdBQUc7QUFDMUUs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UztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQTJCRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXV0b3BsYW5jYW0vLi9ub2RlX21vZHVsZXMvQGJldHRlci1mZXRjaC9mZXRjaC9kaXN0L2luZGV4LmpzPzVjMmEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG5cbi8vIHNyYy9lcnJvci50c1xudmFyIEJldHRlckZldGNoRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc3RhdHVzLCBzdGF0dXNUZXh0LCBlcnJvcikge1xuICAgIHN1cGVyKHN0YXR1c1RleHQgfHwgc3RhdHVzLnRvU3RyaW5nKCksIHtcbiAgICAgIGNhdXNlOiBlcnJvclxuICAgIH0pO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQ7XG4gICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICB9XG59O1xuXG4vLyBzcmMvcGx1Z2lucy50c1xudmFyIGluaXRpYWxpemVQbHVnaW5zID0gYXN5bmMgKHVybCwgb3B0aW9ucykgPT4ge1xuICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgbGV0IG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBob29rcyA9IHtcbiAgICBvblJlcXVlc3Q6IFtvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm9uUmVxdWVzdF0sXG4gICAgb25SZXNwb25zZTogW29wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMub25SZXNwb25zZV0sXG4gICAgb25TdWNjZXNzOiBbb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5vblN1Y2Nlc3NdLFxuICAgIG9uRXJyb3I6IFtvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm9uRXJyb3JdLFxuICAgIG9uUmV0cnk6IFtvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm9uUmV0cnldXG4gIH07XG4gIGlmICghb3B0aW9ucyB8fCAhKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucGx1Z2lucykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXJsLFxuICAgICAgb3B0aW9uczogb3B0cyxcbiAgICAgIGhvb2tzXG4gICAgfTtcbiAgfVxuICBmb3IgKGNvbnN0IHBsdWdpbiBvZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wbHVnaW5zKSB8fCBbXSkge1xuICAgIGlmIChwbHVnaW4uaW5pdCkge1xuICAgICAgY29uc3QgcGx1Z2luUmVzID0gYXdhaXQgKChfYSA9IHBsdWdpbi5pbml0KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChwbHVnaW4sIHVybC50b1N0cmluZygpLCBvcHRpb25zKSk7XG4gICAgICBvcHRzID0gcGx1Z2luUmVzLm9wdGlvbnMgfHwgb3B0cztcbiAgICAgIHVybCA9IHBsdWdpblJlcy51cmw7XG4gICAgfVxuICAgIGhvb2tzLm9uUmVxdWVzdC5wdXNoKChfYiA9IHBsdWdpbi5ob29rcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm9uUmVxdWVzdCk7XG4gICAgaG9va3Mub25SZXNwb25zZS5wdXNoKChfYyA9IHBsdWdpbi5ob29rcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLm9uUmVzcG9uc2UpO1xuICAgIGhvb2tzLm9uU3VjY2Vzcy5wdXNoKChfZCA9IHBsdWdpbi5ob29rcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLm9uU3VjY2Vzcyk7XG4gICAgaG9va3Mub25FcnJvci5wdXNoKChfZSA9IHBsdWdpbi5ob29rcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLm9uRXJyb3IpO1xuICAgIGhvb2tzLm9uUmV0cnkucHVzaCgoX2YgPSBwbHVnaW4uaG9va3MpID09IG51bGwgPyB2b2lkIDAgOiBfZi5vblJldHJ5KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHVybCxcbiAgICBvcHRpb25zOiBvcHRzLFxuICAgIGhvb2tzXG4gIH07XG59O1xuXG4vLyBzcmMvcmV0cnkudHNcbnZhciBMaW5lYXJSZXRyeVN0cmF0ZWd5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBzaG91bGRBdHRlbXB0UmV0cnkoYXR0ZW1wdCwgcmVzcG9uc2UpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNob3VsZFJldHJ5KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICBhdHRlbXB0IDwgdGhpcy5vcHRpb25zLmF0dGVtcHRzICYmIHRoaXMub3B0aW9ucy5zaG91bGRSZXRyeShyZXNwb25zZSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYXR0ZW1wdCA8IHRoaXMub3B0aW9ucy5hdHRlbXB0cyk7XG4gIH1cbiAgZ2V0RGVsYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5kZWxheTtcbiAgfVxufTtcbnZhciBFeHBvbmVudGlhbFJldHJ5U3RyYXRlZ3kgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIHNob3VsZEF0dGVtcHRSZXRyeShhdHRlbXB0LCByZXNwb25zZSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvdWxkUmV0cnkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgIGF0dGVtcHQgPCB0aGlzLm9wdGlvbnMuYXR0ZW1wdHMgJiYgdGhpcy5vcHRpb25zLnNob3VsZFJldHJ5KHJlc3BvbnNlKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhdHRlbXB0IDwgdGhpcy5vcHRpb25zLmF0dGVtcHRzKTtcbiAgfVxuICBnZXREZWxheShhdHRlbXB0KSB7XG4gICAgY29uc3QgZGVsYXkgPSBNYXRoLm1pbihcbiAgICAgIHRoaXMub3B0aW9ucy5tYXhEZWxheSxcbiAgICAgIHRoaXMub3B0aW9ucy5iYXNlRGVsYXkgKiAyICoqIGF0dGVtcHRcbiAgICApO1xuICAgIHJldHVybiBkZWxheTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVJldHJ5U3RyYXRlZ3kob3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gbmV3IExpbmVhclJldHJ5U3RyYXRlZ3koe1xuICAgICAgdHlwZTogXCJsaW5lYXJcIixcbiAgICAgIGF0dGVtcHRzOiBvcHRpb25zLFxuICAgICAgZGVsYXk6IDFlM1xuICAgIH0pO1xuICB9XG4gIHN3aXRjaCAob3B0aW9ucy50eXBlKSB7XG4gICAgY2FzZSBcImxpbmVhclwiOlxuICAgICAgcmV0dXJuIG5ldyBMaW5lYXJSZXRyeVN0cmF0ZWd5KG9wdGlvbnMpO1xuICAgIGNhc2UgXCJleHBvbmVudGlhbFwiOlxuICAgICAgcmV0dXJuIG5ldyBFeHBvbmVudGlhbFJldHJ5U3RyYXRlZ3kob3B0aW9ucyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmV0cnkgc3RyYXRlZ3lcIik7XG4gIH1cbn1cblxuLy8gc3JjL2F1dGgudHNcbnZhciBnZXRBdXRoSGVhZGVyID0gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICBjb25zdCBnZXRWYWx1ZSA9IGFzeW5jICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBhd2FpdCB2YWx1ZSgpIDogdmFsdWU7XG4gIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmF1dGgpIHtcbiAgICBpZiAob3B0aW9ucy5hdXRoLnR5cGUgPT09IFwiQmVhcmVyXCIpIHtcbiAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgZ2V0VmFsdWUob3B0aW9ucy5hdXRoLnRva2VuKTtcbiAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgICB9XG4gICAgICBoZWFkZXJzW1wiYXV0aG9yaXphdGlvblwiXSA9IGBCZWFyZXIgJHt0b2tlbn1gO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5hdXRoLnR5cGUgPT09IFwiQmFzaWNcIikge1xuICAgICAgY29uc3QgdXNlcm5hbWUgPSBnZXRWYWx1ZShvcHRpb25zLmF1dGgudXNlcm5hbWUpO1xuICAgICAgY29uc3QgcGFzc3dvcmQgPSBnZXRWYWx1ZShvcHRpb25zLmF1dGgucGFzc3dvcmQpO1xuICAgICAgaWYgKCF1c2VybmFtZSB8fCAhcGFzc3dvcmQpIHtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgICB9XG4gICAgICBoZWFkZXJzW1wiYXV0aG9yaXphdGlvblwiXSA9IGBCYXNpYyAke2J0b2EoYCR7dXNlcm5hbWV9OiR7cGFzc3dvcmR9YCl9YDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYXV0aC50eXBlID09PSBcIkN1c3RvbVwiKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGdldFZhbHVlKG9wdGlvbnMuYXV0aC52YWx1ZSk7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgICAgfVxuICAgICAgaGVhZGVyc1tcImF1dGhvcml6YXRpb25cIl0gPSBgJHtnZXRWYWx1ZShvcHRpb25zLmF1dGgucHJlZml4KX0gJHt2YWx1ZX1gO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGVhZGVycztcbn07XG5cbi8vIHNyYy91dGlscy50c1xudmFyIEpTT05fUkUgPSAvXmFwcGxpY2F0aW9uXFwvKD86W1xcdyEjJCUmKi5eYH4tXSpcXCspP2pzb24oOy4rKT8kL2k7XG5mdW5jdGlvbiBkZXRlY3RSZXNwb25zZVR5cGUocmVxdWVzdCkge1xuICBjb25zdCBfY29udGVudFR5cGUgPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xuICBjb25zdCB0ZXh0VHlwZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gICAgXCJpbWFnZS9zdmdcIixcbiAgICBcImFwcGxpY2F0aW9uL3htbFwiLFxuICAgIFwiYXBwbGljYXRpb24veGh0bWxcIixcbiAgICBcImFwcGxpY2F0aW9uL2h0bWxcIlxuICBdKTtcbiAgaWYgKCFfY29udGVudFR5cGUpIHtcbiAgICByZXR1cm4gXCJqc29uXCI7XG4gIH1cbiAgY29uc3QgY29udGVudFR5cGUgPSBfY29udGVudFR5cGUuc3BsaXQoXCI7XCIpLnNoaWZ0KCkgfHwgXCJcIjtcbiAgaWYgKEpTT05fUkUudGVzdChjb250ZW50VHlwZSkpIHtcbiAgICByZXR1cm4gXCJqc29uXCI7XG4gIH1cbiAgaWYgKHRleHRUeXBlcy5oYXMoY29udGVudFR5cGUpIHx8IGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoXCJ0ZXh0L1wiKSkge1xuICAgIHJldHVybiBcInRleHRcIjtcbiAgfVxuICByZXR1cm4gXCJibG9iXCI7XG59XG5mdW5jdGlvbiBpc0pTT05QYXJzYWJsZSh2YWx1ZSkge1xuICB0cnkge1xuICAgIEpTT04ucGFyc2UodmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gaXNKU09OU2VyaWFsaXphYmxlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHQgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0ID09PSBcInN0cmluZ1wiIHx8IHQgPT09IFwibnVtYmVyXCIgfHwgdCA9PT0gXCJib29sZWFuXCIgfHwgdCA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZS5idWZmZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiT2JqZWN0XCIgfHwgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24ganNvblBhcnNlKHRleHQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxufVxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBnZXRGZXRjaChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmN1c3RvbUZldGNoSW1wbCkge1xuICAgIHJldHVybiBvcHRpb25zLmN1c3RvbUZldGNoSW1wbDtcbiAgfVxuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgJiYgaXNGdW5jdGlvbihnbG9iYWxUaGlzLmZldGNoKSkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLmZldGNoO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIGlzRnVuY3Rpb24od2luZG93LmZldGNoKSkge1xuICAgIHJldHVybiB3aW5kb3cuZmV0Y2g7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZmV0Y2ggaW1wbGVtZW50YXRpb24gZm91bmRcIik7XG59XG5mdW5jdGlvbiBpc1BheWxvYWRNZXRob2QobWV0aG9kKSB7XG4gIGlmICghbWV0aG9kKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHBheWxvYWRNZXRob2QgPSBbXCJQT1NUXCIsIFwiUFVUXCIsIFwiUEFUQ0hcIiwgXCJERUxFVEVcIl07XG4gIHJldHVybiBwYXlsb2FkTWV0aG9kLmluY2x1ZGVzKG1ldGhvZC50b1VwcGVyQ2FzZSgpKTtcbn1cbmZ1bmN0aW9uIGlzUm91dGVNZXRob2QobWV0aG9kKSB7XG4gIGNvbnN0IHJvdXRlTWV0aG9kID0gW1wiR0VUXCIsIFwiUE9TVFwiLCBcIlBVVFwiLCBcIlBBVENIXCIsIFwiREVMRVRFXCJdO1xuICBpZiAoIW1ldGhvZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gcm91dGVNZXRob2QuaW5jbHVkZXMobWV0aG9kLnRvVXBwZXJDYXNlKCkpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0SGVhZGVycyhvcHRzKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmhlYWRlcnMpO1xuICBjb25zdCBhdXRoSGVhZGVyID0gYXdhaXQgZ2V0QXV0aEhlYWRlcihvcHRzKTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXV0aEhlYWRlciB8fCB7fSkpIHtcbiAgICBoZWFkZXJzLnNldChrZXksIHZhbHVlKTtcbiAgfVxuICBpZiAoIWhlYWRlcnMuaGFzKFwiY29udGVudC10eXBlXCIpKSB7XG4gICAgY29uc3QgdCA9IGRldGVjdENvbnRlbnRUeXBlKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuYm9keSk7XG4gICAgaWYgKHQpIHtcbiAgICAgIGhlYWRlcnMuc2V0KFwiY29udGVudC10eXBlXCIsIHQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGVhZGVycztcbn1cbmZ1bmN0aW9uIGdldFVSTCh1cmwsIG9wdGlvbnMpIHtcbiAgaWYgKHVybC5zdGFydHNXaXRoKFwiQFwiKSkge1xuICAgIGNvbnN0IG0gPSB1cmwudG9TdHJpbmcoKS5zcGxpdChcIkBcIilbMV0uc3BsaXQoXCIvXCIpWzBdO1xuICAgIGlmIChtZXRob2RzLmluY2x1ZGVzKG0pKSB7XG4gICAgICB1cmwgPSB1cmwucmVwbGFjZShgQCR7bX0vYCwgXCIvXCIpO1xuICAgIH1cbiAgfVxuICBsZXQgX3VybDtcbiAgdHJ5IHtcbiAgICBpZiAodXJsLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgICBfdXJsID0gdXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgYmFzZVVSTCA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuYmFzZVVSTDtcbiAgICAgIGlmIChiYXNlVVJMICYmICEoYmFzZVVSTCA9PSBudWxsID8gdm9pZCAwIDogYmFzZVVSTC5lbmRzV2l0aChcIi9cIikpKSB7XG4gICAgICAgIGJhc2VVUkwgPSBiYXNlVVJMICsgXCIvXCI7XG4gICAgICB9XG4gICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgIF91cmwgPSBuZXcgVVJMKHVybC5zdWJzdHJpbmcoMSksIGJhc2VVUkwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3VybCA9IG5ldyBVUkwodXJsLCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmJhc2VVUkwpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICBpZiAoIShvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmJhc2VVUkwpKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcbiAgICAgICAgICBgSW52YWxpZCBVUkwgJHt1cmx9LiBBcmUgeW91IHBhc3NpbmcgaW4gYSByZWxhdGl2ZSB1cmwgYnV0IG5vdCBzZXR0aW5nIHRoZSBiYXNlVVJMP2BcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRocm93IFR5cGVFcnJvcihcbiAgICAgICAgYEludmFsaWQgVVJMICR7dXJsfS4gUGxlYXNlIHZhbGlkYXRlIHRoYXQgeW91IGFyZSBwYXNzaW5nIHRoZSBjb3JyZWN0IGlucHV0LmBcbiAgICAgICk7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyYW1zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wYXJhbXMpKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wYXJhbXMpID8gQXJyYXkuaXNBcnJheShvcHRpb25zLnBhcmFtcykgPyBgLyR7b3B0aW9ucy5wYXJhbXMuam9pbihcIi9cIil9YCA6IGAvJHtPYmplY3QudmFsdWVzKG9wdGlvbnMucGFyYW1zKS5qb2luKFwiL1wiKX1gIDogXCJcIjtcbiAgICAgIF91cmwgPSBfdXJsLnRvU3RyaW5nKCkuc3BsaXQoXCIvOlwiKVswXTtcbiAgICAgIF91cmwgPSBgJHtfdXJsLnRvU3RyaW5nKCl9JHtwYXJhbXN9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wYXJhbXMpKSB7XG4gICAgICAgIF91cmwgPSBfdXJsLnRvU3RyaW5nKCkucmVwbGFjZShgOiR7a2V5fWAsIFN0cmluZyh2YWx1ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBfX3VybCA9IG5ldyBVUkwoX3VybCk7XG4gIGNvbnN0IHF1ZXJ5UGFyYW1zID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5xdWVyeTtcbiAgaWYgKHF1ZXJ5UGFyYW1zKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocXVlcnlQYXJhbXMpKSB7XG4gICAgICBfX3VybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgU3RyaW5nKHZhbHVlKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBfX3VybDtcbn1cbmZ1bmN0aW9uIGRldGVjdENvbnRlbnRUeXBlKGJvZHkpIHtcbiAgaWYgKGlzSlNPTlNlcmlhbGl6YWJsZShib2R5KSkge1xuICAgIHJldHVybiBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldEJvZHkob3B0aW9ucykge1xuICBpZiAoIShvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmJvZHkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycyk7XG4gIGlmIChpc0pTT05TZXJpYWxpemFibGUob3B0aW9ucy5ib2R5KSAmJiAhaGVhZGVycy5oYXMoXCJjb250ZW50LXR5cGVcIikpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmJvZHkpKSB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIG9wdGlvbnMuYm9keVtrZXldID0gdmFsdWUudG9JU09TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuYm9keSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnMuYm9keTtcbn1cbmZ1bmN0aW9uIGdldE1ldGhvZCh1cmwsIG9wdGlvbnMpIHtcbiAgdmFyIF9hO1xuICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5tZXRob2QpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5tZXRob2QudG9VcHBlckNhc2UoKTtcbiAgfVxuICBpZiAodXJsLnN0YXJ0c1dpdGgoXCJAXCIpKSB7XG4gICAgY29uc3QgcE1ldGhvZCA9IChfYSA9IHVybC5zcGxpdChcIkBcIilbMV0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5zcGxpdChcIi9cIilbMF07XG4gICAgaWYgKCFtZXRob2RzLmluY2x1ZGVzKHBNZXRob2QpKSB7XG4gICAgICByZXR1cm4gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuYm9keSkgPyBcIlBPU1RcIiA6IFwiR0VUXCI7XG4gICAgfVxuICAgIHJldHVybiBwTWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gIH1cbiAgcmV0dXJuIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmJvZHkpID8gXCJQT1NUXCIgOiBcIkdFVFwiO1xufVxuZnVuY3Rpb24gZ2V0VGltZW91dChvcHRpb25zLCBjb250cm9sbGVyKSB7XG4gIGxldCBhYm9ydFRpbWVvdXQ7XG4gIGlmICghKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbmFsKSAmJiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50aW1lb3V0KSkge1xuICAgIGFib3J0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5hYm9ydCgpLCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnRpbWVvdXQpO1xuICB9XG4gIHJldHVybiB7XG4gICAgYWJvcnRUaW1lb3V0LFxuICAgIGNsZWFyVGltZW91dDogKCkgPT4ge1xuICAgICAgaWYgKGFib3J0VGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoYWJvcnRUaW1lb3V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBib2R5UGFyc2VyKGRhdGEsIHJlc3BvbnNlVHlwZSkge1xuICBpZiAocmVzcG9uc2VUeXBlID09PSBcImpzb25cIikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxudmFyIFZhbGlkYXRpb25FcnJvciA9IGNsYXNzIF9WYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGlzc3VlcywgbWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UgfHwgSlNPTi5zdHJpbmdpZnkoaXNzdWVzLCBudWxsLCAyKSk7XG4gICAgdGhpcy5pc3N1ZXMgPSBpc3N1ZXM7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIF9WYWxpZGF0aW9uRXJyb3IucHJvdG90eXBlKTtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIHBhcnNlU3RhbmRhcmRTY2hlbWEoc2NoZW1hLCBpbnB1dCkge1xuICBsZXQgcmVzdWx0ID0gYXdhaXQgc2NoZW1hW1wifnN0YW5kYXJkXCJdLnZhbGlkYXRlKGlucHV0KTtcbiAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKHJlc3VsdC5pc3N1ZXMpO1xuICB9XG4gIHJldHVybiByZXN1bHQudmFsdWU7XG59XG5cbi8vIHNyYy9jcmVhdGUtZmV0Y2gvc2NoZW1hLnRzXG52YXIgbWV0aG9kcyA9IFtcImdldFwiLCBcInBvc3RcIiwgXCJwdXRcIiwgXCJwYXRjaFwiLCBcImRlbGV0ZVwiXTtcbnZhciBjcmVhdGVTY2hlbWEgPSAoc2NoZW1hLCBjb25maWcpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBzY2hlbWEsXG4gICAgY29uZmlnXG4gIH07XG59O1xuXG4vLyBzcmMvY3JlYXRlLWZldGNoL2luZGV4LnRzXG52YXIgYXBwbHlTY2hlbWFQbHVnaW4gPSAoY29uZmlnKSA9PiAoe1xuICBpZDogXCJhcHBseS1zY2hlbWFcIixcbiAgbmFtZTogXCJBcHBseSBTY2hlbWFcIixcbiAgdmVyc2lvbjogXCIxLjAuMFwiLFxuICBhc3luYyBpbml0KHVybCwgb3B0aW9ucykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBjb25zdCBzY2hlbWEgPSAoKF9iID0gKF9hID0gY29uZmlnLnBsdWdpbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5maW5kKFxuICAgICAgKHBsdWdpbikgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICByZXR1cm4gKChfYTIgPSBwbHVnaW4uc2NoZW1hKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNvbmZpZykgPyB1cmwuc3RhcnRzV2l0aChwbHVnaW4uc2NoZW1hLmNvbmZpZy5iYXNlVVJMIHx8IFwiXCIpIHx8IHVybC5zdGFydHNXaXRoKHBsdWdpbi5zY2hlbWEuY29uZmlnLnByZWZpeCB8fCBcIlwiKSA6IGZhbHNlO1xuICAgICAgfVxuICAgICkpID09IG51bGwgPyB2b2lkIDAgOiBfYi5zY2hlbWEpIHx8IGNvbmZpZy5zY2hlbWE7XG4gICAgaWYgKHNjaGVtYSkge1xuICAgICAgbGV0IHVybEtleSA9IHVybDtcbiAgICAgIGlmICgoX2MgPSBzY2hlbWEuY29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogX2MucHJlZml4KSB7XG4gICAgICAgIGlmICh1cmxLZXkuc3RhcnRzV2l0aChzY2hlbWEuY29uZmlnLnByZWZpeCkpIHtcbiAgICAgICAgICB1cmxLZXkgPSB1cmxLZXkucmVwbGFjZShzY2hlbWEuY29uZmlnLnByZWZpeCwgXCJcIik7XG4gICAgICAgICAgaWYgKHNjaGVtYS5jb25maWcuYmFzZVVSTCkge1xuICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2Uoc2NoZW1hLmNvbmZpZy5wcmVmaXgsIHNjaGVtYS5jb25maWcuYmFzZVVSTCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoKF9kID0gc2NoZW1hLmNvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmJhc2VVUkwpIHtcbiAgICAgICAgaWYgKHVybEtleS5zdGFydHNXaXRoKHNjaGVtYS5jb25maWcuYmFzZVVSTCkpIHtcbiAgICAgICAgICB1cmxLZXkgPSB1cmxLZXkucmVwbGFjZShzY2hlbWEuY29uZmlnLmJhc2VVUkwsIFwiXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBrZXlTY2hlbWEgPSBzY2hlbWEuc2NoZW1hW3VybEtleV07XG4gICAgICBpZiAoa2V5U2NoZW1hKSB7XG4gICAgICAgIGxldCBvcHRzID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgICAgICBtZXRob2Q6IGtleVNjaGVtYS5tZXRob2QsXG4gICAgICAgICAgb3V0cHV0OiBrZXlTY2hlbWEub3V0cHV0XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIShvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRpc2FibGVWYWxpZGF0aW9uKSkge1xuICAgICAgICAgIG9wdHMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRzKSwge1xuICAgICAgICAgICAgYm9keToga2V5U2NoZW1hLmlucHV0ID8gYXdhaXQgcGFyc2VTdGFuZGFyZFNjaGVtYShrZXlTY2hlbWEuaW5wdXQsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuYm9keSkgOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmJvZHksXG4gICAgICAgICAgICBwYXJhbXM6IGtleVNjaGVtYS5wYXJhbXMgPyBhd2FpdCBwYXJzZVN0YW5kYXJkU2NoZW1hKGtleVNjaGVtYS5wYXJhbXMsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyYW1zKSA6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyYW1zLFxuICAgICAgICAgICAgcXVlcnk6IGtleVNjaGVtYS5xdWVyeSA/IGF3YWl0IHBhcnNlU3RhbmRhcmRTY2hlbWEoa2V5U2NoZW1hLnF1ZXJ5LCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnF1ZXJ5KSA6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucXVlcnlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICBvcHRpb25zOiBvcHRzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB1cmwsXG4gICAgICBvcHRpb25zXG4gICAgfTtcbiAgfVxufSk7XG52YXIgY3JlYXRlRmV0Y2ggPSAoY29uZmlnKSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uICRmZXRjaCh1cmwsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRzID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgY29uZmlnKSwgb3B0aW9ucyksIHtcbiAgICAgIHBsdWdpbnM6IFsuLi4oY29uZmlnID09IG51bGwgPyB2b2lkIDAgOiBjb25maWcucGx1Z2lucykgfHwgW10sIGFwcGx5U2NoZW1hUGx1Z2luKGNvbmZpZyB8fCB7fSldXG4gICAgfSk7XG4gICAgaWYgKGNvbmZpZyA9PSBudWxsID8gdm9pZCAwIDogY29uZmlnLmNhdGNoQWxsRXJyb3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBiZXR0ZXJGZXRjaCh1cmwsIG9wdHMpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IFwiRmV0Y2ggRXJyb3JcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiRmV0Y2ggcmVsYXRlZCBlcnJvci4gQ2FwdHVyZWQgYnkgY2F0Y2hBbGxFcnJvciBvcHRpb24uIFNlZSBlcnJvciBwcm9wZXJ0eSBmb3IgbW9yZSBkZXRhaWxzLlwiLFxuICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBiZXR0ZXJGZXRjaCh1cmwsIG9wdHMpO1xuICB9XG4gIHJldHVybiAkZmV0Y2g7XG59O1xuXG4vLyBzcmMvdXJsLnRzXG5mdW5jdGlvbiBnZXRVUkwyKHVybCwgb3B0aW9uKSB7XG4gIGxldCB7IGJhc2VVUkwsIHBhcmFtcywgcXVlcnkgfSA9IG9wdGlvbiB8fCB7XG4gICAgcXVlcnk6IHt9LFxuICAgIHBhcmFtczoge30sXG4gICAgYmFzZVVSTDogXCJcIlxuICB9O1xuICBsZXQgYmFzZVBhdGggPSB1cmwuc3RhcnRzV2l0aChcImh0dHBcIikgPyB1cmwuc3BsaXQoXCIvXCIpLnNsaWNlKDAsIDMpLmpvaW4oXCIvXCIpIDogYmFzZVVSTCB8fCBcIlwiO1xuICBpZiAodXJsLnN0YXJ0c1dpdGgoXCJAXCIpKSB7XG4gICAgY29uc3QgbSA9IHVybC50b1N0cmluZygpLnNwbGl0KFwiQFwiKVsxXS5zcGxpdChcIi9cIilbMF07XG4gICAgaWYgKG1ldGhvZHMuaW5jbHVkZXMobSkpIHtcbiAgICAgIHVybCA9IHVybC5yZXBsYWNlKGBAJHttfS9gLCBcIi9cIik7XG4gICAgfVxuICB9XG4gIGlmICghYmFzZVBhdGguZW5kc1dpdGgoXCIvXCIpKSBiYXNlUGF0aCArPSBcIi9cIjtcbiAgbGV0IFtwYXRoLCB1cmxRdWVyeV0gPSB1cmwucmVwbGFjZShiYXNlUGF0aCwgXCJcIikuc3BsaXQoXCI/XCIpO1xuICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXModXJsUXVlcnkpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhxdWVyeSB8fCB7fSkpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgY29udGludWU7XG4gICAgcXVlcnlQYXJhbXMuc2V0KGtleSwgU3RyaW5nKHZhbHVlKSk7XG4gIH1cbiAgaWYgKHBhcmFtcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICAgIGNvbnN0IHBhcmFtUGF0aHMgPSBwYXRoLnNwbGl0KFwiL1wiKS5maWx0ZXIoKHApID0+IHAuc3RhcnRzV2l0aChcIjpcIikpO1xuICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGtleV0gb2YgcGFyYW1QYXRocy5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXNbaW5kZXhdO1xuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbXMpKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoYDoke2tleX1gLCBTdHJpbmcodmFsdWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGF0aCA9IHBhdGguc3BsaXQoXCIvXCIpLm1hcChlbmNvZGVVUklDb21wb25lbnQpLmpvaW4oXCIvXCIpO1xuICBpZiAocGF0aC5zdGFydHNXaXRoKFwiL1wiKSkgcGF0aCA9IHBhdGguc2xpY2UoMSk7XG4gIGxldCBxdWVyeVBhcmFtU3RyaW5nID0gcXVlcnlQYXJhbXMudG9TdHJpbmcoKTtcbiAgcXVlcnlQYXJhbVN0cmluZyA9IHF1ZXJ5UGFyYW1TdHJpbmcubGVuZ3RoID4gMCA/IGA/JHtxdWVyeVBhcmFtU3RyaW5nfWAucmVwbGFjZSgvXFwrL2csIFwiJTIwXCIpIDogXCJcIjtcbiAgaWYgKCFiYXNlUGF0aC5zdGFydHNXaXRoKFwiaHR0cFwiKSkge1xuICAgIHJldHVybiBgJHtiYXNlUGF0aH0ke3BhdGh9JHtxdWVyeVBhcmFtU3RyaW5nfWA7XG4gIH1cbiAgY29uc3QgX3VybCA9IG5ldyBVUkwoYCR7cGF0aH0ke3F1ZXJ5UGFyYW1TdHJpbmd9YCwgYmFzZVBhdGgpO1xuICByZXR1cm4gX3VybDtcbn1cblxuLy8gc3JjL2ZldGNoLnRzXG52YXIgYmV0dGVyRmV0Y2ggPSBhc3luYyAodXJsLCBvcHRpb25zKSA9PiB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gIGNvbnN0IHtcbiAgICBob29rcyxcbiAgICB1cmw6IF9fdXJsLFxuICAgIG9wdGlvbnM6IG9wdHNcbiAgfSA9IGF3YWl0IGluaXRpYWxpemVQbHVnaW5zKHVybCwgb3B0aW9ucyk7XG4gIGNvbnN0IGZldGNoID0gZ2V0RmV0Y2gob3B0cyk7XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gIGNvbnN0IHNpZ25hbCA9IChfYSA9IG9wdHMuc2lnbmFsKSAhPSBudWxsID8gX2EgOiBjb250cm9sbGVyLnNpZ25hbDtcbiAgY29uc3QgX3VybCA9IGdldFVSTDIoX191cmwsIG9wdHMpO1xuICBjb25zdCBib2R5ID0gZ2V0Qm9keShvcHRzKTtcbiAgY29uc3QgaGVhZGVycyA9IGF3YWl0IGdldEhlYWRlcnMob3B0cyk7XG4gIGNvbnN0IG1ldGhvZCA9IGdldE1ldGhvZChfX3VybCwgb3B0cyk7XG4gIGxldCBjb250ZXh0ID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0cyksIHtcbiAgICB1cmw6IF91cmwsXG4gICAgaGVhZGVycyxcbiAgICBib2R5LFxuICAgIG1ldGhvZCxcbiAgICBzaWduYWxcbiAgfSk7XG4gIGZvciAoY29uc3Qgb25SZXF1ZXN0IG9mIGhvb2tzLm9uUmVxdWVzdCkge1xuICAgIGlmIChvblJlcXVlc3QpIHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IG9uUmVxdWVzdChjb250ZXh0KTtcbiAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgY29udGV4dCA9IHJlcztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKFwicGlwZVRvXCIgaW4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5waXBlVG8gPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgKChfYiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuYm9keSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnBpcGUpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBpZiAoIShcImR1cGxleFwiIGluIGNvbnRleHQpKSB7XG4gICAgICBjb250ZXh0LmR1cGxleCA9IFwiaGFsZlwiO1xuICAgIH1cbiAgfVxuICBjb25zdCB7IGNsZWFyVGltZW91dDogY2xlYXJUaW1lb3V0MiB9ID0gZ2V0VGltZW91dChvcHRzLCBjb250cm9sbGVyKTtcbiAgbGV0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goY29udGV4dC51cmwsIGNvbnRleHQpO1xuICBjbGVhclRpbWVvdXQyKCk7XG4gIGNvbnN0IHJlc3BvbnNlQ29udGV4dCA9IHtcbiAgICByZXNwb25zZSxcbiAgICByZXF1ZXN0OiBjb250ZXh0XG4gIH07XG4gIGZvciAoY29uc3Qgb25SZXNwb25zZSBvZiBob29rcy5vblJlc3BvbnNlKSB7XG4gICAgaWYgKG9uUmVzcG9uc2UpIHtcbiAgICAgIGNvbnN0IHIgPSBhd2FpdCBvblJlc3BvbnNlKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHJlc3BvbnNlQ29udGV4dCksIHtcbiAgICAgICAgcmVzcG9uc2U6ICgoX2MgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmhvb2tPcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2xvbmVSZXNwb25zZSkgPyByZXNwb25zZS5jbG9uZSgpIDogcmVzcG9uc2VcbiAgICAgIH0pKTtcbiAgICAgIGlmIChyIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgcmVzcG9uc2UgPSByO1xuICAgICAgfSBlbHNlIGlmIChyIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIHJlc3BvbnNlID0gci5yZXNwb25zZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgY29uc3QgaGFzQm9keSA9IGNvbnRleHQubWV0aG9kICE9PSBcIkhFQURcIjtcbiAgICBpZiAoIWhhc0JvZHkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IFwiXCIsXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZVR5cGUgPSBkZXRlY3RSZXNwb25zZVR5cGUocmVzcG9uc2UpO1xuICAgIGNvbnN0IHN1Y2Nlc3NDb250ZXh0ID0ge1xuICAgICAgZGF0YTogXCJcIixcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgcmVxdWVzdDogY29udGV4dFxuICAgIH07XG4gICAgaWYgKHJlc3BvbnNlVHlwZSA9PT0gXCJqc29uXCIgfHwgcmVzcG9uc2VUeXBlID09PSBcInRleHRcIikge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIGNvbnN0IHBhcnNlcjIgPSAoX2QgPSBjb250ZXh0Lmpzb25QYXJzZXIpICE9IG51bGwgPyBfZCA6IGpzb25QYXJzZTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwYXJzZXIyKHRleHQpO1xuICAgICAgc3VjY2Vzc0NvbnRleHQuZGF0YSA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1Y2Nlc3NDb250ZXh0LmRhdGEgPSBhd2FpdCByZXNwb25zZVtyZXNwb25zZVR5cGVdKCk7XG4gICAgfVxuICAgIGlmIChjb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZXh0Lm91dHB1dCkge1xuICAgICAgaWYgKGNvbnRleHQub3V0cHV0ICYmICFjb250ZXh0LmRpc2FibGVWYWxpZGF0aW9uKSB7XG4gICAgICAgIHN1Y2Nlc3NDb250ZXh0LmRhdGEgPSBhd2FpdCBwYXJzZVN0YW5kYXJkU2NoZW1hKFxuICAgICAgICAgIGNvbnRleHQub3V0cHV0LFxuICAgICAgICAgIHN1Y2Nlc3NDb250ZXh0LmRhdGFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBvblN1Y2Nlc3Mgb2YgaG9va3Mub25TdWNjZXNzKSB7XG4gICAgICBpZiAob25TdWNjZXNzKSB7XG4gICAgICAgIGF3YWl0IG9uU3VjY2VzcyhfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBzdWNjZXNzQ29udGV4dCksIHtcbiAgICAgICAgICByZXNwb25zZTogKChfZSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaG9va09wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfZS5jbG9uZVJlc3BvbnNlKSA/IHJlc3BvbnNlLmNsb25lKCkgOiByZXNwb25zZVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnRocm93KSB7XG4gICAgICByZXR1cm4gc3VjY2Vzc0NvbnRleHQuZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHN1Y2Nlc3NDb250ZXh0LmRhdGEsXG4gICAgICBlcnJvcjogbnVsbFxuICAgIH07XG4gIH1cbiAgY29uc3QgcGFyc2VyID0gKF9mID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5qc29uUGFyc2VyKSAhPSBudWxsID8gX2YgOiBqc29uUGFyc2U7XG4gIGNvbnN0IHJlc3BvbnNlVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgY29uc3QgaXNKU09OUmVzcG9uc2UgPSBpc0pTT05QYXJzYWJsZShyZXNwb25zZVRleHQpO1xuICBjb25zdCBlcnJvck9iamVjdCA9IGlzSlNPTlJlc3BvbnNlID8gYXdhaXQgcGFyc2VyKHJlc3BvbnNlVGV4dCkgOiBudWxsO1xuICBjb25zdCBlcnJvckNvbnRleHQgPSB7XG4gICAgcmVzcG9uc2UsXG4gICAgcmVzcG9uc2VUZXh0LFxuICAgIHJlcXVlc3Q6IGNvbnRleHQsXG4gICAgZXJyb3I6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGVycm9yT2JqZWN0KSwge1xuICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0XG4gICAgfSlcbiAgfTtcbiAgZm9yIChjb25zdCBvbkVycm9yIG9mIGhvb2tzLm9uRXJyb3IpIHtcbiAgICBpZiAob25FcnJvcikge1xuICAgICAgYXdhaXQgb25FcnJvcihfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBlcnJvckNvbnRleHQpLCB7XG4gICAgICAgIHJlc3BvbnNlOiAoKF9nID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5ob29rT3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLmNsb25lUmVzcG9uc2UpID8gcmVzcG9uc2UuY2xvbmUoKSA6IHJlc3BvbnNlXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnJldHJ5KSB7XG4gICAgY29uc3QgcmV0cnlTdHJhdGVneSA9IGNyZWF0ZVJldHJ5U3RyYXRlZ3kob3B0aW9ucy5yZXRyeSk7XG4gICAgY29uc3QgX3JldHJ5QXR0ZW1wdCA9IChfaCA9IG9wdGlvbnMucmV0cnlBdHRlbXB0KSAhPSBudWxsID8gX2ggOiAwO1xuICAgIGlmIChhd2FpdCByZXRyeVN0cmF0ZWd5LnNob3VsZEF0dGVtcHRSZXRyeShfcmV0cnlBdHRlbXB0LCByZXNwb25zZSkpIHtcbiAgICAgIGZvciAoY29uc3Qgb25SZXRyeSBvZiBob29rcy5vblJldHJ5KSB7XG4gICAgICAgIGlmIChvblJldHJ5KSB7XG4gICAgICAgICAgYXdhaXQgb25SZXRyeShyZXNwb25zZUNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBkZWxheSA9IHJldHJ5U3RyYXRlZ3kuZ2V0RGVsYXkoX3JldHJ5QXR0ZW1wdCk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICAgICAgcmV0dXJuIGF3YWl0IGJldHRlckZldGNoKHVybCwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgICAgcmV0cnlBdHRlbXB0OiBfcmV0cnlBdHRlbXB0ICsgMVxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50aHJvdykge1xuICAgIHRocm93IG5ldyBCZXR0ZXJGZXRjaEVycm9yKFxuICAgICAgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgIGlzSlNPTlJlc3BvbnNlID8gZXJyb3JPYmplY3QgOiByZXNwb25zZVRleHRcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF0YTogbnVsbCxcbiAgICBlcnJvcjogX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgZXJyb3JPYmplY3QpLCB7XG4gICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICB9KVxuICB9O1xufTtcbmV4cG9ydCB7XG4gIEJldHRlckZldGNoRXJyb3IsXG4gIFZhbGlkYXRpb25FcnJvcixcbiAgYXBwbHlTY2hlbWFQbHVnaW4sXG4gIGJldHRlckZldGNoLFxuICBib2R5UGFyc2VyLFxuICBjcmVhdGVGZXRjaCxcbiAgY3JlYXRlUmV0cnlTdHJhdGVneSxcbiAgY3JlYXRlU2NoZW1hLFxuICBkZXRlY3RDb250ZW50VHlwZSxcbiAgZGV0ZWN0UmVzcG9uc2VUeXBlLFxuICBnZXRCb2R5LFxuICBnZXRGZXRjaCxcbiAgZ2V0SGVhZGVycyxcbiAgZ2V0TWV0aG9kLFxuICBnZXRUaW1lb3V0LFxuICBnZXRVUkwsXG4gIGluaXRpYWxpemVQbHVnaW5zLFxuICBpc0Z1bmN0aW9uLFxuICBpc0pTT05QYXJzYWJsZSxcbiAgaXNKU09OU2VyaWFsaXphYmxlLFxuICBpc1BheWxvYWRNZXRob2QsXG4gIGlzUm91dGVNZXRob2QsXG4gIGpzb25QYXJzZSxcbiAgbWV0aG9kcyxcbiAgcGFyc2VTdGFuZGFyZFNjaGVtYVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@better-fetch/fetch/dist/index.js\n");

/***/ })

};
;