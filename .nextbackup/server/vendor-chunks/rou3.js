"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rou3";
exports.ids = ["vendor-chunks/rou3"];
exports.modules = {

/***/ "(rsc)/./node_modules/rou3/dist/index.mjs":
/*!******************************************!*\
  !*** ./node_modules/rou3/dist/index.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addRoute: () => (/* binding */ addRoute),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   findAllRoutes: () => (/* binding */ findAllRoutes),\n/* harmony export */   findRoute: () => (/* binding */ findRoute),\n/* harmony export */   removeRoute: () => (/* binding */ removeRoute)\n/* harmony export */ });\nconst EmptyObject = /* @__PURE__ */ (() => {\n  const C = function() {\n  };\n  C.prototype = /* @__PURE__ */ Object.create(null);\n  return C;\n})();\n\nfunction createRouter() {\n  const ctx = {\n    root: { key: \"\" },\n    static: new EmptyObject()\n  };\n  return ctx;\n}\n\nfunction splitPath(path) {\n  return path.split(\"/\").filter(Boolean);\n}\nfunction getMatchParams(segments, paramsMap) {\n  const params = new EmptyObject();\n  for (const [index, name] of paramsMap) {\n    const segment = index < 0 ? segments.slice(-1 * index).join(\"/\") : segments[index];\n    if (typeof name === \"string\") {\n      params[name] = segment;\n    } else {\n      const match = segment.match(name);\n      if (match) {\n        for (const key in match.groups) {\n          params[key] = match.groups[key];\n        }\n      }\n    }\n  }\n  return params;\n}\n\nfunction addRoute(ctx, method = \"\", path, data) {\n  const segments = splitPath(path);\n  let node = ctx.root;\n  let _unnamedParamIndex = 0;\n  const paramsMap = [];\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    if (segment.startsWith(\"**\")) {\n      if (!node.wildcard) {\n        node.wildcard = { key: \"**\" };\n      }\n      node = node.wildcard;\n      paramsMap.push([\n        -i,\n        segment.split(\":\")[1] || \"_\",\n        segment.length === 2\n      ]);\n      break;\n    }\n    if (segment === \"*\" || segment.includes(\":\")) {\n      if (!node.param) {\n        node.param = { key: \"*\" };\n      }\n      node = node.param;\n      const isOptional = segment === \"*\";\n      paramsMap.push([\n        i,\n        isOptional ? `_${_unnamedParamIndex++}` : _getParamMatcher(segment),\n        isOptional\n      ]);\n      continue;\n    }\n    const child = node.static?.[segment];\n    if (child) {\n      node = child;\n    } else {\n      const staticNode = { key: segment };\n      if (!node.static) {\n        node.static = new EmptyObject();\n      }\n      node.static[segment] = staticNode;\n      node = staticNode;\n    }\n  }\n  const hasParams = paramsMap.length > 0;\n  if (!node.methods) {\n    node.methods = new EmptyObject();\n  }\n  if (!node.methods[method]) {\n    node.methods[method] = [];\n  }\n  node.methods[method].push({\n    data: data || null,\n    paramsMap: hasParams ? paramsMap : void 0\n  });\n  if (!hasParams) {\n    ctx.static[path] = node;\n  }\n}\nfunction _getParamMatcher(segment) {\n  if (!segment.includes(\":\", 1)) {\n    return segment.slice(1);\n  }\n  const regex = segment.replace(/:(\\w+)/g, (_, id) => `(?<${id}>\\\\w+)`);\n  return new RegExp(`^${regex}$`);\n}\n\nfunction findRoute(ctx, method = \"\", path, opts) {\n  if (path[path.length - 1] === \"/\") {\n    path = path.slice(0, -1);\n  }\n  const staticNode = ctx.static[path];\n  if (staticNode && staticNode.methods) {\n    const staticMatch = staticNode.methods[method] || staticNode.methods[\"\"];\n    if (staticMatch !== void 0) {\n      return staticMatch[0];\n    }\n  }\n  const segments = splitPath(path);\n  const match = _lookupTree(ctx, ctx.root, method, segments, 0)?.[0];\n  if (match === void 0) {\n    return;\n  }\n  if (opts?.params === false) {\n    return match;\n  }\n  return {\n    data: match.data,\n    params: match.paramsMap ? getMatchParams(segments, match.paramsMap) : void 0\n  };\n}\nfunction _lookupTree(ctx, node, method, segments, index) {\n  if (index === segments.length) {\n    if (node.methods) {\n      const match = node.methods[method] || node.methods[\"\"];\n      if (match) {\n        return match;\n      }\n    }\n    if (node.param && node.param.methods) {\n      const match = node.param.methods[method] || node.param.methods[\"\"];\n      if (match) {\n        const pMap = match[0].paramsMap;\n        if (pMap?.[pMap?.length - 1]?.[2]) {\n          return match;\n        }\n      }\n    }\n    if (node.wildcard && node.wildcard.methods) {\n      const match = node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n      if (match) {\n        const pMap = match[0].paramsMap;\n        if (pMap?.[pMap?.length - 1]?.[2]) {\n          return match;\n        }\n      }\n    }\n    return void 0;\n  }\n  const segment = segments[index];\n  if (node.static) {\n    const staticChild = node.static[segment];\n    if (staticChild) {\n      const match = _lookupTree(ctx, staticChild, method, segments, index + 1);\n      if (match) {\n        return match;\n      }\n    }\n  }\n  if (node.param) {\n    const match = _lookupTree(ctx, node.param, method, segments, index + 1);\n    if (match) {\n      return match;\n    }\n  }\n  if (node.wildcard && node.wildcard.methods) {\n    return node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n  }\n  return;\n}\n\nfunction removeRoute(ctx, method, path) {\n  const segments = splitPath(path);\n  return _remove(ctx.root, method || \"\", segments, 0);\n}\nfunction _remove(node, method, segments, index) {\n  if (index === segments.length) {\n    if (node.methods && method in node.methods) {\n      delete node.methods[method];\n      if (Object.keys(node.methods).length === 0) {\n        node.methods = void 0;\n      }\n    }\n    return;\n  }\n  const segment = segments[index];\n  if (segment === \"*\") {\n    if (node.param) {\n      _remove(node.param, method, segments, index + 1);\n      if (_isEmptyNode(node.param)) {\n        node.param = void 0;\n      }\n    }\n    return;\n  }\n  if (segment === \"**\") {\n    if (node.wildcard) {\n      _remove(node.wildcard, method, segments, index + 1);\n      if (_isEmptyNode(node.wildcard)) {\n        node.wildcard = void 0;\n      }\n    }\n    return;\n  }\n  const childNode = node.static?.[segment];\n  if (childNode) {\n    _remove(childNode, method, segments, index + 1);\n    if (_isEmptyNode(childNode)) {\n      delete node.static[segment];\n      if (Object.keys(node.static).length === 0) {\n        node.static = void 0;\n      }\n    }\n  }\n}\nfunction _isEmptyNode(node) {\n  return node.methods === void 0 && node.static === void 0 && node.param === void 0 && node.wildcard === void 0;\n}\n\nfunction findAllRoutes(ctx, method = \"\", path, opts) {\n  if (path[path.length - 1] === \"/\") {\n    path = path.slice(0, -1);\n  }\n  const segments = splitPath(path);\n  const matches = _findAll(ctx, ctx.root, method, segments, 0);\n  if (opts?.params === false) {\n    return matches;\n  }\n  return matches.map((m) => {\n    return {\n      data: m.data,\n      params: m.paramsMap ? getMatchParams(segments, m.paramsMap) : void 0\n    };\n  });\n}\nfunction _findAll(ctx, node, method, segments, index, matches = []) {\n  const segment = segments[index];\n  if (node.wildcard && node.wildcard.methods) {\n    const match = node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n    if (match) {\n      matches.push(...match);\n    }\n  }\n  if (node.param) {\n    _findAll(ctx, node.param, method, segments, index + 1, matches);\n    if (index === segments.length && node.param.methods) {\n      const match = node.param.methods[method] || node.param.methods[\"\"];\n      if (match) {\n        matches.push(...match);\n      }\n    }\n  }\n  const staticChild = node.static?.[segment];\n  if (staticChild) {\n    _findAll(ctx, staticChild, method, segments, index + 1, matches);\n  }\n  if (index === segments.length && node.methods) {\n    const match = node.methods[method] || node.methods[\"\"];\n    if (match) {\n      matches.push(...match);\n    }\n  }\n  return matches;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcm91My9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsR0FBRztBQUMvRCx3QkFBd0IsTUFBTTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5RSIsInNvdXJjZXMiOlsid2VicGFjazovL2F1dG9wbGFuY2FtLy4vbm9kZV9tb2R1bGVzL3JvdTMvZGlzdC9pbmRleC5tanM/MWViYyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBFbXB0eU9iamVjdCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICBjb25zdCBDID0gZnVuY3Rpb24oKSB7XG4gIH07XG4gIEMucHJvdG90eXBlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiBDO1xufSkoKTtcblxuZnVuY3Rpb24gY3JlYXRlUm91dGVyKCkge1xuICBjb25zdCBjdHggPSB7XG4gICAgcm9vdDogeyBrZXk6IFwiXCIgfSxcbiAgICBzdGF0aWM6IG5ldyBFbXB0eU9iamVjdCgpXG4gIH07XG4gIHJldHVybiBjdHg7XG59XG5cbmZ1bmN0aW9uIHNwbGl0UGF0aChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnNwbGl0KFwiL1wiKS5maWx0ZXIoQm9vbGVhbik7XG59XG5mdW5jdGlvbiBnZXRNYXRjaFBhcmFtcyhzZWdtZW50cywgcGFyYW1zTWFwKSB7XG4gIGNvbnN0IHBhcmFtcyA9IG5ldyBFbXB0eU9iamVjdCgpO1xuICBmb3IgKGNvbnN0IFtpbmRleCwgbmFtZV0gb2YgcGFyYW1zTWFwKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IGluZGV4IDwgMCA/IHNlZ21lbnRzLnNsaWNlKC0xICogaW5kZXgpLmpvaW4oXCIvXCIpIDogc2VnbWVudHNbaW5kZXhdO1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcGFyYW1zW25hbWVdID0gc2VnbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWF0Y2ggPSBzZWdtZW50Lm1hdGNoKG5hbWUpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG1hdGNoLmdyb3Vwcykge1xuICAgICAgICAgIHBhcmFtc1trZXldID0gbWF0Y2guZ3JvdXBzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuZnVuY3Rpb24gYWRkUm91dGUoY3R4LCBtZXRob2QgPSBcIlwiLCBwYXRoLCBkYXRhKSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gc3BsaXRQYXRoKHBhdGgpO1xuICBsZXQgbm9kZSA9IGN0eC5yb290O1xuICBsZXQgX3VubmFtZWRQYXJhbUluZGV4ID0gMDtcbiAgY29uc3QgcGFyYW1zTWFwID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgaWYgKHNlZ21lbnQuc3RhcnRzV2l0aChcIioqXCIpKSB7XG4gICAgICBpZiAoIW5vZGUud2lsZGNhcmQpIHtcbiAgICAgICAgbm9kZS53aWxkY2FyZCA9IHsga2V5OiBcIioqXCIgfTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLndpbGRjYXJkO1xuICAgICAgcGFyYW1zTWFwLnB1c2goW1xuICAgICAgICAtaSxcbiAgICAgICAgc2VnbWVudC5zcGxpdChcIjpcIilbMV0gfHwgXCJfXCIsXG4gICAgICAgIHNlZ21lbnQubGVuZ3RoID09PSAyXG4gICAgICBdKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoc2VnbWVudCA9PT0gXCIqXCIgfHwgc2VnbWVudC5pbmNsdWRlcyhcIjpcIikpIHtcbiAgICAgIGlmICghbm9kZS5wYXJhbSkge1xuICAgICAgICBub2RlLnBhcmFtID0geyBrZXk6IFwiKlwiIH07XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5wYXJhbTtcbiAgICAgIGNvbnN0IGlzT3B0aW9uYWwgPSBzZWdtZW50ID09PSBcIipcIjtcbiAgICAgIHBhcmFtc01hcC5wdXNoKFtcbiAgICAgICAgaSxcbiAgICAgICAgaXNPcHRpb25hbCA/IGBfJHtfdW5uYW1lZFBhcmFtSW5kZXgrK31gIDogX2dldFBhcmFtTWF0Y2hlcihzZWdtZW50KSxcbiAgICAgICAgaXNPcHRpb25hbFxuICAgICAgXSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGQgPSBub2RlLnN0YXRpYz8uW3NlZ21lbnRdO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgbm9kZSA9IGNoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdGF0aWNOb2RlID0geyBrZXk6IHNlZ21lbnQgfTtcbiAgICAgIGlmICghbm9kZS5zdGF0aWMpIHtcbiAgICAgICAgbm9kZS5zdGF0aWMgPSBuZXcgRW1wdHlPYmplY3QoKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc3RhdGljW3NlZ21lbnRdID0gc3RhdGljTm9kZTtcbiAgICAgIG5vZGUgPSBzdGF0aWNOb2RlO1xuICAgIH1cbiAgfVxuICBjb25zdCBoYXNQYXJhbXMgPSBwYXJhbXNNYXAubGVuZ3RoID4gMDtcbiAgaWYgKCFub2RlLm1ldGhvZHMpIHtcbiAgICBub2RlLm1ldGhvZHMgPSBuZXcgRW1wdHlPYmplY3QoKTtcbiAgfVxuICBpZiAoIW5vZGUubWV0aG9kc1ttZXRob2RdKSB7XG4gICAgbm9kZS5tZXRob2RzW21ldGhvZF0gPSBbXTtcbiAgfVxuICBub2RlLm1ldGhvZHNbbWV0aG9kXS5wdXNoKHtcbiAgICBkYXRhOiBkYXRhIHx8IG51bGwsXG4gICAgcGFyYW1zTWFwOiBoYXNQYXJhbXMgPyBwYXJhbXNNYXAgOiB2b2lkIDBcbiAgfSk7XG4gIGlmICghaGFzUGFyYW1zKSB7XG4gICAgY3R4LnN0YXRpY1twYXRoXSA9IG5vZGU7XG4gIH1cbn1cbmZ1bmN0aW9uIF9nZXRQYXJhbU1hdGNoZXIoc2VnbWVudCkge1xuICBpZiAoIXNlZ21lbnQuaW5jbHVkZXMoXCI6XCIsIDEpKSB7XG4gICAgcmV0dXJuIHNlZ21lbnQuc2xpY2UoMSk7XG4gIH1cbiAgY29uc3QgcmVnZXggPSBzZWdtZW50LnJlcGxhY2UoLzooXFx3KykvZywgKF8sIGlkKSA9PiBgKD88JHtpZH0+XFxcXHcrKWApO1xuICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7cmVnZXh9JGApO1xufVxuXG5mdW5jdGlvbiBmaW5kUm91dGUoY3R4LCBtZXRob2QgPSBcIlwiLCBwYXRoLCBvcHRzKSB7XG4gIGlmIChwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09IFwiL1wiKSB7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgLTEpO1xuICB9XG4gIGNvbnN0IHN0YXRpY05vZGUgPSBjdHguc3RhdGljW3BhdGhdO1xuICBpZiAoc3RhdGljTm9kZSAmJiBzdGF0aWNOb2RlLm1ldGhvZHMpIHtcbiAgICBjb25zdCBzdGF0aWNNYXRjaCA9IHN0YXRpY05vZGUubWV0aG9kc1ttZXRob2RdIHx8IHN0YXRpY05vZGUubWV0aG9kc1tcIlwiXTtcbiAgICBpZiAoc3RhdGljTWF0Y2ggIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHN0YXRpY01hdGNoWzBdO1xuICAgIH1cbiAgfVxuICBjb25zdCBzZWdtZW50cyA9IHNwbGl0UGF0aChwYXRoKTtcbiAgY29uc3QgbWF0Y2ggPSBfbG9va3VwVHJlZShjdHgsIGN0eC5yb290LCBtZXRob2QsIHNlZ21lbnRzLCAwKT8uWzBdO1xuICBpZiAobWF0Y2ggPT09IHZvaWQgMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAob3B0cz8ucGFyYW1zID09PSBmYWxzZSkge1xuICAgIHJldHVybiBtYXRjaDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRhdGE6IG1hdGNoLmRhdGEsXG4gICAgcGFyYW1zOiBtYXRjaC5wYXJhbXNNYXAgPyBnZXRNYXRjaFBhcmFtcyhzZWdtZW50cywgbWF0Y2gucGFyYW1zTWFwKSA6IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gX2xvb2t1cFRyZWUoY3R4LCBub2RlLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCkge1xuICBpZiAoaW5kZXggPT09IHNlZ21lbnRzLmxlbmd0aCkge1xuICAgIGlmIChub2RlLm1ldGhvZHMpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gbm9kZS5tZXRob2RzW21ldGhvZF0gfHwgbm9kZS5tZXRob2RzW1wiXCJdO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUucGFyYW0gJiYgbm9kZS5wYXJhbS5tZXRob2RzKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IG5vZGUucGFyYW0ubWV0aG9kc1ttZXRob2RdIHx8IG5vZGUucGFyYW0ubWV0aG9kc1tcIlwiXTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBjb25zdCBwTWFwID0gbWF0Y2hbMF0ucGFyYW1zTWFwO1xuICAgICAgICBpZiAocE1hcD8uW3BNYXA/Lmxlbmd0aCAtIDFdPy5bMl0pIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUud2lsZGNhcmQgJiYgbm9kZS53aWxkY2FyZC5tZXRob2RzKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IG5vZGUud2lsZGNhcmQubWV0aG9kc1ttZXRob2RdIHx8IG5vZGUud2lsZGNhcmQubWV0aG9kc1tcIlwiXTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBjb25zdCBwTWFwID0gbWF0Y2hbMF0ucGFyYW1zTWFwO1xuICAgICAgICBpZiAocE1hcD8uW3BNYXA/Lmxlbmd0aCAtIDFdPy5bMl0pIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaW5kZXhdO1xuICBpZiAobm9kZS5zdGF0aWMpIHtcbiAgICBjb25zdCBzdGF0aWNDaGlsZCA9IG5vZGUuc3RhdGljW3NlZ21lbnRdO1xuICAgIGlmIChzdGF0aWNDaGlsZCkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBfbG9va3VwVHJlZShjdHgsIHN0YXRpY0NoaWxkLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCArIDEpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUucGFyYW0pIHtcbiAgICBjb25zdCBtYXRjaCA9IF9sb29rdXBUcmVlKGN0eCwgbm9kZS5wYXJhbSwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXggKyAxKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUud2lsZGNhcmQgJiYgbm9kZS53aWxkY2FyZC5tZXRob2RzKSB7XG4gICAgcmV0dXJuIG5vZGUud2lsZGNhcmQubWV0aG9kc1ttZXRob2RdIHx8IG5vZGUud2lsZGNhcmQubWV0aG9kc1tcIlwiXTtcbiAgfVxuICByZXR1cm47XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVJvdXRlKGN0eCwgbWV0aG9kLCBwYXRoKSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gc3BsaXRQYXRoKHBhdGgpO1xuICByZXR1cm4gX3JlbW92ZShjdHgucm9vdCwgbWV0aG9kIHx8IFwiXCIsIHNlZ21lbnRzLCAwKTtcbn1cbmZ1bmN0aW9uIF9yZW1vdmUobm9kZSwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXgpIHtcbiAgaWYgKGluZGV4ID09PSBzZWdtZW50cy5sZW5ndGgpIHtcbiAgICBpZiAobm9kZS5tZXRob2RzICYmIG1ldGhvZCBpbiBub2RlLm1ldGhvZHMpIHtcbiAgICAgIGRlbGV0ZSBub2RlLm1ldGhvZHNbbWV0aG9kXTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhub2RlLm1ldGhvZHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBub2RlLm1ldGhvZHMgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaW5kZXhdO1xuICBpZiAoc2VnbWVudCA9PT0gXCIqXCIpIHtcbiAgICBpZiAobm9kZS5wYXJhbSkge1xuICAgICAgX3JlbW92ZShub2RlLnBhcmFtLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCArIDEpO1xuICAgICAgaWYgKF9pc0VtcHR5Tm9kZShub2RlLnBhcmFtKSkge1xuICAgICAgICBub2RlLnBhcmFtID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNlZ21lbnQgPT09IFwiKipcIikge1xuICAgIGlmIChub2RlLndpbGRjYXJkKSB7XG4gICAgICBfcmVtb3ZlKG5vZGUud2lsZGNhcmQsIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4ICsgMSk7XG4gICAgICBpZiAoX2lzRW1wdHlOb2RlKG5vZGUud2lsZGNhcmQpKSB7XG4gICAgICAgIG5vZGUud2lsZGNhcmQgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjaGlsZE5vZGUgPSBub2RlLnN0YXRpYz8uW3NlZ21lbnRdO1xuICBpZiAoY2hpbGROb2RlKSB7XG4gICAgX3JlbW92ZShjaGlsZE5vZGUsIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4ICsgMSk7XG4gICAgaWYgKF9pc0VtcHR5Tm9kZShjaGlsZE5vZGUpKSB7XG4gICAgICBkZWxldGUgbm9kZS5zdGF0aWNbc2VnbWVudF07XG4gICAgICBpZiAoT2JqZWN0LmtleXMobm9kZS5zdGF0aWMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBub2RlLnN0YXRpYyA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9pc0VtcHR5Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlLm1ldGhvZHMgPT09IHZvaWQgMCAmJiBub2RlLnN0YXRpYyA9PT0gdm9pZCAwICYmIG5vZGUucGFyYW0gPT09IHZvaWQgMCAmJiBub2RlLndpbGRjYXJkID09PSB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGZpbmRBbGxSb3V0ZXMoY3R4LCBtZXRob2QgPSBcIlwiLCBwYXRoLCBvcHRzKSB7XG4gIGlmIChwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09IFwiL1wiKSB7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgLTEpO1xuICB9XG4gIGNvbnN0IHNlZ21lbnRzID0gc3BsaXRQYXRoKHBhdGgpO1xuICBjb25zdCBtYXRjaGVzID0gX2ZpbmRBbGwoY3R4LCBjdHgucm9vdCwgbWV0aG9kLCBzZWdtZW50cywgMCk7XG4gIGlmIChvcHRzPy5wYXJhbXMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXMubWFwKChtKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IG0uZGF0YSxcbiAgICAgIHBhcmFtczogbS5wYXJhbXNNYXAgPyBnZXRNYXRjaFBhcmFtcyhzZWdtZW50cywgbS5wYXJhbXNNYXApIDogdm9pZCAwXG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBfZmluZEFsbChjdHgsIG5vZGUsIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4LCBtYXRjaGVzID0gW10pIHtcbiAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2luZGV4XTtcbiAgaWYgKG5vZGUud2lsZGNhcmQgJiYgbm9kZS53aWxkY2FyZC5tZXRob2RzKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBub2RlLndpbGRjYXJkLm1ldGhvZHNbbWV0aG9kXSB8fCBub2RlLndpbGRjYXJkLm1ldGhvZHNbXCJcIl07XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBtYXRjaGVzLnB1c2goLi4ubWF0Y2gpO1xuICAgIH1cbiAgfVxuICBpZiAobm9kZS5wYXJhbSkge1xuICAgIF9maW5kQWxsKGN0eCwgbm9kZS5wYXJhbSwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXggKyAxLCBtYXRjaGVzKTtcbiAgICBpZiAoaW5kZXggPT09IHNlZ21lbnRzLmxlbmd0aCAmJiBub2RlLnBhcmFtLm1ldGhvZHMpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gbm9kZS5wYXJhbS5tZXRob2RzW21ldGhvZF0gfHwgbm9kZS5wYXJhbS5tZXRob2RzW1wiXCJdO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaCguLi5tYXRjaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHN0YXRpY0NoaWxkID0gbm9kZS5zdGF0aWM/LltzZWdtZW50XTtcbiAgaWYgKHN0YXRpY0NoaWxkKSB7XG4gICAgX2ZpbmRBbGwoY3R4LCBzdGF0aWNDaGlsZCwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXggKyAxLCBtYXRjaGVzKTtcbiAgfVxuICBpZiAoaW5kZXggPT09IHNlZ21lbnRzLmxlbmd0aCAmJiBub2RlLm1ldGhvZHMpIHtcbiAgICBjb25zdCBtYXRjaCA9IG5vZGUubWV0aG9kc1ttZXRob2RdIHx8IG5vZGUubWV0aG9kc1tcIlwiXTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIG1hdGNoZXMucHVzaCguLi5tYXRjaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXRjaGVzO1xufVxuXG5leHBvcnQgeyBhZGRSb3V0ZSwgY3JlYXRlUm91dGVyLCBmaW5kQWxsUm91dGVzLCBmaW5kUm91dGUsIHJlbW92ZVJvdXRlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rou3/dist/index.mjs\n");

/***/ })

};
;