"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@noble";
exports.ids = ["vendor-chunks/@noble"];
exports.modules = {

/***/ "(ssr)/./node_modules/@noble/hashes/_md.js":
/*!*******************************************!*\
  !*** ./node_modules/@noble/hashes/_md.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: () => (/* binding */ Chi),\n/* harmony export */   HashMD: () => (/* binding */ HashMD),\n/* harmony export */   Maj: () => (/* binding */ Maj),\n/* harmony export */   SHA224_IV: () => (/* binding */ SHA224_IV),\n/* harmony export */   SHA256_IV: () => (/* binding */ SHA256_IV),\n/* harmony export */   SHA384_IV: () => (/* binding */ SHA384_IV),\n/* harmony export */   SHA512_IV: () => (/* binding */ SHA512_IV)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\n/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\n\n/** Choice: a ? b : c */\nfunction Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nfunction Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD {\n    blockLen;\n    outputLen;\n    padOffset;\n    isLE;\n    // For partial updates less than block size\n    buffer;\n    view;\n    finished = false;\n    length = 0;\n    pos = 0;\n    destroyed = false;\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aoutput)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which must be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen must be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to ||= new this.constructor();\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nconst SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nconst SHA224_IV = /* @__PURE__ */ Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nconst SHA384_IV = /* @__PURE__ */ Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nconst SHA512_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fbWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUN5RTtBQUN6RTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQVU7QUFDOUI7QUFDQTtBQUNBLFFBQVEsa0RBQU87QUFDZixRQUFRLGlEQUFNO0FBQ2QsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxREFBVTtBQUMzQyx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTztBQUNmLFFBQVEsa0RBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQSxRQUFRLGdEQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2F1dG9wbGFuY2FtLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX21kLmpzPzZkNTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbnRlcm5hbCBNZXJrbGUtRGFtZ2FyZCBoYXNoIHV0aWxzLlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyBhYnl0ZXMsIGFleGlzdHMsIGFvdXRwdXQsIGNsZWFuLCBjcmVhdGVWaWV3IH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8qKiBDaG9pY2U6IGEgPyBiIDogYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIENoaShhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChhICYgYikgXiAofmEgJiBjKTtcbn1cbi8qKiBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHV0cyBpcyB0cnVlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE1haihhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbn1cbi8qKlxuICogTWVya2xlLURhbWdhcmQgaGFzaCBjb25zdHJ1Y3Rpb24gYmFzZSBjbGFzcy5cbiAqIENvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIE1ENSwgUklQRU1ELCBTSEExLCBTSEEyLlxuICovXG5leHBvcnQgY2xhc3MgSGFzaE1EIHtcbiAgICBibG9ja0xlbjtcbiAgICBvdXRwdXRMZW47XG4gICAgcGFkT2Zmc2V0O1xuICAgIGlzTEU7XG4gICAgLy8gRm9yIHBhcnRpYWwgdXBkYXRlcyBsZXNzIHRoYW4gYmxvY2sgc2l6ZVxuICAgIGJ1ZmZlcjtcbiAgICB2aWV3O1xuICAgIGZpbmlzaGVkID0gZmFsc2U7XG4gICAgbGVuZ3RoID0gMDtcbiAgICBwb3MgPSAwO1xuICAgIGRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICBhYnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYWV4aXN0cyh0aGlzKTtcbiAgICAgICAgYW91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIGNsZWFuKHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykpO1xuICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluXG4gICAgICAgIC8vIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgICAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgICAgICB2aWV3LnNldEJpZ1VpbnQ2NChibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIG11c3QgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgICAgICBpZiAobGVuICUgNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBtdXN0IGJlIGFsaWduZWQgdG8gMzJiaXQnKTtcbiAgICAgICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgICAgICBpZiAob3V0TGVuID4gc3RhdGUubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspXG4gICAgICAgICAgICBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvIHx8PSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbi8qKlxuICogSW5pdGlhbCBTSEEtMiBzdGF0ZTogZnJhY3Rpb25hbCBwYXJ0cyBvZiBzcXVhcmUgcm9vdHMgb2YgZmlyc3QgMTYgcHJpbWVzIDIuLjUzLlxuICogQ2hlY2sgb3V0IGB0ZXN0L21pc2Mvc2hhMi1nZW4taXYuanNgIGZvciByZWNvbXB1dGF0aW9uIGd1aWRlLlxuICovXG4vKiogSW5pdGlhbCBTSEEyNTYgc3RhdGUuIEJpdHMgMC4uMzIgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIuLjE5ICovXG5leHBvcnQgY29uc3QgU0hBMjU2X0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTksXG5dKTtcbi8qKiBJbml0aWFsIFNIQTIyNCBzdGF0ZS4gQml0cyAzMi4uNjQgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIzLi41MyAqL1xuZXhwb3J0IGNvbnN0IFNIQTIyNF9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweGMxMDU5ZWQ4LCAweDM2N2NkNTA3LCAweDMwNzBkZDE3LCAweGY3MGU1OTM5LCAweGZmYzAwYjMxLCAweDY4NTgxNTExLCAweDY0Zjk4ZmE3LCAweGJlZmE0ZmE0LFxuXSk7XG4vKiogSW5pdGlhbCBTSEEzODQgc3RhdGUuIEJpdHMgMC4uNjQgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIzLi41MyAqL1xuZXhwb3J0IGNvbnN0IFNIQTM4NF9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweGNiYmI5ZDVkLCAweGMxMDU5ZWQ4LCAweDYyOWEyOTJhLCAweDM2N2NkNTA3LCAweDkxNTkwMTVhLCAweDMwNzBkZDE3LCAweDE1MmZlY2Q4LCAweGY3MGU1OTM5LFxuICAgIDB4NjczMzI2NjcsIDB4ZmZjMDBiMzEsIDB4OGViNDRhODcsIDB4Njg1ODE1MTEsIDB4ZGIwYzJlMGQsIDB4NjRmOThmYTcsIDB4NDdiNTQ4MWQsIDB4YmVmYTRmYTQsXG5dKTtcbi8qKiBJbml0aWFsIFNIQTUxMiBzdGF0ZS4gQml0cyAwLi42NCBvZiBmcmFjIHBhcnQgb2Ygc3FydCBvZiBwcmltZXMgMi4uMTkgKi9cbmV4cG9ydCBjb25zdCBTSEE1MTJfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg2YTA5ZTY2NywgMHhmM2JjYzkwOCwgMHhiYjY3YWU4NSwgMHg4NGNhYTczYiwgMHgzYzZlZjM3MiwgMHhmZTk0ZjgyYiwgMHhhNTRmZjUzYSwgMHg1ZjFkMzZmMSxcbiAgICAweDUxMGU1MjdmLCAweGFkZTY4MmQxLCAweDliMDU2ODhjLCAweDJiM2U2YzFmLCAweDFmODNkOWFiLCAweGZiNDFiZDZiLCAweDViZTBjZDE5LCAweDEzN2UyMTc5LFxuXSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fbWQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/_md.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/_u64.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/_u64.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\n/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64);\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fdTY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0IsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnTDtBQUNoTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxHQUFHLEVBQUM7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hdXRvcGxhbmNhbS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL191NjQuanM/ZTNiOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEludGVybmFsIGhlbHBlcnMgZm9yIHU2NC4gQmlnVWludDY0QXJyYXkgaXMgdG9vIHNsb3cgYXMgcGVyIDIwMjUsIHNvIHdlIGltcGxlbWVudCBpdCB1c2luZyBVaW50MzJBcnJheS5cbiAqIEB0b2RvIHJlLWNoZWNrIGh0dHBzOi8vaXNzdWVzLmNocm9taXVtLm9yZy9pc3N1ZXMvNDIyMTI1ODhcbiAqIEBtb2R1bGVcbiAqL1xuY29uc3QgVTMyX01BU0s2NCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuY29uc3QgXzMybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMzIpO1xuZnVuY3Rpb24gZnJvbUJpZyhuLCBsZSA9IGZhbHNlKSB7XG4gICAgaWYgKGxlKVxuICAgICAgICByZXR1cm4geyBoOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpLCBsOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB9O1xuICAgIHJldHVybiB7IGg6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSB8IDAgfTtcbn1cbmZ1bmN0aW9uIHNwbGl0KGxzdCwgbGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxlbiA9IGxzdC5sZW5ndGg7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxlbik7XG4gICAgbGV0IEFsID0gbmV3IFVpbnQzMkFycmF5KGxlbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIF9sLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChfaCwgbCkgPT4gbDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgX2wpID0+IGg7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCB7IGFkZCwgYWRkM0gsIGFkZDNMLCBhZGQ0SCwgYWRkNEwsIGFkZDVILCBhZGQ1TCwgZnJvbUJpZywgcm90bEJILCByb3RsQkwsIHJvdGxTSCwgcm90bFNMLCByb3RyMzJILCByb3RyMzJMLCByb3RyQkgsIHJvdHJCTCwgcm90clNILCByb3RyU0wsIHNoclNILCBzaHJTTCwgc3BsaXQsIHRvQmlnIH07XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHU2NCA9IHtcbiAgICBmcm9tQmlnLCBzcGxpdCwgdG9CaWcsXG4gICAgc2hyU0gsIHNoclNMLFxuICAgIHJvdHJTSCwgcm90clNMLCByb3RyQkgsIHJvdHJCTCxcbiAgICByb3RyMzJILCByb3RyMzJMLFxuICAgIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCxcbiAgICBhZGQsIGFkZDNMLCBhZGQzSCwgYWRkNEwsIGFkZDRILCBhZGQ1SCwgYWRkNUwsXG59O1xuZXhwb3J0IGRlZmF1bHQgdTY0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3U2NC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/_u64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/sha2.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/sha2.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _SHA224: () => (/* binding */ _SHA224),\n/* harmony export */   _SHA256: () => (/* binding */ _SHA256),\n/* harmony export */   _SHA384: () => (/* binding */ _SHA384),\n/* harmony export */   _SHA512: () => (/* binding */ _SHA512),\n/* harmony export */   _SHA512_224: () => (/* binding */ _SHA512_224),\n/* harmony export */   _SHA512_256: () => (/* binding */ _SHA512_256),\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   sha384: () => (/* binding */ sha384),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   sha512_224: () => (/* binding */ sha512_224),\n/* harmony export */   sha512_256: () => (/* binding */ sha512_256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"(ssr)/./node_modules/@noble/hashes/_md.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/@noble/hashes/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\n/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://www.rfc-editor.org/rfc/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\n\n\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\n/** Internal 32-byte base SHA2 hash class. */\nclass SHA2_32B extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(outputLen) {\n        super(64, outputLen, 8, false);\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n    }\n}\n/** Internal SHA2-256 hash class. */\nclass _SHA256 extends SHA2_32B {\n    // We cannot use array here since array allows indexing by variable\n    // which means optimizer/compiler cannot use registers.\n    A = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[0] | 0;\n    B = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[1] | 0;\n    C = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[2] | 0;\n    D = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[3] | 0;\n    E = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[4] | 0;\n    F = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[5] | 0;\n    G = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[6] | 0;\n    H = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[7] | 0;\n    constructor() {\n        super(32);\n    }\n}\n/** Internal SHA2-224 hash class. */\nclass _SHA224 extends SHA2_32B {\n    A = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[0] | 0;\n    B = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[1] | 0;\n    C = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[2] | 0;\n    D = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[3] | 0;\n    E = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[4] | 0;\n    F = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[5] | 0;\n    G = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[6] | 0;\n    H = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[7] | 0;\n    constructor() {\n        super(28);\n    }\n}\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => _u64_js__WEBPACK_IMPORTED_MODULE_2__.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n/** Internal 64-byte base SHA2 hash class. */\nclass SHA2_64B extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(outputLen) {\n        super(128, outputLen, 16, false);\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\n/** Internal SHA2-512 hash class. */\nclass _SHA512 extends SHA2_64B {\n    Ah = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[0] | 0;\n    Al = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[1] | 0;\n    Bh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[2] | 0;\n    Bl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[3] | 0;\n    Ch = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[4] | 0;\n    Cl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[5] | 0;\n    Dh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[6] | 0;\n    Dl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[7] | 0;\n    Eh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[8] | 0;\n    El = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[9] | 0;\n    Fh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[10] | 0;\n    Fl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[11] | 0;\n    Gh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[12] | 0;\n    Gl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[13] | 0;\n    Hh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[14] | 0;\n    Hl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[15] | 0;\n    constructor() {\n        super(64);\n    }\n}\n/** Internal SHA2-384 hash class. */\nclass _SHA384 extends SHA2_64B {\n    Ah = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[0] | 0;\n    Al = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[1] | 0;\n    Bh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[2] | 0;\n    Bl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[3] | 0;\n    Ch = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[4] | 0;\n    Cl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[5] | 0;\n    Dh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[6] | 0;\n    Dl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[7] | 0;\n    Eh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[8] | 0;\n    El = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[9] | 0;\n    Fh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[10] | 0;\n    Fl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[11] | 0;\n    Gh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[12] | 0;\n    Gl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[13] | 0;\n    Hh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[14] | 0;\n    Hl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[15] | 0;\n    constructor() {\n        super(48);\n    }\n}\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\n/** Internal SHA2-512/224 hash class. */\nclass _SHA512_224 extends SHA2_64B {\n    Ah = T224_IV[0] | 0;\n    Al = T224_IV[1] | 0;\n    Bh = T224_IV[2] | 0;\n    Bl = T224_IV[3] | 0;\n    Ch = T224_IV[4] | 0;\n    Cl = T224_IV[5] | 0;\n    Dh = T224_IV[6] | 0;\n    Dl = T224_IV[7] | 0;\n    Eh = T224_IV[8] | 0;\n    El = T224_IV[9] | 0;\n    Fh = T224_IV[10] | 0;\n    Fl = T224_IV[11] | 0;\n    Gh = T224_IV[12] | 0;\n    Gl = T224_IV[13] | 0;\n    Hh = T224_IV[14] | 0;\n    Hl = T224_IV[15] | 0;\n    constructor() {\n        super(28);\n    }\n}\n/** Internal SHA2-512/256 hash class. */\nclass _SHA512_256 extends SHA2_64B {\n    Ah = T256_IV[0] | 0;\n    Al = T256_IV[1] | 0;\n    Bh = T256_IV[2] | 0;\n    Bl = T256_IV[3] | 0;\n    Ch = T256_IV[4] | 0;\n    Cl = T256_IV[5] | 0;\n    Dh = T256_IV[6] | 0;\n    Dl = T256_IV[7] | 0;\n    Eh = T256_IV[8] | 0;\n    El = T256_IV[9] | 0;\n    Fh = T256_IV[10] | 0;\n    Fl = T256_IV[11] | 0;\n    Gh = T256_IV[12] | 0;\n    Gl = T256_IV[13] | 0;\n    Hh = T256_IV[14] | 0;\n    Hl = T256_IV[15] | 0;\n    constructor() {\n        super(32);\n    }\n}\n/**\n * SHA2-256 hash function from RFC 4634. In JS it's the fastest: even faster than Blake3. Some info:\n *\n * - Trying 2^128 hashes would get 50% chance of collision, using birthday attack.\n * - BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n * - Each sha256 hash is executing 2^18 bit operations.\n * - Good 2024 ASICs can do 200Th/sec with 3500 watts of power, corresponding to 2^36 hashes/joule.\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new _SHA256(), \n/* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.oidNist)(0x01));\n/** SHA2-224 hash function from RFC 4634 */\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new _SHA224(), \n/* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.oidNist)(0x04));\n/** SHA2-512 hash function from RFC 4634. */\nconst sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new _SHA512(), \n/* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.oidNist)(0x03));\n/** SHA2-384 hash function from RFC 4634. */\nconst sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new _SHA384(), \n/* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.oidNist)(0x02));\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nconst sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new _SHA512_256(), \n/* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.oidNist)(0x06));\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nconst sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new _SHA512_224(), \n/* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.oidNist)(0x05));\n//# sourceMappingURL=sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3dGO0FBQ3ZEO0FBQytCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQ0FBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUMsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkMsd0JBQXdCLFFBQVE7QUFDaEMsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRCxxQ0FBcUMsMkNBQUc7QUFDeEMsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRCxpQ0FBaUMsMkNBQUc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBSztBQUNiO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxRQUFRLDZDQUFTO0FBQ2pCLFFBQVEsNkNBQVM7QUFDakIsUUFBUSw2Q0FBUztBQUNqQixRQUFRLDZDQUFTO0FBQ2pCLFFBQVEsNkNBQVM7QUFDakIsUUFBUSw2Q0FBUztBQUNqQixRQUFRLDZDQUFTO0FBQ2pCLFFBQVEsNkNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsUUFBUSw2Q0FBUztBQUNqQixRQUFRLDZDQUFTO0FBQ2pCLFFBQVEsNkNBQVM7QUFDakIsUUFBUSw2Q0FBUztBQUNqQixRQUFRLDZDQUFTO0FBQ2pCLFFBQVEsNkNBQVM7QUFDakIsUUFBUSw2Q0FBUztBQUNqQixRQUFRLDZDQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMENBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBDQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUVBQWlFO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkNBQVUsa0JBQWtCLDJDQUFVLGtCQUFrQiwwQ0FBUztBQUN6Rix3QkFBd0IsMkNBQVUsa0JBQWtCLDJDQUFVLGtCQUFrQiwwQ0FBUztBQUN6RjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkNBQVUsaUJBQWlCLDJDQUFVLGlCQUFpQiwwQ0FBUztBQUN2Rix3QkFBd0IsMkNBQVUsaUJBQWlCLDJDQUFVLGlCQUFpQiwwQ0FBUztBQUN2RjtBQUNBLHlCQUF5QiwwQ0FBUztBQUNsQyx5QkFBeUIsMENBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpRUFBaUU7QUFDL0U7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLDRCQUE0QiwyQ0FBVSxlQUFlLDJDQUFVLGVBQWUsMkNBQVU7QUFDeEYsNEJBQTRCLDJDQUFVLGVBQWUsMkNBQVUsZUFBZSwyQ0FBVTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBDQUFTO0FBQ2xDLHdCQUF3QiwwQ0FBUztBQUNqQztBQUNBO0FBQ0EsNEJBQTRCLDJDQUFVLGVBQWUsMkNBQVUsZUFBZSwyQ0FBVTtBQUN4Riw0QkFBNEIsMkNBQVUsZUFBZSwyQ0FBVSxlQUFlLDJDQUFVO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWUsRUFBRSx3Q0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMENBQVM7QUFDakMsaUJBQWlCLDBDQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZSxFQUFFLHdDQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLHdDQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLHdDQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLHdDQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLHdDQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLHdDQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLHdDQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLHdDQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQUs7QUFDYjtBQUNBO0FBQ0EsUUFBUSxnREFBSztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxTQUFTLDZDQUFTO0FBQ2xCLFNBQVMsNkNBQVM7QUFDbEIsU0FBUyw2Q0FBUztBQUNsQixTQUFTLDZDQUFTO0FBQ2xCLFNBQVMsNkNBQVM7QUFDbEIsU0FBUyw2Q0FBUztBQUNsQixTQUFTLDZDQUFTO0FBQ2xCLFNBQVMsNkNBQVM7QUFDbEIsU0FBUyw2Q0FBUztBQUNsQixTQUFTLDZDQUFTO0FBQ2xCLFNBQVMsNkNBQVM7QUFDbEIsU0FBUyw2Q0FBUztBQUNsQixTQUFTLDZDQUFTO0FBQ2xCLFNBQVMsNkNBQVM7QUFDbEIsU0FBUyw2Q0FBUztBQUNsQixTQUFTLDZDQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFNBQVMsNkNBQVM7QUFDbEIsU0FBUyw2Q0FBUztBQUNsQixTQUFTLDZDQUFTO0FBQ2xCLFNBQVMsNkNBQVM7QUFDbEIsU0FBUyw2Q0FBUztBQUNsQixTQUFTLDZDQUFTO0FBQ2xCLFNBQVMsNkNBQVM7QUFDbEIsU0FBUyw2Q0FBUztBQUNsQixTQUFTLDZDQUFTO0FBQ2xCLFNBQVMsNkNBQVM7QUFDbEIsU0FBUyw2Q0FBUztBQUNsQixTQUFTLDZDQUFTO0FBQ2xCLFNBQVMsNkNBQVM7QUFDbEIsU0FBUyw2Q0FBUztBQUNsQixTQUFTLDZDQUFTO0FBQ2xCLFNBQVMsNkNBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLHVEQUFZO0FBQ2xELGdCQUFnQixrREFBTztBQUN2QjtBQUNPLCtCQUErQix1REFBWTtBQUNsRCxnQkFBZ0Isa0RBQU87QUFDdkI7QUFDTywrQkFBK0IsdURBQVk7QUFDbEQsZ0JBQWdCLGtEQUFPO0FBQ3ZCO0FBQ08sK0JBQStCLHVEQUFZO0FBQ2xELGdCQUFnQixrREFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQyx1REFBWTtBQUN0RCxnQkFBZ0Isa0RBQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQ0FBbUMsdURBQVk7QUFDdEQsZ0JBQWdCLGtEQUFPO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXV0b3BsYW5jYW0vLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEyLmpzPzQyZDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTSEEyIGhhc2ggZnVuY3Rpb24uIEEuay5hLiBzaGEyNTYsIHNoYTM4NCwgc2hhNTEyLCBzaGE1MTJfMjI0LCBzaGE1MTJfMjU2LlxuICogU0hBMjU2IGlzIHRoZSBmYXN0ZXN0IGhhc2ggaW1wbGVtZW50YWJsZSBpbiBKUywgZXZlbiBmYXN0ZXIgdGhhbiBCbGFrZTMuXG4gKiBDaGVjayBvdXQgW1JGQyA0NjM0XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNDYzNCkgYW5kXG4gKiBbRklQUyAxODAtNF0oaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZikuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IENoaSwgSGFzaE1ELCBNYWosIFNIQTIyNF9JViwgU0hBMjU2X0lWLCBTSEEzODRfSVYsIFNIQTUxMl9JViB9IGZyb20gXCIuL19tZC5qc1wiO1xuaW1wb3J0ICogYXMgdTY0IGZyb20gXCIuL191NjQuanNcIjtcbmltcG9ydCB7IGNsZWFuLCBjcmVhdGVIYXNoZXIsIG9pZE5pc3QsIHJvdHIgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLyoqXG4gKiBSb3VuZCBjb25zdGFudHM6XG4gKiBGaXJzdCAzMiBiaXRzIG9mIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4gKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8qKiBSZXVzYWJsZSB0ZW1wb3JhcnkgYnVmZmVyLiBcIldcIiBjb21lcyBzdHJhaWdodCBmcm9tIHNwZWMuICovXG5jb25zdCBTSEEyNTZfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoNjQpO1xuLyoqIEludGVybmFsIDMyLWJ5dGUgYmFzZSBTSEEyIGhhc2ggY2xhc3MuICovXG5jbGFzcyBTSEEyXzMyQiBleHRlbmRzIEhhc2hNRCB7XG4gICAgY29uc3RydWN0b3Iob3V0cHV0TGVuKSB7XG4gICAgICAgIHN1cGVyKDY0LCBvdXRwdXRMZW4sIDgsIGZhbHNlKTtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBjbGVhbihTSEEyNTZfVyk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlcik7XG4gICAgfVxufVxuLyoqIEludGVybmFsIFNIQTItMjU2IGhhc2ggY2xhc3MuICovXG5leHBvcnQgY2xhc3MgX1NIQTI1NiBleHRlbmRzIFNIQTJfMzJCIHtcbiAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgIEEgPSBTSEEyNTZfSVZbMF0gfCAwO1xuICAgIEIgPSBTSEEyNTZfSVZbMV0gfCAwO1xuICAgIEMgPSBTSEEyNTZfSVZbMl0gfCAwO1xuICAgIEQgPSBTSEEyNTZfSVZbM10gfCAwO1xuICAgIEUgPSBTSEEyNTZfSVZbNF0gfCAwO1xuICAgIEYgPSBTSEEyNTZfSVZbNV0gfCAwO1xuICAgIEcgPSBTSEEyNTZfSVZbNl0gfCAwO1xuICAgIEggPSBTSEEyNTZfSVZbN10gfCAwO1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigzMik7XG4gICAgfVxufVxuLyoqIEludGVybmFsIFNIQTItMjI0IGhhc2ggY2xhc3MuICovXG5leHBvcnQgY2xhc3MgX1NIQTIyNCBleHRlbmRzIFNIQTJfMzJCIHtcbiAgICBBID0gU0hBMjI0X0lWWzBdIHwgMDtcbiAgICBCID0gU0hBMjI0X0lWWzFdIHwgMDtcbiAgICBDID0gU0hBMjI0X0lWWzJdIHwgMDtcbiAgICBEID0gU0hBMjI0X0lWWzNdIHwgMDtcbiAgICBFID0gU0hBMjI0X0lWWzRdIHwgMDtcbiAgICBGID0gU0hBMjI0X0lWWzVdIHwgMDtcbiAgICBHID0gU0hBMjI0X0lWWzZdIHwgMDtcbiAgICBIID0gU0hBMjI0X0lWWzddIHwgMDtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMjgpO1xuICAgIH1cbn1cbi8vIFNIQTItNTEyIGlzIHNsb3dlciB0aGFuIHNoYTI1NiBpbiBqcyBiZWNhdXNlIHU2NCBvcGVyYXRpb25zIGFyZSBzbG93LlxuLy8gUm91bmQgY29udGFudHNcbi8vIEZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDgwIHByaW1lcyAyLi40MDlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgSzUxMiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdTY0LnNwbGl0KFtcbiAgICAnMHg0MjhhMmY5OGQ3MjhhZTIyJywgJzB4NzEzNzQ0OTEyM2VmNjVjZCcsICcweGI1YzBmYmNmZWM0ZDNiMmYnLCAnMHhlOWI1ZGJhNTgxODlkYmJjJyxcbiAgICAnMHgzOTU2YzI1YmYzNDhiNTM4JywgJzB4NTlmMTExZjFiNjA1ZDAxOScsICcweDkyM2Y4MmE0YWYxOTRmOWInLCAnMHhhYjFjNWVkNWRhNmQ4MTE4JyxcbiAgICAnMHhkODA3YWE5OGEzMDMwMjQyJywgJzB4MTI4MzViMDE0NTcwNmZiZScsICcweDI0MzE4NWJlNGVlNGIyOGMnLCAnMHg1NTBjN2RjM2Q1ZmZiNGUyJyxcbiAgICAnMHg3MmJlNWQ3NGYyN2I4OTZmJywgJzB4ODBkZWIxZmUzYjE2OTZiMScsICcweDliZGMwNmE3MjVjNzEyMzUnLCAnMHhjMTliZjE3NGNmNjkyNjk0JyxcbiAgICAnMHhlNDliNjljMTllZjE0YWQyJywgJzB4ZWZiZTQ3ODYzODRmMjVlMycsICcweDBmYzE5ZGM2OGI4Y2Q1YjUnLCAnMHgyNDBjYTFjYzc3YWM5YzY1JyxcbiAgICAnMHgyZGU5MmM2ZjU5MmIwMjc1JywgJzB4NGE3NDg0YWE2ZWE2ZTQ4MycsICcweDVjYjBhOWRjYmQ0MWZiZDQnLCAnMHg3NmY5ODhkYTgzMTE1M2I1JyxcbiAgICAnMHg5ODNlNTE1MmVlNjZkZmFiJywgJzB4YTgzMWM2NmQyZGI0MzIxMCcsICcweGIwMDMyN2M4OThmYjIxM2YnLCAnMHhiZjU5N2ZjN2JlZWYwZWU0JyxcbiAgICAnMHhjNmUwMGJmMzNkYTg4ZmMyJywgJzB4ZDVhNzkxNDc5MzBhYTcyNScsICcweDA2Y2E2MzUxZTAwMzgyNmYnLCAnMHgxNDI5Mjk2NzBhMGU2ZTcwJyxcbiAgICAnMHgyN2I3MGE4NTQ2ZDIyZmZjJywgJzB4MmUxYjIxMzg1YzI2YzkyNicsICcweDRkMmM2ZGZjNWFjNDJhZWQnLCAnMHg1MzM4MGQxMzlkOTViM2RmJyxcbiAgICAnMHg2NTBhNzM1NDhiYWY2M2RlJywgJzB4NzY2YTBhYmIzYzc3YjJhOCcsICcweDgxYzJjOTJlNDdlZGFlZTYnLCAnMHg5MjcyMmM4NTE0ODIzNTNiJyxcbiAgICAnMHhhMmJmZThhMTRjZjEwMzY0JywgJzB4YTgxYTY2NGJiYzQyMzAwMScsICcweGMyNGI4YjcwZDBmODk3OTEnLCAnMHhjNzZjNTFhMzA2NTRiZTMwJyxcbiAgICAnMHhkMTkyZTgxOWQ2ZWY1MjE4JywgJzB4ZDY5OTA2MjQ1NTY1YTkxMCcsICcweGY0MGUzNTg1NTc3MTIwMmEnLCAnMHgxMDZhYTA3MDMyYmJkMWI4JyxcbiAgICAnMHgxOWE0YzExNmI4ZDJkMGM4JywgJzB4MWUzNzZjMDg1MTQxYWI1MycsICcweDI3NDg3NzRjZGY4ZWViOTknLCAnMHgzNGIwYmNiNWUxOWI0OGE4JyxcbiAgICAnMHgzOTFjMGNiM2M1Yzk1YTYzJywgJzB4NGVkOGFhNGFlMzQxOGFjYicsICcweDViOWNjYTRmNzc2M2UzNzMnLCAnMHg2ODJlNmZmM2Q2YjJiOGEzJyxcbiAgICAnMHg3NDhmODJlZTVkZWZiMmZjJywgJzB4NzhhNTYzNmY0MzE3MmY2MCcsICcweDg0Yzg3ODE0YTFmMGFiNzInLCAnMHg4Y2M3MDIwODFhNjQzOWVjJyxcbiAgICAnMHg5MGJlZmZmYTIzNjMxZTI4JywgJzB4YTQ1MDZjZWJkZTgyYmRlOScsICcweGJlZjlhM2Y3YjJjNjc5MTUnLCAnMHhjNjcxNzhmMmUzNzI1MzJiJyxcbiAgICAnMHhjYTI3M2VjZWVhMjY2MTljJywgJzB4ZDE4NmI4YzcyMWMwYzIwNycsICcweGVhZGE3ZGQ2Y2RlMGViMWUnLCAnMHhmNTdkNGY3ZmVlNmVkMTc4JyxcbiAgICAnMHgwNmYwNjdhYTcyMTc2ZmJhJywgJzB4MGE2MzdkYzVhMmM4OThhNicsICcweDExM2Y5ODA0YmVmOTBkYWUnLCAnMHgxYjcxMGIzNTEzMWM0NzFiJyxcbiAgICAnMHgyOGRiNzdmNTIzMDQ3ZDg0JywgJzB4MzJjYWFiN2I0MGM3MjQ5MycsICcweDNjOWViZTBhMTVjOWJlYmMnLCAnMHg0MzFkNjdjNDljMTAwZDRjJyxcbiAgICAnMHg0Y2M1ZDRiZWNiM2U0MmI2JywgJzB4NTk3ZjI5OWNmYzY1N2UyYScsICcweDVmY2I2ZmFiM2FkNmZhZWMnLCAnMHg2YzQ0MTk4YzRhNDc1ODE3J1xuXS5tYXAobiA9PiBCaWdJbnQobikpKSkoKTtcbmNvbnN0IFNIQTUxMl9LaCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gSzUxMlswXSkoKTtcbmNvbnN0IFNIQTUxMl9LbCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gSzUxMlsxXSkoKTtcbi8vIFJldXNhYmxlIHRlbXBvcmFyeSBidWZmZXJzXG5jb25zdCBTSEE1MTJfV19IID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg4MCk7XG5jb25zdCBTSEE1MTJfV19MID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg4MCk7XG4vKiogSW50ZXJuYWwgNjQtYnl0ZSBiYXNlIFNIQTIgaGFzaCBjbGFzcy4gKi9cbmNsYXNzIFNIQTJfNjRCIGV4dGVuZHMgSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcihvdXRwdXRMZW4pIHtcbiAgICAgICAgc3VwZXIoMTI4LCBvdXRwdXRMZW4sIDE2LCBmYWxzZSk7XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCkge1xuICAgICAgICB0aGlzLkFoID0gQWggfCAwO1xuICAgICAgICB0aGlzLkFsID0gQWwgfCAwO1xuICAgICAgICB0aGlzLkJoID0gQmggfCAwO1xuICAgICAgICB0aGlzLkJsID0gQmwgfCAwO1xuICAgICAgICB0aGlzLkNoID0gQ2ggfCAwO1xuICAgICAgICB0aGlzLkNsID0gQ2wgfCAwO1xuICAgICAgICB0aGlzLkRoID0gRGggfCAwO1xuICAgICAgICB0aGlzLkRsID0gRGwgfCAwO1xuICAgICAgICB0aGlzLkVoID0gRWggfCAwO1xuICAgICAgICB0aGlzLkVsID0gRWwgfCAwO1xuICAgICAgICB0aGlzLkZoID0gRmggfCAwO1xuICAgICAgICB0aGlzLkZsID0gRmwgfCAwO1xuICAgICAgICB0aGlzLkdoID0gR2ggfCAwO1xuICAgICAgICB0aGlzLkdsID0gR2wgfCAwO1xuICAgICAgICB0aGlzLkhoID0gSGggfCAwO1xuICAgICAgICB0aGlzLkhsID0gSGwgfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA2NCB3b3JkcyB3WzE2Li43OV0gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNCkge1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gdmlldy5nZXRVaW50MzIoKG9mZnNldCArPSA0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gczAgOj0gKHdbaS0xNV0gcmlnaHRyb3RhdGUgMSkgeG9yICh3W2ktMTVdIHJpZ2h0cm90YXRlIDgpIHhvciAod1tpLTE1XSByaWdodHNoaWZ0IDcpXG4gICAgICAgICAgICBjb25zdCBXMTVoID0gU0hBNTEyX1dfSFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcxNWwgPSBTSEE1MTJfV19MW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczBoID0gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0goVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICBjb25zdCBzMGwgPSB1NjQucm90clNMKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTTChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIC8vIHMxIDo9ICh3W2ktMl0gcmlnaHRyb3RhdGUgMTkpIHhvciAod1tpLTJdIHJpZ2h0cm90YXRlIDYxKSB4b3IgKHdbaS0yXSByaWdodHNoaWZ0IDYpXG4gICAgICAgICAgICBjb25zdCBXMmggPSBTSEE1MTJfV19IW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMmwgPSBTSEE1MTJfV19MW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMWggPSB1NjQucm90clNIKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJIKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0goVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgY29uc3QgczFsID0gdTY0LnJvdHJTTChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCTChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNMKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIC8vIFNIQTI1Nl9XW2ldID0gczAgKyBzMSArIFNIQTI1Nl9XW2kgLSA3XSArIFNIQTI1Nl9XW2kgLSAxNl07XG4gICAgICAgICAgICBjb25zdCBTVU1sID0gdTY0LmFkZDRMKHMwbCwgczFsLCBTSEE1MTJfV19MW2kgLSA3XSwgU0hBNTEyX1dfTFtpIC0gMTZdKTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWggPSB1NjQuYWRkNEgoU1VNbCwgczBoLCBzMWgsIFNIQTUxMl9XX0hbaSAtIDddLCBTSEE1MTJfV19IW2kgLSAxNl0pO1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IFNVTWggfCAwO1xuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IFNVTWwgfCAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDgwIHJvdW5kc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFMxIDo9IChlIHJpZ2h0cm90YXRlIDE0KSB4b3IgKGUgcmlnaHRyb3RhdGUgMTgpIHhvciAoZSByaWdodHJvdGF0ZSA0MSlcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWggPSB1NjQucm90clNIKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTSChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkgoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTFsID0gdTY0LnJvdHJTTChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0woRWgsIEVsLCAxOCkgXiB1NjQucm90ckJMKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgLy9jb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3QgQ0hJaCA9IChFaCAmIEZoKSBeICh+RWggJiBHaCk7XG4gICAgICAgICAgICBjb25zdCBDSElsID0gKEVsICYgRmwpIF4gKH5FbCAmIEdsKTtcbiAgICAgICAgICAgIC8vIFQxID0gSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTUxMl9LW2ldICsgU0hBNTEyX1dbaV1cbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgVDFsbCA9IHU2NC5hZGQ1TChIbCwgc2lnbWExbCwgQ0hJbCwgU0hBNTEyX0tsW2ldLCBTSEE1MTJfV19MW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxaCA9IHU2NC5hZGQ1SChUMWxsLCBIaCwgc2lnbWExaCwgQ0hJaCwgU0hBNTEyX0toW2ldLCBTSEE1MTJfV19IW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxbCA9IFQxbGwgfCAwO1xuICAgICAgICAgICAgLy8gUzAgOj0gKGEgcmlnaHRyb3RhdGUgMjgpIHhvciAoYSByaWdodHJvdGF0ZSAzNCkgeG9yIChhIHJpZ2h0cm90YXRlIDM5KVxuICAgICAgICAgICAgY29uc3Qgc2lnbWEwaCA9IHU2NC5yb3RyU0goQWgsIEFsLCAyOCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCSChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGwgPSB1NjQucm90clNMKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzOSk7XG4gICAgICAgICAgICBjb25zdCBNQUpoID0gKEFoICYgQmgpIF4gKEFoICYgQ2gpIF4gKEJoICYgQ2gpO1xuICAgICAgICAgICAgY29uc3QgTUFKbCA9IChBbCAmIEJsKSBeIChBbCAmIENsKSBeIChCbCAmIENsKTtcbiAgICAgICAgICAgIEhoID0gR2ggfCAwO1xuICAgICAgICAgICAgSGwgPSBHbCB8IDA7XG4gICAgICAgICAgICBHaCA9IEZoIHwgMDtcbiAgICAgICAgICAgIEdsID0gRmwgfCAwO1xuICAgICAgICAgICAgRmggPSBFaCB8IDA7XG4gICAgICAgICAgICBGbCA9IEVsIHwgMDtcbiAgICAgICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZChEaCB8IDAsIERsIHwgMCwgVDFoIHwgMCwgVDFsIHwgMCkpO1xuICAgICAgICAgICAgRGggPSBDaCB8IDA7XG4gICAgICAgICAgICBEbCA9IENsIHwgMDtcbiAgICAgICAgICAgIENoID0gQmggfCAwO1xuICAgICAgICAgICAgQ2wgPSBCbCB8IDA7XG4gICAgICAgICAgICBCaCA9IEFoIHwgMDtcbiAgICAgICAgICAgIEJsID0gQWwgfCAwO1xuICAgICAgICAgICAgY29uc3QgQWxsID0gdTY0LmFkZDNMKFQxbCwgc2lnbWEwbCwgTUFKbCk7XG4gICAgICAgICAgICBBaCA9IHU2NC5hZGQzSChBbGwsIFQxaCwgc2lnbWEwaCwgTUFKaCk7XG4gICAgICAgICAgICBBbCA9IEFsbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgKHsgaDogQWgsIGw6IEFsIH0gPSB1NjQuYWRkKHRoaXMuQWggfCAwLCB0aGlzLkFsIHwgMCwgQWggfCAwLCBBbCB8IDApKTtcbiAgICAgICAgKHsgaDogQmgsIGw6IEJsIH0gPSB1NjQuYWRkKHRoaXMuQmggfCAwLCB0aGlzLkJsIHwgMCwgQmggfCAwLCBCbCB8IDApKTtcbiAgICAgICAgKHsgaDogQ2gsIGw6IENsIH0gPSB1NjQuYWRkKHRoaXMuQ2ggfCAwLCB0aGlzLkNsIHwgMCwgQ2ggfCAwLCBDbCB8IDApKTtcbiAgICAgICAgKHsgaDogRGgsIGw6IERsIH0gPSB1NjQuYWRkKHRoaXMuRGggfCAwLCB0aGlzLkRsIHwgMCwgRGggfCAwLCBEbCB8IDApKTtcbiAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKHRoaXMuRWggfCAwLCB0aGlzLkVsIHwgMCwgRWggfCAwLCBFbCB8IDApKTtcbiAgICAgICAgKHsgaDogRmgsIGw6IEZsIH0gPSB1NjQuYWRkKHRoaXMuRmggfCAwLCB0aGlzLkZsIHwgMCwgRmggfCAwLCBGbCB8IDApKTtcbiAgICAgICAgKHsgaDogR2gsIGw6IEdsIH0gPSB1NjQuYWRkKHRoaXMuR2ggfCAwLCB0aGlzLkdsIHwgMCwgR2ggfCAwLCBHbCB8IDApKTtcbiAgICAgICAgKHsgaDogSGgsIGw6IEhsIH0gPSB1NjQuYWRkKHRoaXMuSGggfCAwLCB0aGlzLkhsIHwgMCwgSGggfCAwLCBIbCB8IDApKTtcbiAgICAgICAgdGhpcy5zZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBjbGVhbihTSEE1MTJfV19ILCBTSEE1MTJfV19MKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYW4odGhpcy5idWZmZXIpO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG4vKiogSW50ZXJuYWwgU0hBMi01MTIgaGFzaCBjbGFzcy4gKi9cbmV4cG9ydCBjbGFzcyBfU0hBNTEyIGV4dGVuZHMgU0hBMl82NEIge1xuICAgIEFoID0gU0hBNTEyX0lWWzBdIHwgMDtcbiAgICBBbCA9IFNIQTUxMl9JVlsxXSB8IDA7XG4gICAgQmggPSBTSEE1MTJfSVZbMl0gfCAwO1xuICAgIEJsID0gU0hBNTEyX0lWWzNdIHwgMDtcbiAgICBDaCA9IFNIQTUxMl9JVls0XSB8IDA7XG4gICAgQ2wgPSBTSEE1MTJfSVZbNV0gfCAwO1xuICAgIERoID0gU0hBNTEyX0lWWzZdIHwgMDtcbiAgICBEbCA9IFNIQTUxMl9JVls3XSB8IDA7XG4gICAgRWggPSBTSEE1MTJfSVZbOF0gfCAwO1xuICAgIEVsID0gU0hBNTEyX0lWWzldIHwgMDtcbiAgICBGaCA9IFNIQTUxMl9JVlsxMF0gfCAwO1xuICAgIEZsID0gU0hBNTEyX0lWWzExXSB8IDA7XG4gICAgR2ggPSBTSEE1MTJfSVZbMTJdIHwgMDtcbiAgICBHbCA9IFNIQTUxMl9JVlsxM10gfCAwO1xuICAgIEhoID0gU0hBNTEyX0lWWzE0XSB8IDA7XG4gICAgSGwgPSBTSEE1MTJfSVZbMTVdIHwgMDtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQpO1xuICAgIH1cbn1cbi8qKiBJbnRlcm5hbCBTSEEyLTM4NCBoYXNoIGNsYXNzLiAqL1xuZXhwb3J0IGNsYXNzIF9TSEEzODQgZXh0ZW5kcyBTSEEyXzY0QiB7XG4gICAgQWggPSBTSEEzODRfSVZbMF0gfCAwO1xuICAgIEFsID0gU0hBMzg0X0lWWzFdIHwgMDtcbiAgICBCaCA9IFNIQTM4NF9JVlsyXSB8IDA7XG4gICAgQmwgPSBTSEEzODRfSVZbM10gfCAwO1xuICAgIENoID0gU0hBMzg0X0lWWzRdIHwgMDtcbiAgICBDbCA9IFNIQTM4NF9JVls1XSB8IDA7XG4gICAgRGggPSBTSEEzODRfSVZbNl0gfCAwO1xuICAgIERsID0gU0hBMzg0X0lWWzddIHwgMDtcbiAgICBFaCA9IFNIQTM4NF9JVls4XSB8IDA7XG4gICAgRWwgPSBTSEEzODRfSVZbOV0gfCAwO1xuICAgIEZoID0gU0hBMzg0X0lWWzEwXSB8IDA7XG4gICAgRmwgPSBTSEEzODRfSVZbMTFdIHwgMDtcbiAgICBHaCA9IFNIQTM4NF9JVlsxMl0gfCAwO1xuICAgIEdsID0gU0hBMzg0X0lWWzEzXSB8IDA7XG4gICAgSGggPSBTSEEzODRfSVZbMTRdIHwgMDtcbiAgICBIbCA9IFNIQTM4NF9JVlsxNV0gfCAwO1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig0OCk7XG4gICAgfVxufVxuLyoqXG4gKiBUcnVuY2F0ZWQgU0hBNTEyLzI1NiBhbmQgU0hBNTEyLzIyNC5cbiAqIFNIQTUxMl9JViBpcyBYT1JlZCB3aXRoIDB4YTVhNWE1YTVhNWE1YTVhNSwgdGhlbiB1c2VkIGFzIFwiaW50ZXJtZWRpYXJ5XCIgSVYgb2YgU0hBNTEyL3QuXG4gKiBUaGVuIHQgaGFzaGVzIHN0cmluZyB0byBwcm9kdWNlIHJlc3VsdCBJVi5cbiAqIFNlZSBgdGVzdC9taXNjL3NoYTItZ2VuLWl2LmpzYC5cbiAqL1xuLyoqIFNIQTUxMi8yMjQgSVYgKi9cbmNvbnN0IFQyMjRfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg4YzNkMzdjOCwgMHgxOTU0NGRhMiwgMHg3M2UxOTk2NiwgMHg4OWRjZDRkNiwgMHgxZGZhYjdhZSwgMHgzMmZmOWM4MiwgMHg2NzlkZDUxNCwgMHg1ODJmOWZjZixcbiAgICAweDBmNmQyYjY5LCAweDdiZDQ0ZGE4LCAweDc3ZTM2ZjczLCAweDA0YzQ4OTQyLCAweDNmOWQ4NWE4LCAweDZhMWQzNmM4LCAweDExMTJlNmFkLCAweDkxZDY5MmExLFxuXSk7XG4vKiogU0hBNTEyLzI1NiBJViAqL1xuY29uc3QgVDI1Nl9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweDIyMzEyMTk0LCAweGZjMmJmNzJjLCAweDlmNTU1ZmEzLCAweGM4NGM2NGMyLCAweDIzOTNiODZiLCAweDZmNTNiMTUxLCAweDk2Mzg3NzE5LCAweDU5NDBlYWJkLFxuICAgIDB4OTYyODNlZTIsIDB4YTg4ZWZmZTMsIDB4YmU1ZTFlMjUsIDB4NTM4NjM5OTIsIDB4MmIwMTk5ZmMsIDB4MmM4NWI4YWEsIDB4MGViNzJkZGMsIDB4ODFjNTJjYTIsXG5dKTtcbi8qKiBJbnRlcm5hbCBTSEEyLTUxMi8yMjQgaGFzaCBjbGFzcy4gKi9cbmV4cG9ydCBjbGFzcyBfU0hBNTEyXzIyNCBleHRlbmRzIFNIQTJfNjRCIHtcbiAgICBBaCA9IFQyMjRfSVZbMF0gfCAwO1xuICAgIEFsID0gVDIyNF9JVlsxXSB8IDA7XG4gICAgQmggPSBUMjI0X0lWWzJdIHwgMDtcbiAgICBCbCA9IFQyMjRfSVZbM10gfCAwO1xuICAgIENoID0gVDIyNF9JVls0XSB8IDA7XG4gICAgQ2wgPSBUMjI0X0lWWzVdIHwgMDtcbiAgICBEaCA9IFQyMjRfSVZbNl0gfCAwO1xuICAgIERsID0gVDIyNF9JVls3XSB8IDA7XG4gICAgRWggPSBUMjI0X0lWWzhdIHwgMDtcbiAgICBFbCA9IFQyMjRfSVZbOV0gfCAwO1xuICAgIEZoID0gVDIyNF9JVlsxMF0gfCAwO1xuICAgIEZsID0gVDIyNF9JVlsxMV0gfCAwO1xuICAgIEdoID0gVDIyNF9JVlsxMl0gfCAwO1xuICAgIEdsID0gVDIyNF9JVlsxM10gfCAwO1xuICAgIEhoID0gVDIyNF9JVlsxNF0gfCAwO1xuICAgIEhsID0gVDIyNF9JVlsxNV0gfCAwO1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigyOCk7XG4gICAgfVxufVxuLyoqIEludGVybmFsIFNIQTItNTEyLzI1NiBoYXNoIGNsYXNzLiAqL1xuZXhwb3J0IGNsYXNzIF9TSEE1MTJfMjU2IGV4dGVuZHMgU0hBMl82NEIge1xuICAgIEFoID0gVDI1Nl9JVlswXSB8IDA7XG4gICAgQWwgPSBUMjU2X0lWWzFdIHwgMDtcbiAgICBCaCA9IFQyNTZfSVZbMl0gfCAwO1xuICAgIEJsID0gVDI1Nl9JVlszXSB8IDA7XG4gICAgQ2ggPSBUMjU2X0lWWzRdIHwgMDtcbiAgICBDbCA9IFQyNTZfSVZbNV0gfCAwO1xuICAgIERoID0gVDI1Nl9JVls2XSB8IDA7XG4gICAgRGwgPSBUMjU2X0lWWzddIHwgMDtcbiAgICBFaCA9IFQyNTZfSVZbOF0gfCAwO1xuICAgIEVsID0gVDI1Nl9JVls5XSB8IDA7XG4gICAgRmggPSBUMjU2X0lWWzEwXSB8IDA7XG4gICAgRmwgPSBUMjU2X0lWWzExXSB8IDA7XG4gICAgR2ggPSBUMjU2X0lWWzEyXSB8IDA7XG4gICAgR2wgPSBUMjU2X0lWWzEzXSB8IDA7XG4gICAgSGggPSBUMjU2X0lWWzE0XSB8IDA7XG4gICAgSGwgPSBUMjU2X0lWWzE1XSB8IDA7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDMyKTtcbiAgICB9XG59XG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb24gZnJvbSBSRkMgNDYzNC4gSW4gSlMgaXQncyB0aGUgZmFzdGVzdDogZXZlbiBmYXN0ZXIgdGhhbiBCbGFrZTMuIFNvbWUgaW5mbzpcbiAqXG4gKiAtIFRyeWluZyAyXjEyOCBoYXNoZXMgd291bGQgZ2V0IDUwJSBjaGFuY2Ugb2YgY29sbGlzaW9uLCB1c2luZyBiaXJ0aGRheSBhdHRhY2suXG4gKiAtIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNzAgaGFzaGVzL3NlYyAoMl45NSBoYXNoZXMveWVhcikgYXMgcGVyIDIwMjUuXG4gKiAtIEVhY2ggc2hhMjU2IGhhc2ggaXMgZXhlY3V0aW5nIDJeMTggYml0IG9wZXJhdGlvbnMuXG4gKiAtIEdvb2QgMjAyNCBBU0lDcyBjYW4gZG8gMjAwVGgvc2VjIHdpdGggMzUwMCB3YXR0cyBvZiBwb3dlciwgY29ycmVzcG9uZGluZyB0byAyXjM2IGhhc2hlcy9qb3VsZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoKCkgPT4gbmV3IF9TSEEyNTYoKSwgXG4vKiBAX19QVVJFX18gKi8gb2lkTmlzdCgweDAxKSk7XG4vKiogU0hBMi0yMjQgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0ICovXG5leHBvcnQgY29uc3Qgc2hhMjI0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgX1NIQTIyNCgpLCBcbi8qIEBfX1BVUkVfXyAqLyBvaWROaXN0KDB4MDQpKTtcbi8qKiBTSEEyLTUxMiBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQuICovXG5leHBvcnQgY29uc3Qgc2hhNTEyID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgX1NIQTUxMigpLCBcbi8qIEBfX1BVUkVfXyAqLyBvaWROaXN0KDB4MDMpKTtcbi8qKiBTSEEyLTM4NCBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQuICovXG5leHBvcnQgY29uc3Qgc2hhMzg0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgX1NIQTM4NCgpLCBcbi8qIEBfX1BVUkVfXyAqLyBvaWROaXN0KDB4MDIpKTtcbi8qKlxuICogU0hBMi01MTIvMjU2IFwidHJ1bmNhdGVkXCIgaGFzaCBmdW5jdGlvbiwgd2l0aCBpbXByb3ZlZCByZXNpc3RhbmNlIHRvIGxlbmd0aCBleHRlbnNpb24gYXR0YWNrcy5cbiAqIFNlZSB0aGUgcGFwZXIgb24gW3RydW5jYXRlZCBTSEE1MTJdKGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTAvNTQ4LnBkZikuXG4gKi9cbmV4cG9ydCBjb25zdCBzaGE1MTJfMjU2ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgX1NIQTUxMl8yNTYoKSwgXG4vKiBAX19QVVJFX18gKi8gb2lkTmlzdCgweDA2KSk7XG4vKipcbiAqIFNIQTItNTEyLzIyNCBcInRydW5jYXRlZFwiIGhhc2ggZnVuY3Rpb24sIHdpdGggaW1wcm92ZWQgcmVzaXN0YW5jZSB0byBsZW5ndGggZXh0ZW5zaW9uIGF0dGFja3MuXG4gKiBTZWUgdGhlIHBhcGVyIG9uIFt0cnVuY2F0ZWQgU0hBNTEyXShodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEwLzU0OC5wZGYpLlxuICovXG5leHBvcnQgY29uc3Qgc2hhNTEyXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoKCkgPT4gbmV3IF9TSEE1MTJfMjI0KCksIFxuLyogQF9fUFVSRV9fICovIG9pZE5pc3QoMHgwNSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/@noble/hashes/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   aexists: () => (/* binding */ aexists),\n/* harmony export */   ahash: () => (/* binding */ ahash),\n/* harmony export */   anumber: () => (/* binding */ anumber),\n/* harmony export */   aoutput: () => (/* binding */ aoutput),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   byteSwap: () => (/* binding */ byteSwap),\n/* harmony export */   byteSwap32: () => (/* binding */ byteSwap32),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   clean: () => (/* binding */ clean),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   kdfInputToBytes: () => (/* binding */ kdfInputToBytes),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   oidNist: () => (/* binding */ oidNist),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotl: () => (/* binding */ rotl),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   swap32IfBE: () => (/* binding */ swap32IfBE),\n/* harmony export */   swap8IfBE: () => (/* binding */ swap8IfBE),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes)\n/* harmony export */ });\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nfunction anumber(n, title = '') {\n    if (!Number.isSafeInteger(n) || n < 0) {\n        const prefix = title && `\"${title}\" `;\n        throw new Error(`${prefix}expected integer >= 0, got ${n}`);\n    }\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(value, length, title = '') {\n    const bytes = isBytes(value);\n    const len = value?.length;\n    const needsLen = length !== undefined;\n    if (!bytes || (needsLen && len !== length)) {\n        const prefix = title && `\"${title}\" `;\n        const ofLen = needsLen ? ` of length ${length}` : '';\n        const got = bytes ? `length=${len}` : `type=${typeof value}`;\n        throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n    }\n    return value;\n}\n/** Asserts something is hash */\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash must wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nfunction aoutput(out, instance) {\n    abytes(out, undefined, 'digestInto() output');\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('\"digestInto() output\" expected to be of length >=' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nfunction u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nfunction u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nfunction clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nfunction createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nfunction rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nfunction rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nconst isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nfunction byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nconst swap8IfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** In place byte swap for Uint32Array */\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nconst swap32IfBE = isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nconst nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * Built-in doesn't validate input to be string: we do the check.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nfunction kdfInputToBytes(data, errorTitle = '') {\n    if (typeof data === 'string')\n        return utf8ToBytes(data);\n    return abytes(data, undefined, errorTitle);\n}\n/** Copies several Uint8Arrays into one. */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n/** Merges default options and passed options. */\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options must be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** Creates function with outputLen, blockLen, create properties from a class constructor. */\nfunction createHasher(hashCons, info = {}) {\n    const hashC = (msg, opts) => hashCons(opts).update(msg).digest();\n    const tmp = hashCons(undefined);\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    Object.assign(hashC, info);\n    return Object.freeze(hashC);\n}\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nfunction randomBytes(bytesLength = 32) {\n    const cr = typeof globalThis === 'object' ? globalThis.crypto : null;\n    if (typeof cr?.getRandomValues !== 'function')\n        throw new Error('crypto.getRandomValues must be defined');\n    return cr.getRandomValues(new Uint8Array(bytesLength));\n}\n/** Creates OID opts for NIST hashes, with prefix 06 09 60 86 48 01 65 03 04 02. */\nconst oidNist = (suffix) => ({\n    oid: Uint8Array.from([0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, suffix]),\n});\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0NBQW9DLE1BQU07QUFDMUMsMkJBQTJCLE9BQU8sNkJBQTZCLEVBQUU7QUFDakU7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxNQUFNO0FBQzFDLCtDQUErQyxPQUFPO0FBQ3RELHNDQUFzQyxJQUFJLFlBQVksYUFBYTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUCxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08seUNBQXlDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL2F1dG9wbGFuY2FtLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvdXRpbHMuanM/MmJhYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdGllcyBmb3IgaGV4LCBieXRlcywgQ1NQUk5HLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vKiogQ2hlY2tzIGlmIHNvbWV0aGluZyBpcyBVaW50OEFycmF5LiBCZSBjYXJlZnVsOiBub2RlanMgQnVmZmVyIHdpbGwgcmV0dXJuIHRydWUuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIHBvc2l0aXZlIGludGVnZXIuICovXG5leHBvcnQgZnVuY3Rpb24gYW51bWJlcihuLCB0aXRsZSA9ICcnKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMCkge1xuICAgICAgICBjb25zdCBwcmVmaXggPSB0aXRsZSAmJiBgXCIke3RpdGxlfVwiIGA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtwcmVmaXh9ZXhwZWN0ZWQgaW50ZWdlciA+PSAwLCBnb3QgJHtufWApO1xuICAgIH1cbn1cbi8qKiBBc3NlcnRzIHNvbWV0aGluZyBpcyBVaW50OEFycmF5LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFieXRlcyh2YWx1ZSwgbGVuZ3RoLCB0aXRsZSA9ICcnKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBpc0J5dGVzKHZhbHVlKTtcbiAgICBjb25zdCBsZW4gPSB2YWx1ZT8ubGVuZ3RoO1xuICAgIGNvbnN0IG5lZWRzTGVuID0gbGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKCFieXRlcyB8fCAobmVlZHNMZW4gJiYgbGVuICE9PSBsZW5ndGgpKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHRpdGxlICYmIGBcIiR7dGl0bGV9XCIgYDtcbiAgICAgICAgY29uc3Qgb2ZMZW4gPSBuZWVkc0xlbiA/IGAgb2YgbGVuZ3RoICR7bGVuZ3RofWAgOiAnJztcbiAgICAgICAgY29uc3QgZ290ID0gYnl0ZXMgPyBgbGVuZ3RoPSR7bGVufWAgOiBgdHlwZT0ke3R5cGVvZiB2YWx1ZX1gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJlZml4ICsgJ2V4cGVjdGVkIFVpbnQ4QXJyYXknICsgb2ZMZW4gKyAnLCBnb3QgJyArIGdvdCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKiBBc3NlcnRzIHNvbWV0aGluZyBpcyBoYXNoICovXG5leHBvcnQgZnVuY3Rpb24gYWhhc2goaCkge1xuICAgIGlmICh0eXBlb2YgaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBtdXN0IHdyYXBwZWQgYnkgdXRpbHMuY3JlYXRlSGFzaGVyJyk7XG4gICAgYW51bWJlcihoLm91dHB1dExlbik7XG4gICAgYW51bWJlcihoLmJsb2NrTGVuKTtcbn1cbi8qKiBBc3NlcnRzIGEgaGFzaCBpbnN0YW5jZSBoYXMgbm90IGJlZW4gZGVzdHJveWVkIC8gZmluaXNoZWQgKi9cbmV4cG9ydCBmdW5jdGlvbiBhZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG4vKiogQXNzZXJ0cyBvdXRwdXQgaXMgcHJvcGVybHktc2l6ZWQgYnl0ZSBhcnJheSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGFieXRlcyhvdXQsIHVuZGVmaW5lZCwgJ2RpZ2VzdEludG8oKSBvdXRwdXQnKTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImRpZ2VzdEludG8oKSBvdXRwdXRcIiBleHBlY3RlZCB0byBiZSBvZiBsZW5ndGggPj0nICsgbWluKTtcbiAgICB9XG59XG4vKiogQ2FzdCB1OCAvIHUxNiAvIHUzMiB0byB1OC4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1OChhcnIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbn1cbi8qKiBDYXN0IHU4IC8gdTE2IC8gdTMyIHRvIHUzMi4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1MzIoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbn1cbi8qKiBaZXJvaXplIGEgYnl0ZSBhcnJheS4gV2FybmluZzogSlMgcHJvdmlkZXMgbm8gZ3VhcmFudGVlcy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbiguLi5hcnJheXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheXNbaV0uZmlsbCgwKTtcbiAgICB9XG59XG4vKiogQ3JlYXRlIERhdGFWaWV3IG9mIGFuIGFycmF5IGZvciBlYXN5IGJ5dGUtbGV2ZWwgbWFuaXB1bGF0aW9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZpZXcoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xufVxuLyoqIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdHIod29yZCwgc2hpZnQpIHtcbiAgICByZXR1cm4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG59XG4vKiogVGhlIHJvdGF0ZSBsZWZ0IChjaXJjdWxhciBsZWZ0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGwod29yZCwgc2hpZnQpIHtcbiAgICByZXR1cm4gKHdvcmQgPDwgc2hpZnQpIHwgKCh3b3JkID4+PiAoMzIgLSBzaGlmdCkpID4+PiAwKTtcbn1cbi8qKiBJcyBjdXJyZW50IHBsYXRmb3JtIGxpdHRsZS1lbmRpYW4/IE1vc3QgYXJlLiBCaWctRW5kaWFuIHBsYXRmb3JtOiBJQk0gKi9cbmV4cG9ydCBjb25zdCBpc0xFID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0KSgpO1xuLyoqIFRoZSBieXRlIHN3YXAgb3BlcmF0aW9uIGZvciB1aW50MzIgKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlU3dhcCh3b3JkKSB7XG4gICAgcmV0dXJuICgoKHdvcmQgPDwgMjQpICYgMHhmZjAwMDAwMCkgfFxuICAgICAgICAoKHdvcmQgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICAgICAoKHdvcmQgPj4+IDgpICYgMHhmZjAwKSB8XG4gICAgICAgICgod29yZCA+Pj4gMjQpICYgMHhmZikpO1xufVxuLyoqIENvbmRpdGlvbmFsbHkgYnl0ZSBzd2FwIGlmIG9uIGEgYmlnLWVuZGlhbiBwbGF0Zm9ybSAqL1xuZXhwb3J0IGNvbnN0IHN3YXA4SWZCRSA9IGlzTEVcbiAgICA/IChuKSA9PiBuXG4gICAgOiAobikgPT4gYnl0ZVN3YXAobik7XG4vKiogSW4gcGxhY2UgYnl0ZSBzd2FwIGZvciBVaW50MzJBcnJheSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVTd2FwMzIoYXJyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYnl0ZVN3YXAoYXJyW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmV4cG9ydCBjb25zdCBzd2FwMzJJZkJFID0gaXNMRVxuICAgID8gKHUpID0+IHVcbiAgICA6IGJ5dGVTd2FwMzI7XG4vLyBCdWlsdC1pbiBoZXggY29udmVyc2lvbiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX3VpbnQ4YXJyYXlfZnJvbWhleFxuY29uc3QgaGFzSGV4QnVpbHRpbiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gXG4vLyBAdHMtaWdub3JlXG50eXBlb2YgVWludDhBcnJheS5mcm9tKFtdKS50b0hleCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgVWludDhBcnJheS5mcm9tSGV4ID09PSAnZnVuY3Rpb24nKSgpO1xuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIENvbnZlcnQgYnl0ZSBhcnJheSB0byBoZXggc3RyaW5nLiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoaGFzSGV4QnVpbHRpbilcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnRvSGV4KCk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBBOiA2NSwgRjogNzAsIGE6IDk3LCBmOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2gpIHtcbiAgICBpZiAoY2ggPj0gYXNjaWlzLl8wICYmIGNoIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoIC0gYXNjaWlzLl8wOyAvLyAnMicgPT4gNTAtNDhcbiAgICBpZiAoY2ggPj0gYXNjaWlzLkEgJiYgY2ggPD0gYXNjaWlzLkYpXG4gICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuQSAtIDEwKTsgLy8gJ0InID0+IDY2LSg2NS0xMClcbiAgICBpZiAoY2ggPj0gYXNjaWlzLmEgJiYgY2ggPD0gYXNjaWlzLmYpXG4gICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuYSAtIDEwKTsgLy8gJ2InID0+IDk4LSg5Ny0xMClcbiAgICByZXR1cm47XG59XG4vKipcbiAqIENvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5LiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChoYXNIZXhCdWlsdGluKVxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tSGV4KGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjsgLy8gbXVsdGlwbHkgZmlyc3Qgb2N0ZXQsIGUuZy4gJ2EzJyA9PiAxMCoxNiszID0+IDE2MCArIDMgPT4gMTYzXG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8qKlxuICogVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbiAqIENhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuICogbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuICovXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vKiogUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZy4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIHN0cmluZyB0byBieXRlcyB1c2luZyBVVEY4IGVuY29kaW5nLlxuICogQnVpbHQtaW4gZG9lc24ndCB2YWxpZGF0ZSBpbnB1dCB0byBiZSBzdHJpbmc6IHdlIGRvIHRoZSBjaGVjay5cbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBVaW50OEFycmF5LmZyb20oWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZyBleHBlY3RlZCcpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8qKlxuICogSGVscGVyIGZvciBLREZzOiBjb25zdW1lcyB1aW50OGFycmF5IG9yIHN0cmluZy5cbiAqIFdoZW4gc3RyaW5nIGlzIHBhc3NlZCwgZG9lcyB1dGY4IGRlY29kaW5nLCB1c2luZyBUZXh0RGVjb2Rlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtkZklucHV0VG9CeXRlcyhkYXRhLCBlcnJvclRpdGxlID0gJycpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgcmV0dXJuIGFieXRlcyhkYXRhLCB1bmRlZmluZWQsIGVycm9yVGl0bGUpO1xufVxuLyoqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIGFieXRlcyhhKTtcbiAgICAgICAgc3VtICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyoqIE1lcmdlcyBkZWZhdWx0IG9wdGlvbnMgYW5kIHBhc3NlZCBvcHRpb25zLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYge30udG9TdHJpbmcuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBtdXN0IGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuLyoqIENyZWF0ZXMgZnVuY3Rpb24gd2l0aCBvdXRwdXRMZW4sIGJsb2NrTGVuLCBjcmVhdGUgcHJvcGVydGllcyBmcm9tIGEgY2xhc3MgY29uc3RydWN0b3IuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaGVyKGhhc2hDb25zLCBpbmZvID0ge30pIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZShtc2cpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHVuZGVmaW5lZCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgT2JqZWN0LmFzc2lnbihoYXNoQywgaW5mbyk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoaGFzaEMpO1xufVxuLyoqIENyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBQUk5HLiBVc2VzIGludGVybmFsIE9TLWxldmVsIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYC4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgY29uc3QgY3IgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgPyBnbG9iYWxUaGlzLmNyeXB0byA6IG51bGw7XG4gICAgaWYgKHR5cGVvZiBjcj8uZ2V0UmFuZG9tVmFsdWVzICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuIGNyLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xufVxuLyoqIENyZWF0ZXMgT0lEIG9wdHMgZm9yIE5JU1QgaGFzaGVzLCB3aXRoIHByZWZpeCAwNiAwOSA2MCA4NiA0OCAwMSA2NSAwMyAwNCAwMi4gKi9cbmV4cG9ydCBjb25zdCBvaWROaXN0ID0gKHN1ZmZpeCkgPT4gKHtcbiAgICBvaWQ6IFVpbnQ4QXJyYXkuZnJvbShbMHgwNiwgMHgwOSwgMHg2MCwgMHg4NiwgMHg0OCwgMHgwMSwgMHg2NSwgMHgwMywgMHgwNCwgMHgwMiwgc3VmZml4XSksXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/ciphers/_arx.js":
/*!*********************************************!*\
  !*** ./node_modules/@noble/ciphers/_arx.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _XorStreamPRG: () => (/* binding */ _XorStreamPRG),\n/* harmony export */   createCipher: () => (/* binding */ createCipher),\n/* harmony export */   createPRG: () => (/* binding */ createPRG),\n/* harmony export */   rotl: () => (/* binding */ rotl)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@noble/ciphers/utils.js\");\n/**\n * Basic utils for ARX (add-rotate-xor) salsa and chacha ciphers.\n\nRFC8439 requires multi-step cipher stream, where\nauthKey starts with counter: 0, actual msg with counter: 1.\n\nFor this, we need a way to re-use nonce / counter:\n\n    const counter = new Uint8Array(4);\n    chacha(..., counter, ...); // counter is now 1\n    chacha(..., counter, ...); // counter is now 2\n\nThis is complicated:\n\n- 32-bit counters are enough, no need for 64-bit: max ArrayBuffer size in JS is 4GB\n- Original papers don't allow mutating counters\n- Counter overflow is undefined [^1]\n- Idea A: allow providing (nonce | counter) instead of just nonce, re-use it\n- Caveat: Cannot be re-used through all cases:\n- * chacha has (counter | nonce)\n- * xchacha has (nonce16 | counter | nonce16)\n- Idea B: separate nonce / counter and provide separate API for counter re-use\n- Caveat: there are different counter sizes depending on an algorithm.\n- salsa & chacha also differ in structures of key & sigma:\n  salsa20:      s[0] | k(4) | s[1] | nonce(2) | cnt(2) | s[2] | k(4) | s[3]\n  chacha:       s(4) | k(8) | cnt(1) | nonce(3)\n  chacha20orig: s(4) | k(8) | cnt(2) | nonce(2)\n- Idea C: helper method such as `setSalsaState(key, nonce, sigma, data)`\n- Caveat: we can't re-use counter array\n\nxchacha [^2] uses the subkey and remaining 8 byte nonce with ChaCha20 as normal\n(prefixed by 4 NUL bytes, since [RFC8439] specifies a 12-byte nonce).\n\n[^1]: https://mailarchive.ietf.org/arch/msg/cfrg/gsOnTJzcbgG6OqD8Sc0GO5aR_tU/\n[^2]: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#appendix-A.2\n\n * @module\n */\n\n// Replaces `TextEncoder`, which is not available in all environments\nconst encodeStr = (str) => Uint8Array.from(str.split(''), (c) => c.charCodeAt(0));\nconst sigma16 = encodeStr('expand 16-byte k');\nconst sigma32 = encodeStr('expand 32-byte k');\nconst sigma16_32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(sigma16);\nconst sigma32_32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(sigma32);\n/** Rotate left. */\nfunction rotl(a, b) {\n    return (a << b) | (a >>> (32 - b));\n}\n// Is byte array aligned to 4 byte offset (u32)?\nfunction isAligned32(b) {\n    return b.byteOffset % 4 === 0;\n}\n// Salsa and Chacha block length is always 512-bit\nconst BLOCK_LEN = 64;\nconst BLOCK_LEN32 = 16;\n// new Uint32Array([2**32])   // => Uint32Array(1) [ 0 ]\n// new Uint32Array([2**32-1]) // => Uint32Array(1) [ 4294967295 ]\nconst MAX_COUNTER = 2 ** 32 - 1;\nconst U32_EMPTY = Uint32Array.of();\nfunction runCipher(core, sigma, key, nonce, data, output, counter, rounds) {\n    const len = data.length;\n    const block = new Uint8Array(BLOCK_LEN);\n    const b32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(block);\n    // Make sure that buffers aligned to 4 bytes\n    const isAligned = isAligned32(data) && isAligned32(output);\n    const d32 = isAligned ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(data) : U32_EMPTY;\n    const o32 = isAligned ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(output) : U32_EMPTY;\n    for (let pos = 0; pos < len; counter++) {\n        core(sigma, key, nonce, b32, counter, rounds);\n        if (counter >= MAX_COUNTER)\n            throw new Error('arx: counter overflow');\n        const take = Math.min(BLOCK_LEN, len - pos);\n        // aligned to 4 bytes\n        if (isAligned && take === BLOCK_LEN) {\n            const pos32 = pos / 4;\n            if (pos % 4 !== 0)\n                throw new Error('arx: invalid block position');\n            for (let j = 0, posj; j < BLOCK_LEN32; j++) {\n                posj = pos32 + j;\n                o32[posj] = d32[posj] ^ b32[j];\n            }\n            pos += BLOCK_LEN;\n            continue;\n        }\n        for (let j = 0, posj; j < take; j++) {\n            posj = pos + j;\n            output[posj] = data[posj] ^ block[j];\n        }\n        pos += take;\n    }\n}\n/** Creates ARX-like (ChaCha, Salsa) cipher stream from core function. */\nfunction createCipher(core, opts) {\n    const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.checkOpts)({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);\n    if (typeof core !== 'function')\n        throw new Error('core must be a function');\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(counterLength);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(rounds);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(counterRight);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(allowShortKeys);\n    return (key, nonce, data, output, counter = 0) => {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(key, undefined, 'key');\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(nonce, undefined, 'nonce');\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(data, undefined, 'data');\n        const len = data.length;\n        if (output === undefined)\n            output = new Uint8Array(len);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(output, undefined, 'output');\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(counter);\n        if (counter < 0 || counter >= MAX_COUNTER)\n            throw new Error('arx: counter overflow');\n        if (output.length < len)\n            throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);\n        const toClean = [];\n        // Key & sigma\n        // key=16 -> sigma16, k=key|key\n        // key=32 -> sigma32, k=key\n        let l = key.length;\n        let k;\n        let sigma;\n        if (l === 32) {\n            toClean.push((k = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.copyBytes)(key)));\n            sigma = sigma32_32;\n        }\n        else if (l === 16 && allowShortKeys) {\n            k = new Uint8Array(32);\n            k.set(key);\n            k.set(key, 16);\n            sigma = sigma16_32;\n            toClean.push(k);\n        }\n        else {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(key, 32, 'arx key');\n            throw new Error('invalid key size');\n            // throw new Error(`\"arx key\" expected Uint8Array of length 32, got length=${l}`);\n        }\n        // Nonce\n        // salsa20:      8   (8-byte counter)\n        // chacha20orig: 8   (8-byte counter)\n        // chacha20:     12  (4-byte counter)\n        // xsalsa20:     24  (16 -> hsalsa,  8 -> old nonce)\n        // xchacha20:    24  (16 -> hchacha, 8 -> old nonce)\n        // Align nonce to 4 bytes\n        if (!isAligned32(nonce))\n            toClean.push((nonce = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.copyBytes)(nonce)));\n        const k32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(k);\n        // hsalsa & hchacha: handle extended nonce\n        if (extendNonceFn) {\n            if (nonce.length !== 24)\n                throw new Error(`arx: extended nonce must be 24 bytes`);\n            extendNonceFn(sigma, k32, (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(nonce.subarray(0, 16)), k32);\n            nonce = nonce.subarray(16);\n        }\n        // Handle nonce counter\n        const nonceNcLen = 16 - counterLength;\n        if (nonceNcLen !== nonce.length)\n            throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);\n        // Pad counter when nonce is 64 bit\n        if (nonceNcLen !== 12) {\n            const nc = new Uint8Array(12);\n            nc.set(nonce, counterRight ? 0 : 12 - nonce.length);\n            nonce = nc;\n            toClean.push(nonce);\n        }\n        const n32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(nonce);\n        runCipher(core, sigma, k32, n32, data, output, counter, rounds);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(...toClean);\n        return output;\n    };\n}\n/** Internal class which wraps chacha20 or chacha8 to create CSPRNG. */\nclass _XorStreamPRG {\n    blockLen;\n    keyLen;\n    nonceLen;\n    state;\n    buf;\n    key;\n    nonce;\n    pos;\n    ctr;\n    cipher;\n    constructor(cipher, blockLen, keyLen, nonceLen, seed) {\n        this.cipher = cipher;\n        this.blockLen = blockLen;\n        this.keyLen = keyLen;\n        this.nonceLen = nonceLen;\n        this.state = new Uint8Array(this.keyLen + this.nonceLen);\n        this.reseed(seed);\n        this.ctr = 0;\n        this.pos = this.blockLen;\n        this.buf = new Uint8Array(this.blockLen);\n        this.key = this.state.subarray(0, this.keyLen);\n        this.nonce = this.state.subarray(this.keyLen);\n    }\n    reseed(seed) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(seed);\n        if (!seed || seed.length === 0)\n            throw new Error('entropy required');\n        for (let i = 0; i < seed.length; i++)\n            this.state[i % this.state.length] ^= seed[i];\n        this.ctr = 0;\n        this.pos = this.blockLen;\n    }\n    addEntropy(seed) {\n        this.state.set(this.randomBytes(this.state.length));\n        this.reseed(seed);\n    }\n    randomBytes(len) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(len);\n        if (len === 0)\n            return new Uint8Array(0);\n        const out = new Uint8Array(len);\n        let outPos = 0;\n        // Leftovers\n        if (this.pos < this.blockLen) {\n            const take = Math.min(len, this.blockLen - this.pos);\n            out.set(this.buf.subarray(this.pos, this.pos + take), 0);\n            this.pos += take;\n            outPos += take;\n            if (outPos === len)\n                return out; // fast path\n        }\n        // Full blocks directly to out\n        const blocks = Math.floor((len - outPos) / this.blockLen);\n        if (blocks > 0) {\n            const blockBytes = blocks * this.blockLen;\n            const b = out.subarray(outPos, outPos + blockBytes);\n            this.cipher(this.key, this.nonce, b, b, this.ctr);\n            this.ctr += blocks;\n            outPos += blockBytes;\n        }\n        // Save leftovers\n        const left = len - outPos;\n        if (left > 0) {\n            this.buf.fill(0);\n            // NOTE: cipher will handle overflow\n            this.cipher(this.key, this.nonce, this.buf, this.buf, this.ctr++);\n            out.set(this.buf.subarray(0, left), outPos);\n            this.pos = left;\n        }\n        return out;\n    }\n    clone() {\n        return new _XorStreamPRG(this.cipher, this.blockLen, this.keyLen, this.nonceLen, this.randomBytes(this.state.length));\n    }\n    clean() {\n        this.pos = 0;\n        this.ctr = 0;\n        this.buf.fill(0);\n        this.state.fill(0);\n    }\n}\nconst createPRG = (cipher, blockLen, keyLen, nonceLen) => {\n    return (seed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(32)) => new _XorStreamPRG(cipher, blockLen, keyLen, nonceLen, seed);\n};\n//# sourceMappingURL=_arx.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2NpcGhlcnMvX2FyeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQiwrQkFBK0I7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNvRztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4Q0FBRztBQUN0QixtQkFBbUIsOENBQUc7QUFDdEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhDQUFHO0FBQ25CO0FBQ0E7QUFDQSw0QkFBNEIsOENBQUc7QUFDL0IsNEJBQTRCLDhDQUFHO0FBQy9CLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVkscUVBQXFFLEVBQUUsb0RBQVMsR0FBRywwRUFBMEU7QUFDeks7QUFDQTtBQUNBLElBQUksa0RBQU87QUFDWCxJQUFJLGtEQUFPO0FBQ1gsSUFBSSxnREFBSztBQUNULElBQUksZ0RBQUs7QUFDVDtBQUNBLFFBQVEsaURBQU07QUFDZCxRQUFRLGlEQUFNO0FBQ2QsUUFBUSxpREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaURBQU07QUFDZCxRQUFRLGtEQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGNBQWMsMEJBQTBCLElBQUk7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvREFBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaURBQU07QUFDbEI7QUFDQSx5RkFBeUYsRUFBRTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0RBQVM7QUFDM0Msb0JBQW9CLDhDQUFHO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDhDQUFHO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsWUFBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4Q0FBRztBQUN2QjtBQUNBLFFBQVEsZ0RBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpREFBTTtBQUNkO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxtQkFBbUIsc0RBQVc7QUFDOUI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2F1dG9wbGFuY2FtLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL19hcnguanM/MTBmMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEJhc2ljIHV0aWxzIGZvciBBUlggKGFkZC1yb3RhdGUteG9yKSBzYWxzYSBhbmQgY2hhY2hhIGNpcGhlcnMuXG5cblJGQzg0MzkgcmVxdWlyZXMgbXVsdGktc3RlcCBjaXBoZXIgc3RyZWFtLCB3aGVyZVxuYXV0aEtleSBzdGFydHMgd2l0aCBjb3VudGVyOiAwLCBhY3R1YWwgbXNnIHdpdGggY291bnRlcjogMS5cblxuRm9yIHRoaXMsIHdlIG5lZWQgYSB3YXkgdG8gcmUtdXNlIG5vbmNlIC8gY291bnRlcjpcblxuICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBjaGFjaGEoLi4uLCBjb3VudGVyLCAuLi4pOyAvLyBjb3VudGVyIGlzIG5vdyAxXG4gICAgY2hhY2hhKC4uLiwgY291bnRlciwgLi4uKTsgLy8gY291bnRlciBpcyBub3cgMlxuXG5UaGlzIGlzIGNvbXBsaWNhdGVkOlxuXG4tIDMyLWJpdCBjb3VudGVycyBhcmUgZW5vdWdoLCBubyBuZWVkIGZvciA2NC1iaXQ6IG1heCBBcnJheUJ1ZmZlciBzaXplIGluIEpTIGlzIDRHQlxuLSBPcmlnaW5hbCBwYXBlcnMgZG9uJ3QgYWxsb3cgbXV0YXRpbmcgY291bnRlcnNcbi0gQ291bnRlciBvdmVyZmxvdyBpcyB1bmRlZmluZWQgW14xXVxuLSBJZGVhIEE6IGFsbG93IHByb3ZpZGluZyAobm9uY2UgfCBjb3VudGVyKSBpbnN0ZWFkIG9mIGp1c3Qgbm9uY2UsIHJlLXVzZSBpdFxuLSBDYXZlYXQ6IENhbm5vdCBiZSByZS11c2VkIHRocm91Z2ggYWxsIGNhc2VzOlxuLSAqIGNoYWNoYSBoYXMgKGNvdW50ZXIgfCBub25jZSlcbi0gKiB4Y2hhY2hhIGhhcyAobm9uY2UxNiB8IGNvdW50ZXIgfCBub25jZTE2KVxuLSBJZGVhIEI6IHNlcGFyYXRlIG5vbmNlIC8gY291bnRlciBhbmQgcHJvdmlkZSBzZXBhcmF0ZSBBUEkgZm9yIGNvdW50ZXIgcmUtdXNlXG4tIENhdmVhdDogdGhlcmUgYXJlIGRpZmZlcmVudCBjb3VudGVyIHNpemVzIGRlcGVuZGluZyBvbiBhbiBhbGdvcml0aG0uXG4tIHNhbHNhICYgY2hhY2hhIGFsc28gZGlmZmVyIGluIHN0cnVjdHVyZXMgb2Yga2V5ICYgc2lnbWE6XG4gIHNhbHNhMjA6ICAgICAgc1swXSB8IGsoNCkgfCBzWzFdIHwgbm9uY2UoMikgfCBjbnQoMikgfCBzWzJdIHwgayg0KSB8IHNbM11cbiAgY2hhY2hhOiAgICAgICBzKDQpIHwgayg4KSB8IGNudCgxKSB8IG5vbmNlKDMpXG4gIGNoYWNoYTIwb3JpZzogcyg0KSB8IGsoOCkgfCBjbnQoMikgfCBub25jZSgyKVxuLSBJZGVhIEM6IGhlbHBlciBtZXRob2Qgc3VjaCBhcyBgc2V0U2Fsc2FTdGF0ZShrZXksIG5vbmNlLCBzaWdtYSwgZGF0YSlgXG4tIENhdmVhdDogd2UgY2FuJ3QgcmUtdXNlIGNvdW50ZXIgYXJyYXlcblxueGNoYWNoYSBbXjJdIHVzZXMgdGhlIHN1YmtleSBhbmQgcmVtYWluaW5nIDggYnl0ZSBub25jZSB3aXRoIENoYUNoYTIwIGFzIG5vcm1hbFxuKHByZWZpeGVkIGJ5IDQgTlVMIGJ5dGVzLCBzaW5jZSBbUkZDODQzOV0gc3BlY2lmaWVzIGEgMTItYnl0ZSBub25jZSkuXG5cblteMV06IGh0dHBzOi8vbWFpbGFyY2hpdmUuaWV0Zi5vcmcvYXJjaC9tc2cvY2ZyZy9nc09uVEp6Y2JnRzZPcUQ4U2MwR081YVJfdFUvXG5bXjJdOiBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy14Y2hhY2hhI2FwcGVuZGl4LUEuMlxuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IGFib29sLCBhYnl0ZXMsIGFudW1iZXIsIGNoZWNrT3B0cywgY2xlYW4sIGNvcHlCeXRlcywgcmFuZG9tQnl0ZXMsIHUzMiwgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLy8gUmVwbGFjZXMgYFRleHRFbmNvZGVyYCwgd2hpY2ggaXMgbm90IGF2YWlsYWJsZSBpbiBhbGwgZW52aXJvbm1lbnRzXG5jb25zdCBlbmNvZGVTdHIgPSAoc3RyKSA9PiBVaW50OEFycmF5LmZyb20oc3RyLnNwbGl0KCcnKSwgKGMpID0+IGMuY2hhckNvZGVBdCgwKSk7XG5jb25zdCBzaWdtYTE2ID0gZW5jb2RlU3RyKCdleHBhbmQgMTYtYnl0ZSBrJyk7XG5jb25zdCBzaWdtYTMyID0gZW5jb2RlU3RyKCdleHBhbmQgMzItYnl0ZSBrJyk7XG5jb25zdCBzaWdtYTE2XzMyID0gdTMyKHNpZ21hMTYpO1xuY29uc3Qgc2lnbWEzMl8zMiA9IHUzMihzaWdtYTMyKTtcbi8qKiBSb3RhdGUgbGVmdC4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RsKGEsIGIpIHtcbiAgICByZXR1cm4gKGEgPDwgYikgfCAoYSA+Pj4gKDMyIC0gYikpO1xufVxuLy8gSXMgYnl0ZSBhcnJheSBhbGlnbmVkIHRvIDQgYnl0ZSBvZmZzZXQgKHUzMik/XG5mdW5jdGlvbiBpc0FsaWduZWQzMihiKSB7XG4gICAgcmV0dXJuIGIuYnl0ZU9mZnNldCAlIDQgPT09IDA7XG59XG4vLyBTYWxzYSBhbmQgQ2hhY2hhIGJsb2NrIGxlbmd0aCBpcyBhbHdheXMgNTEyLWJpdFxuY29uc3QgQkxPQ0tfTEVOID0gNjQ7XG5jb25zdCBCTE9DS19MRU4zMiA9IDE2O1xuLy8gbmV3IFVpbnQzMkFycmF5KFsyKiozMl0pICAgLy8gPT4gVWludDMyQXJyYXkoMSkgWyAwIF1cbi8vIG5ldyBVaW50MzJBcnJheShbMioqMzItMV0pIC8vID0+IFVpbnQzMkFycmF5KDEpIFsgNDI5NDk2NzI5NSBdXG5jb25zdCBNQVhfQ09VTlRFUiA9IDIgKiogMzIgLSAxO1xuY29uc3QgVTMyX0VNUFRZID0gVWludDMyQXJyYXkub2YoKTtcbmZ1bmN0aW9uIHJ1bkNpcGhlcihjb3JlLCBzaWdtYSwga2V5LCBub25jZSwgZGF0YSwgb3V0cHV0LCBjb3VudGVyLCByb3VuZHMpIHtcbiAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICBjb25zdCBibG9jayA9IG5ldyBVaW50OEFycmF5KEJMT0NLX0xFTik7XG4gICAgY29uc3QgYjMyID0gdTMyKGJsb2NrKTtcbiAgICAvLyBNYWtlIHN1cmUgdGhhdCBidWZmZXJzIGFsaWduZWQgdG8gNCBieXRlc1xuICAgIGNvbnN0IGlzQWxpZ25lZCA9IGlzQWxpZ25lZDMyKGRhdGEpICYmIGlzQWxpZ25lZDMyKG91dHB1dCk7XG4gICAgY29uc3QgZDMyID0gaXNBbGlnbmVkID8gdTMyKGRhdGEpIDogVTMyX0VNUFRZO1xuICAgIGNvbnN0IG8zMiA9IGlzQWxpZ25lZCA/IHUzMihvdXRwdXQpIDogVTMyX0VNUFRZO1xuICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjsgY291bnRlcisrKSB7XG4gICAgICAgIGNvcmUoc2lnbWEsIGtleSwgbm9uY2UsIGIzMiwgY291bnRlciwgcm91bmRzKTtcbiAgICAgICAgaWYgKGNvdW50ZXIgPj0gTUFYX0NPVU5URVIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FyeDogY291bnRlciBvdmVyZmxvdycpO1xuICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oQkxPQ0tfTEVOLCBsZW4gLSBwb3MpO1xuICAgICAgICAvLyBhbGlnbmVkIHRvIDQgYnl0ZXNcbiAgICAgICAgaWYgKGlzQWxpZ25lZCAmJiB0YWtlID09PSBCTE9DS19MRU4pIHtcbiAgICAgICAgICAgIGNvbnN0IHBvczMyID0gcG9zIC8gNDtcbiAgICAgICAgICAgIGlmIChwb3MgJSA0ICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXJ4OiBpbnZhbGlkIGJsb2NrIHBvc2l0aW9uJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgcG9zajsgaiA8IEJMT0NLX0xFTjMyOyBqKyspIHtcbiAgICAgICAgICAgICAgICBwb3NqID0gcG9zMzIgKyBqO1xuICAgICAgICAgICAgICAgIG8zMltwb3NqXSA9IGQzMltwb3NqXSBeIGIzMltqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSBCTE9DS19MRU47XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBqID0gMCwgcG9zajsgaiA8IHRha2U7IGorKykge1xuICAgICAgICAgICAgcG9zaiA9IHBvcyArIGo7XG4gICAgICAgICAgICBvdXRwdXRbcG9zal0gPSBkYXRhW3Bvc2pdIF4gYmxvY2tbal07XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IHRha2U7XG4gICAgfVxufVxuLyoqIENyZWF0ZXMgQVJYLWxpa2UgKENoYUNoYSwgU2Fsc2EpIGNpcGhlciBzdHJlYW0gZnJvbSBjb3JlIGZ1bmN0aW9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNpcGhlcihjb3JlLCBvcHRzKSB7XG4gICAgY29uc3QgeyBhbGxvd1Nob3J0S2V5cywgZXh0ZW5kTm9uY2VGbiwgY291bnRlckxlbmd0aCwgY291bnRlclJpZ2h0LCByb3VuZHMgfSA9IGNoZWNrT3B0cyh7IGFsbG93U2hvcnRLZXlzOiBmYWxzZSwgY291bnRlckxlbmd0aDogOCwgY291bnRlclJpZ2h0OiBmYWxzZSwgcm91bmRzOiAyMCB9LCBvcHRzKTtcbiAgICBpZiAodHlwZW9mIGNvcmUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29yZSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICBhbnVtYmVyKGNvdW50ZXJMZW5ndGgpO1xuICAgIGFudW1iZXIocm91bmRzKTtcbiAgICBhYm9vbChjb3VudGVyUmlnaHQpO1xuICAgIGFib29sKGFsbG93U2hvcnRLZXlzKTtcbiAgICByZXR1cm4gKGtleSwgbm9uY2UsIGRhdGEsIG91dHB1dCwgY291bnRlciA9IDApID0+IHtcbiAgICAgICAgYWJ5dGVzKGtleSwgdW5kZWZpbmVkLCAna2V5Jyk7XG4gICAgICAgIGFieXRlcyhub25jZSwgdW5kZWZpbmVkLCAnbm9uY2UnKTtcbiAgICAgICAgYWJ5dGVzKGRhdGEsIHVuZGVmaW5lZCwgJ2RhdGEnKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIG91dHB1dCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgICAgIGFieXRlcyhvdXRwdXQsIHVuZGVmaW5lZCwgJ291dHB1dCcpO1xuICAgICAgICBhbnVtYmVyKGNvdW50ZXIpO1xuICAgICAgICBpZiAoY291bnRlciA8IDAgfHwgY291bnRlciA+PSBNQVhfQ09VTlRFUilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXJ4OiBjb3VudGVyIG92ZXJmbG93Jyk7XG4gICAgICAgIGlmIChvdXRwdXQubGVuZ3RoIDwgbGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcng6IG91dHB1dCAoJHtvdXRwdXQubGVuZ3RofSkgaXMgc2hvcnRlciB0aGFuIGRhdGEgKCR7bGVufSlgKTtcbiAgICAgICAgY29uc3QgdG9DbGVhbiA9IFtdO1xuICAgICAgICAvLyBLZXkgJiBzaWdtYVxuICAgICAgICAvLyBrZXk9MTYgLT4gc2lnbWExNiwgaz1rZXl8a2V5XG4gICAgICAgIC8vIGtleT0zMiAtPiBzaWdtYTMyLCBrPWtleVxuICAgICAgICBsZXQgbCA9IGtleS5sZW5ndGg7XG4gICAgICAgIGxldCBrO1xuICAgICAgICBsZXQgc2lnbWE7XG4gICAgICAgIGlmIChsID09PSAzMikge1xuICAgICAgICAgICAgdG9DbGVhbi5wdXNoKChrID0gY29weUJ5dGVzKGtleSkpKTtcbiAgICAgICAgICAgIHNpZ21hID0gc2lnbWEzMl8zMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsID09PSAxNiAmJiBhbGxvd1Nob3J0S2V5cykge1xuICAgICAgICAgICAgayA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgICAgICAgIGsuc2V0KGtleSk7XG4gICAgICAgICAgICBrLnNldChrZXksIDE2KTtcbiAgICAgICAgICAgIHNpZ21hID0gc2lnbWExNl8zMjtcbiAgICAgICAgICAgIHRvQ2xlYW4ucHVzaChrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFieXRlcyhrZXksIDMyLCAnYXJ4IGtleScpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGtleSBzaXplJyk7XG4gICAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoYFwiYXJ4IGtleVwiIGV4cGVjdGVkIFVpbnQ4QXJyYXkgb2YgbGVuZ3RoIDMyLCBnb3QgbGVuZ3RoPSR7bH1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb25jZVxuICAgICAgICAvLyBzYWxzYTIwOiAgICAgIDggICAoOC1ieXRlIGNvdW50ZXIpXG4gICAgICAgIC8vIGNoYWNoYTIwb3JpZzogOCAgICg4LWJ5dGUgY291bnRlcilcbiAgICAgICAgLy8gY2hhY2hhMjA6ICAgICAxMiAgKDQtYnl0ZSBjb3VudGVyKVxuICAgICAgICAvLyB4c2Fsc2EyMDogICAgIDI0ICAoMTYgLT4gaHNhbHNhLCAgOCAtPiBvbGQgbm9uY2UpXG4gICAgICAgIC8vIHhjaGFjaGEyMDogICAgMjQgICgxNiAtPiBoY2hhY2hhLCA4IC0+IG9sZCBub25jZSlcbiAgICAgICAgLy8gQWxpZ24gbm9uY2UgdG8gNCBieXRlc1xuICAgICAgICBpZiAoIWlzQWxpZ25lZDMyKG5vbmNlKSlcbiAgICAgICAgICAgIHRvQ2xlYW4ucHVzaCgobm9uY2UgPSBjb3B5Qnl0ZXMobm9uY2UpKSk7XG4gICAgICAgIGNvbnN0IGszMiA9IHUzMihrKTtcbiAgICAgICAgLy8gaHNhbHNhICYgaGNoYWNoYTogaGFuZGxlIGV4dGVuZGVkIG5vbmNlXG4gICAgICAgIGlmIChleHRlbmROb25jZUZuKSB7XG4gICAgICAgICAgICBpZiAobm9uY2UubGVuZ3RoICE9PSAyNClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFyeDogZXh0ZW5kZWQgbm9uY2UgbXVzdCBiZSAyNCBieXRlc2ApO1xuICAgICAgICAgICAgZXh0ZW5kTm9uY2VGbihzaWdtYSwgazMyLCB1MzIobm9uY2Uuc3ViYXJyYXkoMCwgMTYpKSwgazMyKTtcbiAgICAgICAgICAgIG5vbmNlID0gbm9uY2Uuc3ViYXJyYXkoMTYpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBub25jZSBjb3VudGVyXG4gICAgICAgIGNvbnN0IG5vbmNlTmNMZW4gPSAxNiAtIGNvdW50ZXJMZW5ndGg7XG4gICAgICAgIGlmIChub25jZU5jTGVuICE9PSBub25jZS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFyeDogbm9uY2UgbXVzdCBiZSAke25vbmNlTmNMZW59IG9yIDE2IGJ5dGVzYCk7XG4gICAgICAgIC8vIFBhZCBjb3VudGVyIHdoZW4gbm9uY2UgaXMgNjQgYml0XG4gICAgICAgIGlmIChub25jZU5jTGVuICE9PSAxMikge1xuICAgICAgICAgICAgY29uc3QgbmMgPSBuZXcgVWludDhBcnJheSgxMik7XG4gICAgICAgICAgICBuYy5zZXQobm9uY2UsIGNvdW50ZXJSaWdodCA/IDAgOiAxMiAtIG5vbmNlLmxlbmd0aCk7XG4gICAgICAgICAgICBub25jZSA9IG5jO1xuICAgICAgICAgICAgdG9DbGVhbi5wdXNoKG5vbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuMzIgPSB1MzIobm9uY2UpO1xuICAgICAgICBydW5DaXBoZXIoY29yZSwgc2lnbWEsIGszMiwgbjMyLCBkYXRhLCBvdXRwdXQsIGNvdW50ZXIsIHJvdW5kcyk7XG4gICAgICAgIGNsZWFuKC4uLnRvQ2xlYW4pO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59XG4vKiogSW50ZXJuYWwgY2xhc3Mgd2hpY2ggd3JhcHMgY2hhY2hhMjAgb3IgY2hhY2hhOCB0byBjcmVhdGUgQ1NQUk5HLiAqL1xuZXhwb3J0IGNsYXNzIF9Yb3JTdHJlYW1QUkcge1xuICAgIGJsb2NrTGVuO1xuICAgIGtleUxlbjtcbiAgICBub25jZUxlbjtcbiAgICBzdGF0ZTtcbiAgICBidWY7XG4gICAga2V5O1xuICAgIG5vbmNlO1xuICAgIHBvcztcbiAgICBjdHI7XG4gICAgY2lwaGVyO1xuICAgIGNvbnN0cnVjdG9yKGNpcGhlciwgYmxvY2tMZW4sIGtleUxlbiwgbm9uY2VMZW4sIHNlZWQpIHtcbiAgICAgICAgdGhpcy5jaXBoZXIgPSBjaXBoZXI7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5rZXlMZW4gPSBrZXlMZW47XG4gICAgICAgIHRoaXMubm9uY2VMZW4gPSBub25jZUxlbjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBVaW50OEFycmF5KHRoaXMua2V5TGVuICsgdGhpcy5ub25jZUxlbik7XG4gICAgICAgIHRoaXMucmVzZWVkKHNlZWQpO1xuICAgICAgICB0aGlzLmN0ciA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5idWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy5rZXkgPSB0aGlzLnN0YXRlLnN1YmFycmF5KDAsIHRoaXMua2V5TGVuKTtcbiAgICAgICAgdGhpcy5ub25jZSA9IHRoaXMuc3RhdGUuc3ViYXJyYXkodGhpcy5rZXlMZW4pO1xuICAgIH1cbiAgICByZXNlZWQoc2VlZCkge1xuICAgICAgICBhYnl0ZXMoc2VlZCk7XG4gICAgICAgIGlmICghc2VlZCB8fCBzZWVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZW50cm9weSByZXF1aXJlZCcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLnN0YXRlW2kgJSB0aGlzLnN0YXRlLmxlbmd0aF0gXj0gc2VlZFtpXTtcbiAgICAgICAgdGhpcy5jdHIgPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IHRoaXMuYmxvY2tMZW47XG4gICAgfVxuICAgIGFkZEVudHJvcHkoc2VlZCkge1xuICAgICAgICB0aGlzLnN0YXRlLnNldCh0aGlzLnJhbmRvbUJ5dGVzKHRoaXMuc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIHRoaXMucmVzZWVkKHNlZWQpO1xuICAgIH1cbiAgICByYW5kb21CeXRlcyhsZW4pIHtcbiAgICAgICAgYW51bWJlcihsZW4pO1xuICAgICAgICBpZiAobGVuID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgICAgICBsZXQgb3V0UG9zID0gMDtcbiAgICAgICAgLy8gTGVmdG92ZXJzXG4gICAgICAgIGlmICh0aGlzLnBvcyA8IHRoaXMuYmxvY2tMZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihsZW4sIHRoaXMuYmxvY2tMZW4gLSB0aGlzLnBvcyk7XG4gICAgICAgICAgICBvdXQuc2V0KHRoaXMuYnVmLnN1YmFycmF5KHRoaXMucG9zLCB0aGlzLnBvcyArIHRha2UpLCAwKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBvdXRQb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmIChvdXRQb3MgPT09IGxlbilcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0OyAvLyBmYXN0IHBhdGhcbiAgICAgICAgfVxuICAgICAgICAvLyBGdWxsIGJsb2NrcyBkaXJlY3RseSB0byBvdXRcbiAgICAgICAgY29uc3QgYmxvY2tzID0gTWF0aC5mbG9vcigobGVuIC0gb3V0UG9zKSAvIHRoaXMuYmxvY2tMZW4pO1xuICAgICAgICBpZiAoYmxvY2tzID4gMCkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2tCeXRlcyA9IGJsb2NrcyAqIHRoaXMuYmxvY2tMZW47XG4gICAgICAgICAgICBjb25zdCBiID0gb3V0LnN1YmFycmF5KG91dFBvcywgb3V0UG9zICsgYmxvY2tCeXRlcyk7XG4gICAgICAgICAgICB0aGlzLmNpcGhlcih0aGlzLmtleSwgdGhpcy5ub25jZSwgYiwgYiwgdGhpcy5jdHIpO1xuICAgICAgICAgICAgdGhpcy5jdHIgKz0gYmxvY2tzO1xuICAgICAgICAgICAgb3V0UG9zICs9IGJsb2NrQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2F2ZSBsZWZ0b3ZlcnNcbiAgICAgICAgY29uc3QgbGVmdCA9IGxlbiAtIG91dFBvcztcbiAgICAgICAgaWYgKGxlZnQgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmJ1Zi5maWxsKDApO1xuICAgICAgICAgICAgLy8gTk9URTogY2lwaGVyIHdpbGwgaGFuZGxlIG92ZXJmbG93XG4gICAgICAgICAgICB0aGlzLmNpcGhlcih0aGlzLmtleSwgdGhpcy5ub25jZSwgdGhpcy5idWYsIHRoaXMuYnVmLCB0aGlzLmN0cisrKTtcbiAgICAgICAgICAgIG91dC5zZXQodGhpcy5idWYuc3ViYXJyYXkoMCwgbGVmdCksIG91dFBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgX1hvclN0cmVhbVBSRyh0aGlzLmNpcGhlciwgdGhpcy5ibG9ja0xlbiwgdGhpcy5rZXlMZW4sIHRoaXMubm9uY2VMZW4sIHRoaXMucmFuZG9tQnl0ZXModGhpcy5zdGF0ZS5sZW5ndGgpKTtcbiAgICB9XG4gICAgY2xlYW4oKSB7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5jdHIgPSAwO1xuICAgICAgICB0aGlzLmJ1Zi5maWxsKDApO1xuICAgICAgICB0aGlzLnN0YXRlLmZpbGwoMCk7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IGNyZWF0ZVBSRyA9IChjaXBoZXIsIGJsb2NrTGVuLCBrZXlMZW4sIG5vbmNlTGVuKSA9PiB7XG4gICAgcmV0dXJuIChzZWVkID0gcmFuZG9tQnl0ZXMoMzIpKSA9PiBuZXcgX1hvclN0cmVhbVBSRyhjaXBoZXIsIGJsb2NrTGVuLCBrZXlMZW4sIG5vbmNlTGVuLCBzZWVkKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXJ4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/ciphers/_arx.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/ciphers/_poly1305.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/ciphers/_poly1305.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Poly1305: () => (/* binding */ Poly1305),\n/* harmony export */   poly1305: () => (/* binding */ poly1305),\n/* harmony export */   wrapConstructorWithKey: () => (/* binding */ wrapConstructorWithKey)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@noble/ciphers/utils.js\");\n/**\n * Poly1305 ([PDF](https://cr.yp.to/mac/poly1305-20050329.pdf),\n * [wiki](https://en.wikipedia.org/wiki/Poly1305))\n * is a fast and parallel secret-key message-authentication code suitable for\n * a wide variety of applications. It was standardized in\n * [RFC 8439](https://www.rfc-editor.org/rfc/rfc8439) and is now used in TLS 1.3.\n *\n * Polynomial MACs are not perfect for every situation:\n * they lack Random Key Robustness: the MAC can be forged, and can't be used in PAKE schemes.\n * See [invisible salamanders attack](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/).\n * To combat invisible salamanders, `hash(key)` can be included in ciphertext,\n * however, this would violate ciphertext indistinguishability:\n * an attacker would know which key was used - so `HKDF(key, i)`\n * could be used instead.\n *\n * Check out [original website](https://cr.yp.to/mac.html).\n * Based on Public Domain [poly1305-donna](https://github.com/floodyberry/poly1305-donna).\n * @module\n */\n// prettier-ignore\n\nfunction u8to16(a, i) {\n    return (a[i++] & 0xff) | ((a[i++] & 0xff) << 8);\n}\nfunction bytesToNumberLE(bytes) {\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToNumber)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(Uint8Array.from(bytes).reverse()));\n}\n/** Small version of `poly1305` without loop unrolling. Unused, provided for auditability. */\nfunction poly1305_small(msg, key) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(key, 32, 'key');\n    const POW_2_130_5 = BigInt(2) ** BigInt(130) - BigInt(5); // 2^130-5\n    const POW_2_128_1 = BigInt(2) ** BigInt(128) - BigInt(1); // 2^128-1\n    const CLAMP_R = BigInt('0x0ffffffc0ffffffc0ffffffc0fffffff');\n    const r = bytesToNumberLE(key.subarray(0, 16)) & CLAMP_R;\n    const s = bytesToNumberLE(key.subarray(16));\n    // Process by 16 byte chunks\n    let acc = BigInt(0);\n    for (let i = 0; i < msg.length; i += 16) {\n        const m = msg.subarray(i, i + 16);\n        const n = bytesToNumberLE(m) | (BigInt(1) << BigInt(8 * m.length));\n        acc = ((acc + n) * r) % POW_2_130_5;\n    }\n    const res = (acc + s) & POW_2_128_1;\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(res, 16).reverse(); // LE\n}\n// Can be used to replace `computeTag` in chacha.ts. Unused, provided for auditability.\n// @ts-expect-error\nfunction poly1305_computeTag_small(authKey, lengths, ciphertext, AAD) {\n    const res = [];\n    const updatePadded2 = (msg) => {\n        res.push(msg);\n        const leftover = msg.length % 16;\n        if (leftover)\n            res.push(new Uint8Array(16).slice(leftover));\n    };\n    if (AAD)\n        updatePadded2(AAD);\n    updatePadded2(ciphertext);\n    res.push(lengths);\n    return poly1305_small((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...res), authKey);\n}\n/** Poly1305 class. Prefer poly1305() function instead. */\nclass Poly1305 {\n    blockLen = 16;\n    outputLen = 16;\n    buffer = new Uint8Array(16);\n    r = new Uint16Array(10); // Allocating 1 array with .subarray() here is slower than 3\n    h = new Uint16Array(10);\n    pad = new Uint16Array(8);\n    pos = 0;\n    finished = false;\n    // Can be speed-up using BigUint64Array, at the cost of complexity\n    constructor(key) {\n        key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.copyBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(key, 32, 'key'));\n        const t0 = u8to16(key, 0);\n        const t1 = u8to16(key, 2);\n        const t2 = u8to16(key, 4);\n        const t3 = u8to16(key, 6);\n        const t4 = u8to16(key, 8);\n        const t5 = u8to16(key, 10);\n        const t6 = u8to16(key, 12);\n        const t7 = u8to16(key, 14);\n        // https://github.com/floodyberry/poly1305-donna/blob/e6ad6e091d30d7f4ec2d4f978be1fcfcbce72781/poly1305-donna-16.h#L47\n        this.r[0] = t0 & 0x1fff;\n        this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;\n        this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;\n        this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;\n        this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;\n        this.r[5] = (t4 >>> 1) & 0x1ffe;\n        this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;\n        this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;\n        this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;\n        this.r[9] = (t7 >>> 5) & 0x007f;\n        for (let i = 0; i < 8; i++)\n            this.pad[i] = u8to16(key, 16 + 2 * i);\n    }\n    process(data, offset, isLast = false) {\n        const hibit = isLast ? 0 : 1 << 11;\n        const { h, r } = this;\n        const r0 = r[0];\n        const r1 = r[1];\n        const r2 = r[2];\n        const r3 = r[3];\n        const r4 = r[4];\n        const r5 = r[5];\n        const r6 = r[6];\n        const r7 = r[7];\n        const r8 = r[8];\n        const r9 = r[9];\n        const t0 = u8to16(data, offset + 0);\n        const t1 = u8to16(data, offset + 2);\n        const t2 = u8to16(data, offset + 4);\n        const t3 = u8to16(data, offset + 6);\n        const t4 = u8to16(data, offset + 8);\n        const t5 = u8to16(data, offset + 10);\n        const t6 = u8to16(data, offset + 12);\n        const t7 = u8to16(data, offset + 14);\n        let h0 = h[0] + (t0 & 0x1fff);\n        let h1 = h[1] + (((t0 >>> 13) | (t1 << 3)) & 0x1fff);\n        let h2 = h[2] + (((t1 >>> 10) | (t2 << 6)) & 0x1fff);\n        let h3 = h[3] + (((t2 >>> 7) | (t3 << 9)) & 0x1fff);\n        let h4 = h[4] + (((t3 >>> 4) | (t4 << 12)) & 0x1fff);\n        let h5 = h[5] + ((t4 >>> 1) & 0x1fff);\n        let h6 = h[6] + (((t4 >>> 14) | (t5 << 2)) & 0x1fff);\n        let h7 = h[7] + (((t5 >>> 11) | (t6 << 5)) & 0x1fff);\n        let h8 = h[8] + (((t6 >>> 8) | (t7 << 8)) & 0x1fff);\n        let h9 = h[9] + ((t7 >>> 5) | hibit);\n        let c = 0;\n        let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);\n        c = d0 >>> 13;\n        d0 &= 0x1fff;\n        d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);\n        c += d0 >>> 13;\n        d0 &= 0x1fff;\n        let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);\n        c = d1 >>> 13;\n        d1 &= 0x1fff;\n        d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);\n        c += d1 >>> 13;\n        d1 &= 0x1fff;\n        let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);\n        c = d2 >>> 13;\n        d2 &= 0x1fff;\n        d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);\n        c += d2 >>> 13;\n        d2 &= 0x1fff;\n        let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);\n        c = d3 >>> 13;\n        d3 &= 0x1fff;\n        d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);\n        c += d3 >>> 13;\n        d3 &= 0x1fff;\n        let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;\n        c = d4 >>> 13;\n        d4 &= 0x1fff;\n        d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);\n        c += d4 >>> 13;\n        d4 &= 0x1fff;\n        let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;\n        c = d5 >>> 13;\n        d5 &= 0x1fff;\n        d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);\n        c += d5 >>> 13;\n        d5 &= 0x1fff;\n        let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;\n        c = d6 >>> 13;\n        d6 &= 0x1fff;\n        d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);\n        c += d6 >>> 13;\n        d6 &= 0x1fff;\n        let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;\n        c = d7 >>> 13;\n        d7 &= 0x1fff;\n        d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);\n        c += d7 >>> 13;\n        d7 &= 0x1fff;\n        let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;\n        c = d8 >>> 13;\n        d8 &= 0x1fff;\n        d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);\n        c += d8 >>> 13;\n        d8 &= 0x1fff;\n        let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;\n        c = d9 >>> 13;\n        d9 &= 0x1fff;\n        d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;\n        c += d9 >>> 13;\n        d9 &= 0x1fff;\n        c = ((c << 2) + c) | 0;\n        c = (c + d0) | 0;\n        d0 = c & 0x1fff;\n        c = c >>> 13;\n        d1 += c;\n        h[0] = d0;\n        h[1] = d1;\n        h[2] = d2;\n        h[3] = d3;\n        h[4] = d4;\n        h[5] = d5;\n        h[6] = d6;\n        h[7] = d7;\n        h[8] = d8;\n        h[9] = d9;\n    }\n    finalize() {\n        const { h, pad } = this;\n        const g = new Uint16Array(10);\n        let c = h[1] >>> 13;\n        h[1] &= 0x1fff;\n        for (let i = 2; i < 10; i++) {\n            h[i] += c;\n            c = h[i] >>> 13;\n            h[i] &= 0x1fff;\n        }\n        h[0] += c * 5;\n        c = h[0] >>> 13;\n        h[0] &= 0x1fff;\n        h[1] += c;\n        c = h[1] >>> 13;\n        h[1] &= 0x1fff;\n        h[2] += c;\n        g[0] = h[0] + 5;\n        c = g[0] >>> 13;\n        g[0] &= 0x1fff;\n        for (let i = 1; i < 10; i++) {\n            g[i] = h[i] + c;\n            c = g[i] >>> 13;\n            g[i] &= 0x1fff;\n        }\n        g[9] -= 1 << 13;\n        let mask = (c ^ 1) - 1;\n        for (let i = 0; i < 10; i++)\n            g[i] &= mask;\n        mask = ~mask;\n        for (let i = 0; i < 10; i++)\n            h[i] = (h[i] & mask) | g[i];\n        h[0] = (h[0] | (h[1] << 13)) & 0xffff;\n        h[1] = ((h[1] >>> 3) | (h[2] << 10)) & 0xffff;\n        h[2] = ((h[2] >>> 6) | (h[3] << 7)) & 0xffff;\n        h[3] = ((h[3] >>> 9) | (h[4] << 4)) & 0xffff;\n        h[4] = ((h[4] >>> 12) | (h[5] << 1) | (h[6] << 14)) & 0xffff;\n        h[5] = ((h[6] >>> 2) | (h[7] << 11)) & 0xffff;\n        h[6] = ((h[7] >>> 5) | (h[8] << 8)) & 0xffff;\n        h[7] = ((h[8] >>> 8) | (h[9] << 5)) & 0xffff;\n        let f = h[0] + pad[0];\n        h[0] = f & 0xffff;\n        for (let i = 1; i < 8; i++) {\n            f = (((h[i] + pad[i]) | 0) + (f >>> 16)) | 0;\n            h[i] = f & 0xffff;\n        }\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(g);\n    }\n    update(data) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(data);\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.copyBytes)(data);\n        const { buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input\n            if (take === blockLen) {\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(data, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(buffer, 0, false);\n                this.pos = 0;\n            }\n        }\n        return this;\n    }\n    destroy() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(this.h, this.r, this.buffer, this.pad);\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aoutput)(out, this);\n        this.finished = true;\n        const { buffer, h } = this;\n        let { pos } = this;\n        if (pos) {\n            buffer[pos++] = 1;\n            for (; pos < 16; pos++)\n                buffer[pos] = 0;\n            this.process(buffer, 0, true);\n        }\n        this.finalize();\n        let opos = 0;\n        for (let i = 0; i < 8; i++) {\n            out[opos++] = h[i] >>> 0;\n            out[opos++] = h[i] >>> 8;\n        }\n        return out;\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n}\nfunction wrapConstructorWithKey(hashCons) {\n    const hashC = (msg, key) => hashCons(key).update(msg).digest();\n    const tmp = hashCons(new Uint8Array(32)); // tmp array, used just once below\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (key) => hashCons(key);\n    return hashC;\n}\n/** Poly1305 MAC from RFC 8439. */\nconst poly1305 = /** @__PURE__ */ (() => wrapConstructorWithKey((key) => new Poly1305(key)))();\n//# sourceMappingURL=_poly1305.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2NpcGhlcnMvX3BvbHkxMzA1LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQytIO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzREFBVyxDQUFDLHFEQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLElBQUksaURBQU07QUFDVixJQUFJLGlEQUFNO0FBQ1YsOERBQThEO0FBQzlELDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwREFBZSxxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNEQUFXO0FBQ3JDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9EQUFTLENBQUMsaURBQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBSztBQUNiO0FBQ0E7QUFDQSxRQUFRLGtEQUFPO0FBQ2YsUUFBUSxpREFBTTtBQUNkLGVBQWUsb0RBQVM7QUFDeEIsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQUs7QUFDYjtBQUNBO0FBQ0EsUUFBUSxrREFBTztBQUNmLFFBQVEsa0RBQU87QUFDZjtBQUNBLGdCQUFnQixZQUFZO0FBQzVCLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXV0b3BsYW5jYW0vLi9ub2RlX21vZHVsZXMvQG5vYmxlL2NpcGhlcnMvX3BvbHkxMzA1LmpzPzAzOTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQb2x5MTMwNSAoW1BERl0oaHR0cHM6Ly9jci55cC50by9tYWMvcG9seTEzMDUtMjAwNTAzMjkucGRmKSxcbiAqIFt3aWtpXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qb2x5MTMwNSkpXG4gKiBpcyBhIGZhc3QgYW5kIHBhcmFsbGVsIHNlY3JldC1rZXkgbWVzc2FnZS1hdXRoZW50aWNhdGlvbiBjb2RlIHN1aXRhYmxlIGZvclxuICogYSB3aWRlIHZhcmlldHkgb2YgYXBwbGljYXRpb25zLiBJdCB3YXMgc3RhbmRhcmRpemVkIGluXG4gKiBbUkZDIDg0MzldKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM4NDM5KSBhbmQgaXMgbm93IHVzZWQgaW4gVExTIDEuMy5cbiAqXG4gKiBQb2x5bm9taWFsIE1BQ3MgYXJlIG5vdCBwZXJmZWN0IGZvciBldmVyeSBzaXR1YXRpb246XG4gKiB0aGV5IGxhY2sgUmFuZG9tIEtleSBSb2J1c3RuZXNzOiB0aGUgTUFDIGNhbiBiZSBmb3JnZWQsIGFuZCBjYW4ndCBiZSB1c2VkIGluIFBBS0Ugc2NoZW1lcy5cbiAqIFNlZSBbaW52aXNpYmxlIHNhbGFtYW5kZXJzIGF0dGFja10oaHR0cHM6Ly9rZXltYXRlcmlhbC5uZXQvMjAyMC8wOS8wNy9pbnZpc2libGUtc2FsYW1hbmRlcnMtaW4tYWVzLWdjbS1zaXYvKS5cbiAqIFRvIGNvbWJhdCBpbnZpc2libGUgc2FsYW1hbmRlcnMsIGBoYXNoKGtleSlgIGNhbiBiZSBpbmNsdWRlZCBpbiBjaXBoZXJ0ZXh0LFxuICogaG93ZXZlciwgdGhpcyB3b3VsZCB2aW9sYXRlIGNpcGhlcnRleHQgaW5kaXN0aW5ndWlzaGFiaWxpdHk6XG4gKiBhbiBhdHRhY2tlciB3b3VsZCBrbm93IHdoaWNoIGtleSB3YXMgdXNlZCAtIHNvIGBIS0RGKGtleSwgaSlgXG4gKiBjb3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gKlxuICogQ2hlY2sgb3V0IFtvcmlnaW5hbCB3ZWJzaXRlXShodHRwczovL2NyLnlwLnRvL21hYy5odG1sKS5cbiAqIEJhc2VkIG9uIFB1YmxpYyBEb21haW4gW3BvbHkxMzA1LWRvbm5hXShodHRwczovL2dpdGh1Yi5jb20vZmxvb2R5YmVycnkvcG9seTEzMDUtZG9ubmEpLlxuICogQG1vZHVsZVxuICovXG4vLyBwcmV0dGllci1pZ25vcmVcbmltcG9ydCB7IGFieXRlcywgYWV4aXN0cywgYW91dHB1dCwgYnl0ZXNUb0hleCwgY2xlYW4sIGNvbmNhdEJ5dGVzLCBjb3B5Qnl0ZXMsIGhleFRvTnVtYmVyLCBudW1iZXJUb0J5dGVzQkUgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuZnVuY3Rpb24gdTh0bzE2KGEsIGkpIHtcbiAgICByZXR1cm4gKGFbaSsrXSAmIDB4ZmYpIHwgKChhW2krK10gJiAweGZmKSA8PCA4KTtcbn1cbmZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShieXRlcykucmV2ZXJzZSgpKSk7XG59XG4vKiogU21hbGwgdmVyc2lvbiBvZiBgcG9seTEzMDVgIHdpdGhvdXQgbG9vcCB1bnJvbGxpbmcuIFVudXNlZCwgcHJvdmlkZWQgZm9yIGF1ZGl0YWJpbGl0eS4gKi9cbmZ1bmN0aW9uIHBvbHkxMzA1X3NtYWxsKG1zZywga2V5KSB7XG4gICAgYWJ5dGVzKG1zZyk7XG4gICAgYWJ5dGVzKGtleSwgMzIsICdrZXknKTtcbiAgICBjb25zdCBQT1dfMl8xMzBfNSA9IEJpZ0ludCgyKSAqKiBCaWdJbnQoMTMwKSAtIEJpZ0ludCg1KTsgLy8gMl4xMzAtNVxuICAgIGNvbnN0IFBPV18yXzEyOF8xID0gQmlnSW50KDIpICoqIEJpZ0ludCgxMjgpIC0gQmlnSW50KDEpOyAvLyAyXjEyOC0xXG4gICAgY29uc3QgQ0xBTVBfUiA9IEJpZ0ludCgnMHgwZmZmZmZmYzBmZmZmZmZjMGZmZmZmZmMwZmZmZmZmZicpO1xuICAgIGNvbnN0IHIgPSBieXRlc1RvTnVtYmVyTEUoa2V5LnN1YmFycmF5KDAsIDE2KSkgJiBDTEFNUF9SO1xuICAgIGNvbnN0IHMgPSBieXRlc1RvTnVtYmVyTEUoa2V5LnN1YmFycmF5KDE2KSk7XG4gICAgLy8gUHJvY2VzcyBieSAxNiBieXRlIGNodW5rc1xuICAgIGxldCBhY2MgPSBCaWdJbnQoMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICAgIGNvbnN0IG0gPSBtc2cuc3ViYXJyYXkoaSwgaSArIDE2KTtcbiAgICAgICAgY29uc3QgbiA9IGJ5dGVzVG9OdW1iZXJMRShtKSB8IChCaWdJbnQoMSkgPDwgQmlnSW50KDggKiBtLmxlbmd0aCkpO1xuICAgICAgICBhY2MgPSAoKGFjYyArIG4pICogcikgJSBQT1dfMl8xMzBfNTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gKGFjYyArIHMpICYgUE9XXzJfMTI4XzE7XG4gICAgcmV0dXJuIG51bWJlclRvQnl0ZXNCRShyZXMsIDE2KS5yZXZlcnNlKCk7IC8vIExFXG59XG4vLyBDYW4gYmUgdXNlZCB0byByZXBsYWNlIGBjb21wdXRlVGFnYCBpbiBjaGFjaGEudHMuIFVudXNlZCwgcHJvdmlkZWQgZm9yIGF1ZGl0YWJpbGl0eS5cbi8vIEB0cy1leHBlY3QtZXJyb3JcbmZ1bmN0aW9uIHBvbHkxMzA1X2NvbXB1dGVUYWdfc21hbGwoYXV0aEtleSwgbGVuZ3RocywgY2lwaGVydGV4dCwgQUFEKSB7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgY29uc3QgdXBkYXRlUGFkZGVkMiA9IChtc2cpID0+IHtcbiAgICAgICAgcmVzLnB1c2gobXNnKTtcbiAgICAgICAgY29uc3QgbGVmdG92ZXIgPSBtc2cubGVuZ3RoICUgMTY7XG4gICAgICAgIGlmIChsZWZ0b3ZlcilcbiAgICAgICAgICAgIHJlcy5wdXNoKG5ldyBVaW50OEFycmF5KDE2KS5zbGljZShsZWZ0b3ZlcikpO1xuICAgIH07XG4gICAgaWYgKEFBRClcbiAgICAgICAgdXBkYXRlUGFkZGVkMihBQUQpO1xuICAgIHVwZGF0ZVBhZGRlZDIoY2lwaGVydGV4dCk7XG4gICAgcmVzLnB1c2gobGVuZ3Rocyk7XG4gICAgcmV0dXJuIHBvbHkxMzA1X3NtYWxsKGNvbmNhdEJ5dGVzKC4uLnJlcyksIGF1dGhLZXkpO1xufVxuLyoqIFBvbHkxMzA1IGNsYXNzLiBQcmVmZXIgcG9seTEzMDUoKSBmdW5jdGlvbiBpbnN0ZWFkLiAqL1xuZXhwb3J0IGNsYXNzIFBvbHkxMzA1IHtcbiAgICBibG9ja0xlbiA9IDE2O1xuICAgIG91dHB1dExlbiA9IDE2O1xuICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICByID0gbmV3IFVpbnQxNkFycmF5KDEwKTsgLy8gQWxsb2NhdGluZyAxIGFycmF5IHdpdGggLnN1YmFycmF5KCkgaGVyZSBpcyBzbG93ZXIgdGhhbiAzXG4gICAgaCA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gICAgcGFkID0gbmV3IFVpbnQxNkFycmF5KDgpO1xuICAgIHBvcyA9IDA7XG4gICAgZmluaXNoZWQgPSBmYWxzZTtcbiAgICAvLyBDYW4gYmUgc3BlZWQtdXAgdXNpbmcgQmlnVWludDY0QXJyYXksIGF0IHRoZSBjb3N0IG9mIGNvbXBsZXhpdHlcbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAgICAga2V5ID0gY29weUJ5dGVzKGFieXRlcyhrZXksIDMyLCAna2V5JykpO1xuICAgICAgICBjb25zdCB0MCA9IHU4dG8xNihrZXksIDApO1xuICAgICAgICBjb25zdCB0MSA9IHU4dG8xNihrZXksIDIpO1xuICAgICAgICBjb25zdCB0MiA9IHU4dG8xNihrZXksIDQpO1xuICAgICAgICBjb25zdCB0MyA9IHU4dG8xNihrZXksIDYpO1xuICAgICAgICBjb25zdCB0NCA9IHU4dG8xNihrZXksIDgpO1xuICAgICAgICBjb25zdCB0NSA9IHU4dG8xNihrZXksIDEwKTtcbiAgICAgICAgY29uc3QgdDYgPSB1OHRvMTYoa2V5LCAxMik7XG4gICAgICAgIGNvbnN0IHQ3ID0gdTh0bzE2KGtleSwgMTQpO1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvb2R5YmVycnkvcG9seTEzMDUtZG9ubmEvYmxvYi9lNmFkNmUwOTFkMzBkN2Y0ZWMyZDRmOTc4YmUxZmNmY2JjZTcyNzgxL3BvbHkxMzA1LWRvbm5hLTE2LmgjTDQ3XG4gICAgICAgIHRoaXMuclswXSA9IHQwICYgMHgxZmZmO1xuICAgICAgICB0aGlzLnJbMV0gPSAoKHQwID4+PiAxMykgfCAodDEgPDwgMykpICYgMHgxZmZmO1xuICAgICAgICB0aGlzLnJbMl0gPSAoKHQxID4+PiAxMCkgfCAodDIgPDwgNikpICYgMHgxZjAzO1xuICAgICAgICB0aGlzLnJbM10gPSAoKHQyID4+PiA3KSB8ICh0MyA8PCA5KSkgJiAweDFmZmY7XG4gICAgICAgIHRoaXMucls0XSA9ICgodDMgPj4+IDQpIHwgKHQ0IDw8IDEyKSkgJiAweDAwZmY7XG4gICAgICAgIHRoaXMucls1XSA9ICh0NCA+Pj4gMSkgJiAweDFmZmU7XG4gICAgICAgIHRoaXMucls2XSA9ICgodDQgPj4+IDE0KSB8ICh0NSA8PCAyKSkgJiAweDFmZmY7XG4gICAgICAgIHRoaXMucls3XSA9ICgodDUgPj4+IDExKSB8ICh0NiA8PCA1KSkgJiAweDFmODE7XG4gICAgICAgIHRoaXMucls4XSA9ICgodDYgPj4+IDgpIHwgKHQ3IDw8IDgpKSAmIDB4MWZmZjtcbiAgICAgICAgdGhpcy5yWzldID0gKHQ3ID4+PiA1KSAmIDB4MDA3ZjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspXG4gICAgICAgICAgICB0aGlzLnBhZFtpXSA9IHU4dG8xNihrZXksIDE2ICsgMiAqIGkpO1xuICAgIH1cbiAgICBwcm9jZXNzKGRhdGEsIG9mZnNldCwgaXNMYXN0ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgaGliaXQgPSBpc0xhc3QgPyAwIDogMSA8PCAxMTtcbiAgICAgICAgY29uc3QgeyBoLCByIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCByMCA9IHJbMF07XG4gICAgICAgIGNvbnN0IHIxID0gclsxXTtcbiAgICAgICAgY29uc3QgcjIgPSByWzJdO1xuICAgICAgICBjb25zdCByMyA9IHJbM107XG4gICAgICAgIGNvbnN0IHI0ID0gcls0XTtcbiAgICAgICAgY29uc3QgcjUgPSByWzVdO1xuICAgICAgICBjb25zdCByNiA9IHJbNl07XG4gICAgICAgIGNvbnN0IHI3ID0gcls3XTtcbiAgICAgICAgY29uc3QgcjggPSByWzhdO1xuICAgICAgICBjb25zdCByOSA9IHJbOV07XG4gICAgICAgIGNvbnN0IHQwID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDApO1xuICAgICAgICBjb25zdCB0MSA9IHU4dG8xNihkYXRhLCBvZmZzZXQgKyAyKTtcbiAgICAgICAgY29uc3QgdDIgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgNCk7XG4gICAgICAgIGNvbnN0IHQzID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDYpO1xuICAgICAgICBjb25zdCB0NCA9IHU4dG8xNihkYXRhLCBvZmZzZXQgKyA4KTtcbiAgICAgICAgY29uc3QgdDUgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgMTApO1xuICAgICAgICBjb25zdCB0NiA9IHU4dG8xNihkYXRhLCBvZmZzZXQgKyAxMik7XG4gICAgICAgIGNvbnN0IHQ3ID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDE0KTtcbiAgICAgICAgbGV0IGgwID0gaFswXSArICh0MCAmIDB4MWZmZik7XG4gICAgICAgIGxldCBoMSA9IGhbMV0gKyAoKCh0MCA+Pj4gMTMpIHwgKHQxIDw8IDMpKSAmIDB4MWZmZik7XG4gICAgICAgIGxldCBoMiA9IGhbMl0gKyAoKCh0MSA+Pj4gMTApIHwgKHQyIDw8IDYpKSAmIDB4MWZmZik7XG4gICAgICAgIGxldCBoMyA9IGhbM10gKyAoKCh0MiA+Pj4gNykgfCAodDMgPDwgOSkpICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGg0ID0gaFs0XSArICgoKHQzID4+PiA0KSB8ICh0NCA8PCAxMikpICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGg1ID0gaFs1XSArICgodDQgPj4+IDEpICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGg2ID0gaFs2XSArICgoKHQ0ID4+PiAxNCkgfCAodDUgPDwgMikpICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGg3ID0gaFs3XSArICgoKHQ1ID4+PiAxMSkgfCAodDYgPDwgNSkpICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGg4ID0gaFs4XSArICgoKHQ2ID4+PiA4KSB8ICh0NyA8PCA4KSkgJiAweDFmZmYpO1xuICAgICAgICBsZXQgaDkgPSBoWzldICsgKCh0NyA+Pj4gNSkgfCBoaWJpdCk7XG4gICAgICAgIGxldCBjID0gMDtcbiAgICAgICAgbGV0IGQwID0gYyArIGgwICogcjAgKyBoMSAqICg1ICogcjkpICsgaDIgKiAoNSAqIHI4KSArIGgzICogKDUgKiByNykgKyBoNCAqICg1ICogcjYpO1xuICAgICAgICBjID0gZDAgPj4+IDEzO1xuICAgICAgICBkMCAmPSAweDFmZmY7XG4gICAgICAgIGQwICs9IGg1ICogKDUgKiByNSkgKyBoNiAqICg1ICogcjQpICsgaDcgKiAoNSAqIHIzKSArIGg4ICogKDUgKiByMikgKyBoOSAqICg1ICogcjEpO1xuICAgICAgICBjICs9IGQwID4+PiAxMztcbiAgICAgICAgZDAgJj0gMHgxZmZmO1xuICAgICAgICBsZXQgZDEgPSBjICsgaDAgKiByMSArIGgxICogcjAgKyBoMiAqICg1ICogcjkpICsgaDMgKiAoNSAqIHI4KSArIGg0ICogKDUgKiByNyk7XG4gICAgICAgIGMgPSBkMSA+Pj4gMTM7XG4gICAgICAgIGQxICY9IDB4MWZmZjtcbiAgICAgICAgZDEgKz0gaDUgKiAoNSAqIHI2KSArIGg2ICogKDUgKiByNSkgKyBoNyAqICg1ICogcjQpICsgaDggKiAoNSAqIHIzKSArIGg5ICogKDUgKiByMik7XG4gICAgICAgIGMgKz0gZDEgPj4+IDEzO1xuICAgICAgICBkMSAmPSAweDFmZmY7XG4gICAgICAgIGxldCBkMiA9IGMgKyBoMCAqIHIyICsgaDEgKiByMSArIGgyICogcjAgKyBoMyAqICg1ICogcjkpICsgaDQgKiAoNSAqIHI4KTtcbiAgICAgICAgYyA9IGQyID4+PiAxMztcbiAgICAgICAgZDIgJj0gMHgxZmZmO1xuICAgICAgICBkMiArPSBoNSAqICg1ICogcjcpICsgaDYgKiAoNSAqIHI2KSArIGg3ICogKDUgKiByNSkgKyBoOCAqICg1ICogcjQpICsgaDkgKiAoNSAqIHIzKTtcbiAgICAgICAgYyArPSBkMiA+Pj4gMTM7XG4gICAgICAgIGQyICY9IDB4MWZmZjtcbiAgICAgICAgbGV0IGQzID0gYyArIGgwICogcjMgKyBoMSAqIHIyICsgaDIgKiByMSArIGgzICogcjAgKyBoNCAqICg1ICogcjkpO1xuICAgICAgICBjID0gZDMgPj4+IDEzO1xuICAgICAgICBkMyAmPSAweDFmZmY7XG4gICAgICAgIGQzICs9IGg1ICogKDUgKiByOCkgKyBoNiAqICg1ICogcjcpICsgaDcgKiAoNSAqIHI2KSArIGg4ICogKDUgKiByNSkgKyBoOSAqICg1ICogcjQpO1xuICAgICAgICBjICs9IGQzID4+PiAxMztcbiAgICAgICAgZDMgJj0gMHgxZmZmO1xuICAgICAgICBsZXQgZDQgPSBjICsgaDAgKiByNCArIGgxICogcjMgKyBoMiAqIHIyICsgaDMgKiByMSArIGg0ICogcjA7XG4gICAgICAgIGMgPSBkNCA+Pj4gMTM7XG4gICAgICAgIGQ0ICY9IDB4MWZmZjtcbiAgICAgICAgZDQgKz0gaDUgKiAoNSAqIHI5KSArIGg2ICogKDUgKiByOCkgKyBoNyAqICg1ICogcjcpICsgaDggKiAoNSAqIHI2KSArIGg5ICogKDUgKiByNSk7XG4gICAgICAgIGMgKz0gZDQgPj4+IDEzO1xuICAgICAgICBkNCAmPSAweDFmZmY7XG4gICAgICAgIGxldCBkNSA9IGMgKyBoMCAqIHI1ICsgaDEgKiByNCArIGgyICogcjMgKyBoMyAqIHIyICsgaDQgKiByMTtcbiAgICAgICAgYyA9IGQ1ID4+PiAxMztcbiAgICAgICAgZDUgJj0gMHgxZmZmO1xuICAgICAgICBkNSArPSBoNSAqIHIwICsgaDYgKiAoNSAqIHI5KSArIGg3ICogKDUgKiByOCkgKyBoOCAqICg1ICogcjcpICsgaDkgKiAoNSAqIHI2KTtcbiAgICAgICAgYyArPSBkNSA+Pj4gMTM7XG4gICAgICAgIGQ1ICY9IDB4MWZmZjtcbiAgICAgICAgbGV0IGQ2ID0gYyArIGgwICogcjYgKyBoMSAqIHI1ICsgaDIgKiByNCArIGgzICogcjMgKyBoNCAqIHIyO1xuICAgICAgICBjID0gZDYgPj4+IDEzO1xuICAgICAgICBkNiAmPSAweDFmZmY7XG4gICAgICAgIGQ2ICs9IGg1ICogcjEgKyBoNiAqIHIwICsgaDcgKiAoNSAqIHI5KSArIGg4ICogKDUgKiByOCkgKyBoOSAqICg1ICogcjcpO1xuICAgICAgICBjICs9IGQ2ID4+PiAxMztcbiAgICAgICAgZDYgJj0gMHgxZmZmO1xuICAgICAgICBsZXQgZDcgPSBjICsgaDAgKiByNyArIGgxICogcjYgKyBoMiAqIHI1ICsgaDMgKiByNCArIGg0ICogcjM7XG4gICAgICAgIGMgPSBkNyA+Pj4gMTM7XG4gICAgICAgIGQ3ICY9IDB4MWZmZjtcbiAgICAgICAgZDcgKz0gaDUgKiByMiArIGg2ICogcjEgKyBoNyAqIHIwICsgaDggKiAoNSAqIHI5KSArIGg5ICogKDUgKiByOCk7XG4gICAgICAgIGMgKz0gZDcgPj4+IDEzO1xuICAgICAgICBkNyAmPSAweDFmZmY7XG4gICAgICAgIGxldCBkOCA9IGMgKyBoMCAqIHI4ICsgaDEgKiByNyArIGgyICogcjYgKyBoMyAqIHI1ICsgaDQgKiByNDtcbiAgICAgICAgYyA9IGQ4ID4+PiAxMztcbiAgICAgICAgZDggJj0gMHgxZmZmO1xuICAgICAgICBkOCArPSBoNSAqIHIzICsgaDYgKiByMiArIGg3ICogcjEgKyBoOCAqIHIwICsgaDkgKiAoNSAqIHI5KTtcbiAgICAgICAgYyArPSBkOCA+Pj4gMTM7XG4gICAgICAgIGQ4ICY9IDB4MWZmZjtcbiAgICAgICAgbGV0IGQ5ID0gYyArIGgwICogcjkgKyBoMSAqIHI4ICsgaDIgKiByNyArIGgzICogcjYgKyBoNCAqIHI1O1xuICAgICAgICBjID0gZDkgPj4+IDEzO1xuICAgICAgICBkOSAmPSAweDFmZmY7XG4gICAgICAgIGQ5ICs9IGg1ICogcjQgKyBoNiAqIHIzICsgaDcgKiByMiArIGg4ICogcjEgKyBoOSAqIHIwO1xuICAgICAgICBjICs9IGQ5ID4+PiAxMztcbiAgICAgICAgZDkgJj0gMHgxZmZmO1xuICAgICAgICBjID0gKChjIDw8IDIpICsgYykgfCAwO1xuICAgICAgICBjID0gKGMgKyBkMCkgfCAwO1xuICAgICAgICBkMCA9IGMgJiAweDFmZmY7XG4gICAgICAgIGMgPSBjID4+PiAxMztcbiAgICAgICAgZDEgKz0gYztcbiAgICAgICAgaFswXSA9IGQwO1xuICAgICAgICBoWzFdID0gZDE7XG4gICAgICAgIGhbMl0gPSBkMjtcbiAgICAgICAgaFszXSA9IGQzO1xuICAgICAgICBoWzRdID0gZDQ7XG4gICAgICAgIGhbNV0gPSBkNTtcbiAgICAgICAgaFs2XSA9IGQ2O1xuICAgICAgICBoWzddID0gZDc7XG4gICAgICAgIGhbOF0gPSBkODtcbiAgICAgICAgaFs5XSA9IGQ5O1xuICAgIH1cbiAgICBmaW5hbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgeyBoLCBwYWQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGcgPSBuZXcgVWludDE2QXJyYXkoMTApO1xuICAgICAgICBsZXQgYyA9IGhbMV0gPj4+IDEzO1xuICAgICAgICBoWzFdICY9IDB4MWZmZjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgICBoW2ldICs9IGM7XG4gICAgICAgICAgICBjID0gaFtpXSA+Pj4gMTM7XG4gICAgICAgICAgICBoW2ldICY9IDB4MWZmZjtcbiAgICAgICAgfVxuICAgICAgICBoWzBdICs9IGMgKiA1O1xuICAgICAgICBjID0gaFswXSA+Pj4gMTM7XG4gICAgICAgIGhbMF0gJj0gMHgxZmZmO1xuICAgICAgICBoWzFdICs9IGM7XG4gICAgICAgIGMgPSBoWzFdID4+PiAxMztcbiAgICAgICAgaFsxXSAmPSAweDFmZmY7XG4gICAgICAgIGhbMl0gKz0gYztcbiAgICAgICAgZ1swXSA9IGhbMF0gKyA1O1xuICAgICAgICBjID0gZ1swXSA+Pj4gMTM7XG4gICAgICAgIGdbMF0gJj0gMHgxZmZmO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgICAgIGdbaV0gPSBoW2ldICsgYztcbiAgICAgICAgICAgIGMgPSBnW2ldID4+PiAxMztcbiAgICAgICAgICAgIGdbaV0gJj0gMHgxZmZmO1xuICAgICAgICB9XG4gICAgICAgIGdbOV0gLT0gMSA8PCAxMztcbiAgICAgICAgbGV0IG1hc2sgPSAoYyBeIDEpIC0gMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKVxuICAgICAgICAgICAgZ1tpXSAmPSBtYXNrO1xuICAgICAgICBtYXNrID0gfm1hc2s7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKylcbiAgICAgICAgICAgIGhbaV0gPSAoaFtpXSAmIG1hc2spIHwgZ1tpXTtcbiAgICAgICAgaFswXSA9IChoWzBdIHwgKGhbMV0gPDwgMTMpKSAmIDB4ZmZmZjtcbiAgICAgICAgaFsxXSA9ICgoaFsxXSA+Pj4gMykgfCAoaFsyXSA8PCAxMCkpICYgMHhmZmZmO1xuICAgICAgICBoWzJdID0gKChoWzJdID4+PiA2KSB8IChoWzNdIDw8IDcpKSAmIDB4ZmZmZjtcbiAgICAgICAgaFszXSA9ICgoaFszXSA+Pj4gOSkgfCAoaFs0XSA8PCA0KSkgJiAweGZmZmY7XG4gICAgICAgIGhbNF0gPSAoKGhbNF0gPj4+IDEyKSB8IChoWzVdIDw8IDEpIHwgKGhbNl0gPDwgMTQpKSAmIDB4ZmZmZjtcbiAgICAgICAgaFs1XSA9ICgoaFs2XSA+Pj4gMikgfCAoaFs3XSA8PCAxMSkpICYgMHhmZmZmO1xuICAgICAgICBoWzZdID0gKChoWzddID4+PiA1KSB8IChoWzhdIDw8IDgpKSAmIDB4ZmZmZjtcbiAgICAgICAgaFs3XSA9ICgoaFs4XSA+Pj4gOCkgfCAoaFs5XSA8PCA1KSkgJiAweGZmZmY7XG4gICAgICAgIGxldCBmID0gaFswXSArIHBhZFswXTtcbiAgICAgICAgaFswXSA9IGYgJiAweGZmZmY7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICBmID0gKCgoaFtpXSArIHBhZFtpXSkgfCAwKSArIChmID4+PiAxNikpIHwgMDtcbiAgICAgICAgICAgIGhbaV0gPSBmICYgMHhmZmZmO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFuKGcpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICBhYnl0ZXMoZGF0YSk7XG4gICAgICAgIGRhdGEgPSBjb3B5Qnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dFxuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YSwgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGJ1ZmZlciwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYW4odGhpcy5oLCB0aGlzLnIsIHRoaXMuYnVmZmVyLCB0aGlzLnBhZCk7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIGFvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBoIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgIGJ1ZmZlcltwb3MrK10gPSAxO1xuICAgICAgICAgICAgZm9yICg7IHBvcyA8IDE2OyBwb3MrKylcbiAgICAgICAgICAgICAgICBidWZmZXJbcG9zXSA9IDA7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3MoYnVmZmVyLCAwLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgICAgIGxldCBvcG9zID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgIG91dFtvcG9zKytdID0gaFtpXSA+Pj4gMDtcbiAgICAgICAgICAgIG91dFtvcG9zKytdID0gaFtpXSA+Pj4gODtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhLZXkoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIGtleSkgPT4gaGFzaENvbnMoa2V5KS51cGRhdGUobXNnKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyhuZXcgVWludDhBcnJheSgzMikpOyAvLyB0bXAgYXJyYXksIHVzZWQganVzdCBvbmNlIGJlbG93XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoa2V5KSA9PiBoYXNoQ29ucyhrZXkpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbi8qKiBQb2x5MTMwNSBNQUMgZnJvbSBSRkMgODQzOS4gKi9cbmV4cG9ydCBjb25zdCBwb2x5MTMwNSA9IC8qKiBAX19QVVJFX18gKi8gKCgpID0+IHdyYXBDb25zdHJ1Y3RvcldpdGhLZXkoKGtleSkgPT4gbmV3IFBvbHkxMzA1KGtleSkpKSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3BvbHkxMzA1LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/ciphers/_poly1305.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/ciphers/chacha.js":
/*!***********************************************!*\
  !*** ./node_modules/@noble/ciphers/chacha.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _poly1305_aead: () => (/* binding */ _poly1305_aead),\n/* harmony export */   chacha12: () => (/* binding */ chacha12),\n/* harmony export */   chacha20: () => (/* binding */ chacha20),\n/* harmony export */   chacha20orig: () => (/* binding */ chacha20orig),\n/* harmony export */   chacha20poly1305: () => (/* binding */ chacha20poly1305),\n/* harmony export */   chacha8: () => (/* binding */ chacha8),\n/* harmony export */   hchacha: () => (/* binding */ hchacha),\n/* harmony export */   rngChacha20: () => (/* binding */ rngChacha20),\n/* harmony export */   rngChacha8: () => (/* binding */ rngChacha8),\n/* harmony export */   xchacha20: () => (/* binding */ xchacha20),\n/* harmony export */   xchacha20poly1305: () => (/* binding */ xchacha20poly1305)\n/* harmony export */ });\n/* harmony import */ var _arx_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arx.js */ \"(rsc)/./node_modules/@noble/ciphers/_arx.js\");\n/* harmony import */ var _poly1305_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_poly1305.js */ \"(rsc)/./node_modules/@noble/ciphers/_poly1305.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@noble/ciphers/utils.js\");\n/**\n * ChaCha stream cipher, released\n * in 2008. Developed after Salsa20, ChaCha aims to increase diffusion per round.\n * It was standardized in [RFC 8439](https://www.rfc-editor.org/rfc/rfc8439) and\n * is now used in TLS 1.3.\n *\n * [XChaCha20](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha)\n * extended-nonce variant is also provided. Similar to XSalsa, it's safe to use with\n * randomly-generated nonces.\n *\n * Check out [PDF](http://cr.yp.to/chacha/chacha-20080128.pdf) and\n * [wiki](https://en.wikipedia.org/wiki/Salsa20) and\n * [website](https://cr.yp.to/chacha.html).\n *\n * @module\n */\n\n\n\n/**\n * ChaCha core function. It is implemented twice:\n * 1. Simple loop (chachaCore_small, hchacha_small)\n * 2. Unrolled loop (chachaCore, hchacha) - 4x faster, but larger & harder to read\n * The specific implementation is selected in `createCipher` below.\n */\n/** quarter-round */\n// prettier-ignore\nfunction chachaQR(x, a, b, c, d) {\n    x[a] = (x[a] + x[b]) | 0;\n    x[d] = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x[d] ^ x[a], 16);\n    x[c] = (x[c] + x[d]) | 0;\n    x[b] = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x[b] ^ x[c], 12);\n    x[a] = (x[a] + x[b]) | 0;\n    x[d] = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x[d] ^ x[a], 8);\n    x[c] = (x[c] + x[d]) | 0;\n    x[b] = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x[b] ^ x[c], 7);\n}\n/** single round */\nfunction chachaRound(x, rounds = 20) {\n    for (let r = 0; r < rounds; r += 2) {\n        chachaQR(x, 0, 4, 8, 12);\n        chachaQR(x, 1, 5, 9, 13);\n        chachaQR(x, 2, 6, 10, 14);\n        chachaQR(x, 3, 7, 11, 15);\n        chachaQR(x, 0, 5, 10, 15);\n        chachaQR(x, 1, 6, 11, 12);\n        chachaQR(x, 2, 7, 8, 13);\n        chachaQR(x, 3, 4, 9, 14);\n    }\n}\nconst ctmp = /* @__PURE__ */ new Uint32Array(16);\n/** Small version of chacha without loop unrolling. Unused, provided for auditability. */\n// prettier-ignore\nfunction chacha(s, k, i, out, isHChacha = true, rounds = 20) {\n    // Create initial array using common pattern\n    const y = Uint32Array.from([\n        s[0], s[1], s[2], s[3], // \"expa\"   \"nd 3\"  \"2-by\"  \"te k\"\n        k[0], k[1], k[2], k[3], // Key      Key     Key     Key\n        k[4], k[5], k[6], k[7], // Key      Key     Key     Key\n        i[0], i[1], i[2], i[3], // Counter  Counter Nonce   Nonce\n    ]);\n    const x = ctmp;\n    x.set(y);\n    chachaRound(x, rounds);\n    // hchacha extracts 8 specific bytes, chacha adds orig to result\n    if (isHChacha) {\n        const xindexes = [0, 1, 2, 3, 12, 13, 14, 15];\n        for (let i = 0; i < 8; i++)\n            out[i] = x[xindexes[i]];\n    }\n    else {\n        for (let i = 0; i < 16; i++)\n            out[i] = (y[i] + x[i]) | 0;\n    }\n}\n/** Identical to `chachaCore`. Unused. */\n// @ts-ignore\nconst chachaCore_small = (s, k, n, out, cnt, rounds) => chacha(s, k, Uint32Array.from([n[0], n[1], cnt, 0]), out, false, rounds);\n/** Identical to `hchacha`. Unused. */\n// @ts-ignore\nconst hchacha_small = chacha;\n/** Identical to `chachaCore_small`. Unused. */\n// prettier-ignore\nfunction chachaCore(s, k, n, out, cnt, rounds = 20) {\n    let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], // \"expa\"   \"nd 3\"  \"2-by\"  \"te k\"\n    y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], // Key      Key     Key     Key\n    y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], // Key      Key     Key     Key\n    y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2]; // Counter  Counter\tNonce   Nonce\n    // Save state to temporary variables\n    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n    for (let r = 0; r < rounds; r += 2) {\n        x00 = (x00 + x04) | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 ^ x00, 16);\n        x08 = (x08 + x12) | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 ^ x08, 12);\n        x00 = (x00 + x04) | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 ^ x00, 8);\n        x08 = (x08 + x12) | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 ^ x08, 7);\n        x01 = (x01 + x05) | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 ^ x01, 16);\n        x09 = (x09 + x13) | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 ^ x09, 12);\n        x01 = (x01 + x05) | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 ^ x01, 8);\n        x09 = (x09 + x13) | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 ^ x09, 7);\n        x02 = (x02 + x06) | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 ^ x02, 16);\n        x10 = (x10 + x14) | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 ^ x10, 12);\n        x02 = (x02 + x06) | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 ^ x02, 8);\n        x10 = (x10 + x14) | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 ^ x10, 7);\n        x03 = (x03 + x07) | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 ^ x03, 16);\n        x11 = (x11 + x15) | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 ^ x11, 12);\n        x03 = (x03 + x07) | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 ^ x03, 8);\n        x11 = (x11 + x15) | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 ^ x11, 7);\n        x00 = (x00 + x05) | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 ^ x00, 16);\n        x10 = (x10 + x15) | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 ^ x10, 12);\n        x00 = (x00 + x05) | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 ^ x00, 8);\n        x10 = (x10 + x15) | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 ^ x10, 7);\n        x01 = (x01 + x06) | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 ^ x01, 16);\n        x11 = (x11 + x12) | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 ^ x11, 12);\n        x01 = (x01 + x06) | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 ^ x01, 8);\n        x11 = (x11 + x12) | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 ^ x11, 7);\n        x02 = (x02 + x07) | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 ^ x02, 16);\n        x08 = (x08 + x13) | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 ^ x08, 12);\n        x02 = (x02 + x07) | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 ^ x02, 8);\n        x08 = (x08 + x13) | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 ^ x08, 7);\n        x03 = (x03 + x04) | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 ^ x03, 16);\n        x09 = (x09 + x14) | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 ^ x09, 12);\n        x03 = (x03 + x04) | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 ^ x03, 8);\n        x09 = (x09 + x14) | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 ^ x09, 7);\n    }\n    // Write output\n    let oi = 0;\n    out[oi++] = (y00 + x00) | 0;\n    out[oi++] = (y01 + x01) | 0;\n    out[oi++] = (y02 + x02) | 0;\n    out[oi++] = (y03 + x03) | 0;\n    out[oi++] = (y04 + x04) | 0;\n    out[oi++] = (y05 + x05) | 0;\n    out[oi++] = (y06 + x06) | 0;\n    out[oi++] = (y07 + x07) | 0;\n    out[oi++] = (y08 + x08) | 0;\n    out[oi++] = (y09 + x09) | 0;\n    out[oi++] = (y10 + x10) | 0;\n    out[oi++] = (y11 + x11) | 0;\n    out[oi++] = (y12 + x12) | 0;\n    out[oi++] = (y13 + x13) | 0;\n    out[oi++] = (y14 + x14) | 0;\n    out[oi++] = (y15 + x15) | 0;\n}\n/**\n * hchacha hashes key and nonce into key' and nonce' for xchacha20.\n * Identical to `hchacha_small`.\n * Need to find a way to merge it with `chachaCore` without 25% performance hit.\n */\n// prettier-ignore\nfunction hchacha(s, k, i, out) {\n    let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];\n    for (let r = 0; r < 20; r += 2) {\n        x00 = (x00 + x04) | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 ^ x00, 16);\n        x08 = (x08 + x12) | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 ^ x08, 12);\n        x00 = (x00 + x04) | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 ^ x00, 8);\n        x08 = (x08 + x12) | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 ^ x08, 7);\n        x01 = (x01 + x05) | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 ^ x01, 16);\n        x09 = (x09 + x13) | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 ^ x09, 12);\n        x01 = (x01 + x05) | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 ^ x01, 8);\n        x09 = (x09 + x13) | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 ^ x09, 7);\n        x02 = (x02 + x06) | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 ^ x02, 16);\n        x10 = (x10 + x14) | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 ^ x10, 12);\n        x02 = (x02 + x06) | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 ^ x02, 8);\n        x10 = (x10 + x14) | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 ^ x10, 7);\n        x03 = (x03 + x07) | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 ^ x03, 16);\n        x11 = (x11 + x15) | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 ^ x11, 12);\n        x03 = (x03 + x07) | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 ^ x03, 8);\n        x11 = (x11 + x15) | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 ^ x11, 7);\n        x00 = (x00 + x05) | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 ^ x00, 16);\n        x10 = (x10 + x15) | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 ^ x10, 12);\n        x00 = (x00 + x05) | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 ^ x00, 8);\n        x10 = (x10 + x15) | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 ^ x10, 7);\n        x01 = (x01 + x06) | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 ^ x01, 16);\n        x11 = (x11 + x12) | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 ^ x11, 12);\n        x01 = (x01 + x06) | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 ^ x01, 8);\n        x11 = (x11 + x12) | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 ^ x11, 7);\n        x02 = (x02 + x07) | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 ^ x02, 16);\n        x08 = (x08 + x13) | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 ^ x08, 12);\n        x02 = (x02 + x07) | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 ^ x02, 8);\n        x08 = (x08 + x13) | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 ^ x08, 7);\n        x03 = (x03 + x04) | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 ^ x03, 16);\n        x09 = (x09 + x14) | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 ^ x09, 12);\n        x03 = (x03 + x04) | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 ^ x03, 8);\n        x09 = (x09 + x14) | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 ^ x09, 7);\n    }\n    let oi = 0;\n    out[oi++] = x00;\n    out[oi++] = x01;\n    out[oi++] = x02;\n    out[oi++] = x03;\n    out[oi++] = x12;\n    out[oi++] = x13;\n    out[oi++] = x14;\n    out[oi++] = x15;\n}\n/** Original, non-RFC chacha20 from DJB. 8-byte nonce, 8-byte counter. */\nconst chacha20orig = /* @__PURE__ */ (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 8,\n    allowShortKeys: true,\n});\n/**\n * ChaCha stream cipher. Conforms to RFC 8439 (IETF, TLS). 12-byte nonce, 4-byte counter.\n * With smaller nonce, it's not safe to make it random (CSPRNG), due to collision chance.\n */\nconst chacha20 = /* @__PURE__ */ (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    allowShortKeys: false,\n});\n/**\n * XChaCha eXtended-nonce ChaCha. With 24-byte nonce, it's safe to make it random (CSPRNG).\n * See [IRTF draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha).\n */\nconst xchacha20 = /* @__PURE__ */ (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 8,\n    extendNonceFn: hchacha,\n    allowShortKeys: false,\n});\n/** Reduced 8-round chacha, described in original paper. */\nconst chacha8 = /* @__PURE__ */ (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    rounds: 8,\n});\n/** Reduced 12-round chacha, described in original paper. */\nconst chacha12 = /* @__PURE__ */ (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    rounds: 12,\n});\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\n// Pad to digest size with zeros\nconst updatePadded = (h, msg) => {\n    h.update(msg);\n    const leftover = msg.length % 16;\n    if (leftover)\n        h.update(ZEROS16.subarray(leftover));\n};\nconst ZEROS32 = /* @__PURE__ */ new Uint8Array(32);\nfunction computeTag(fn, key, nonce, ciphertext, AAD) {\n    if (AAD !== undefined)\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(AAD, undefined, 'AAD');\n    const authKey = fn(key, nonce, ZEROS32);\n    const lengths = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u64Lengths)(ciphertext.length, AAD ? AAD.length : 0, true);\n    // Methods below can be replaced with\n    // return poly1305_computeTag_small(authKey, lengths, ciphertext, AAD)\n    const h = _poly1305_js__WEBPACK_IMPORTED_MODULE_2__.poly1305.create(authKey);\n    if (AAD)\n        updatePadded(h, AAD);\n    updatePadded(h, ciphertext);\n    h.update(lengths);\n    const res = h.digest();\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(authKey, lengths);\n    return res;\n}\n/**\n * AEAD algorithm from RFC 8439.\n * Salsa20 and chacha (RFC 8439) use poly1305 differently.\n * We could have composed them, but it's hard because of authKey:\n * In salsa20, authKey changes position in salsa stream.\n * In chacha, authKey can't be computed inside computeTag, it modifies the counter.\n */\nconst _poly1305_aead = (xorStream) => (key, nonce, AAD) => {\n    const tagLength = 16;\n    return {\n        encrypt(plaintext, output) {\n            const plength = plaintext.length;\n            output = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getOutput)(plength + tagLength, output, false);\n            output.set(plaintext);\n            const oPlain = output.subarray(0, -tagLength);\n            // Actual encryption\n            xorStream(key, nonce, oPlain, oPlain, 1);\n            const tag = computeTag(xorStream, key, nonce, oPlain, AAD);\n            output.set(tag, plength); // append tag\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(tag);\n            return output;\n        },\n        decrypt(ciphertext, output) {\n            output = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getOutput)(ciphertext.length - tagLength, output, false);\n            const data = ciphertext.subarray(0, -tagLength);\n            const passedTag = ciphertext.subarray(-tagLength);\n            const tag = computeTag(xorStream, key, nonce, data, AAD);\n            if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.equalBytes)(passedTag, tag))\n                throw new Error('invalid tag');\n            output.set(ciphertext.subarray(0, -tagLength));\n            // Actual decryption\n            xorStream(key, nonce, output, output, 1); // start stream with i=1\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(tag);\n            return output;\n        },\n    };\n};\n/**\n * ChaCha20-Poly1305 from RFC 8439.\n *\n * Unsafe to use random nonces under the same key, due to collision chance.\n * Prefer XChaCha instead.\n */\nconst chacha20poly1305 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapCipher)({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead(chacha20));\n/**\n * XChaCha20-Poly1305 extended-nonce chacha.\n *\n * Can be safely used with random nonces (CSPRNG).\n * See [IRTF draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha).\n */\nconst xchacha20poly1305 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapCipher)({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));\n/**\n * Chacha20 CSPRNG (cryptographically secure pseudorandom number generator).\n * It's best to limit usage to non-production, non-critical cases: for example, test-only.\n * Compatible with libtomcrypt. It does not have a specification, so unclear how secure it is.\n */\nconst rngChacha20 = /* @__PURE__ */ (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.createPRG)(chacha20orig, 64, 32, 8);\n/**\n * Chacha20/8 CSPRNG (cryptographically secure pseudorandom number generator).\n * It's best to limit usage to non-production, non-critical cases: for example, test-only.\n * Faster than `rngChacha20`.\n */\nconst rngChacha8 = /* @__PURE__ */ (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.createPRG)(chacha8, 64, 32, 12);\n//# sourceMappingURL=chacha.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2NpcGhlcnMvY2hhY2hhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMEQ7QUFDaEI7QUFDaUQ7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZDQUFJO0FBQ2Y7QUFDQSxXQUFXLDZDQUFJO0FBQ2Y7QUFDQSxXQUFXLDZDQUFJO0FBQ2Y7QUFDQSxXQUFXLDZDQUFJO0FBQ2Y7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQ0FBcUMscURBQVk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ08saUNBQWlDLHFEQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNPLGtDQUFrQyxxREFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPLGdDQUFnQyxxREFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDTyxpQ0FBaUMscURBQVk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlEQUFNO0FBQ2Q7QUFDQSxvQkFBb0IscURBQVU7QUFDOUI7QUFDQTtBQUNBLGNBQWMsa0RBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQUs7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9EQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsWUFBWSxnREFBSztBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBLHFCQUFxQixvREFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscURBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELFlBQVksZ0RBQUs7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlDQUF5QyxxREFBVSxHQUFHLCtDQUErQztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQ0FBMEMscURBQVUsR0FBRywrQ0FBK0M7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG9DQUFvQyxrREFBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUNBQW1DLGtEQUFTO0FBQ25EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXV0b3BsYW5jYW0vLi9ub2RlX21vZHVsZXMvQG5vYmxlL2NpcGhlcnMvY2hhY2hhLmpzPzkzNjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDaGFDaGEgc3RyZWFtIGNpcGhlciwgcmVsZWFzZWRcbiAqIGluIDIwMDguIERldmVsb3BlZCBhZnRlciBTYWxzYTIwLCBDaGFDaGEgYWltcyB0byBpbmNyZWFzZSBkaWZmdXNpb24gcGVyIHJvdW5kLlxuICogSXQgd2FzIHN0YW5kYXJkaXplZCBpbiBbUkZDIDg0MzldKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM4NDM5KSBhbmRcbiAqIGlzIG5vdyB1c2VkIGluIFRMUyAxLjMuXG4gKlxuICogW1hDaGFDaGEyMF0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmcteGNoYWNoYSlcbiAqIGV4dGVuZGVkLW5vbmNlIHZhcmlhbnQgaXMgYWxzbyBwcm92aWRlZC4gU2ltaWxhciB0byBYU2Fsc2EsIGl0J3Mgc2FmZSB0byB1c2Ugd2l0aFxuICogcmFuZG9tbHktZ2VuZXJhdGVkIG5vbmNlcy5cbiAqXG4gKiBDaGVjayBvdXQgW1BERl0oaHR0cDovL2NyLnlwLnRvL2NoYWNoYS9jaGFjaGEtMjAwODAxMjgucGRmKSBhbmRcbiAqIFt3aWtpXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TYWxzYTIwKSBhbmRcbiAqIFt3ZWJzaXRlXShodHRwczovL2NyLnlwLnRvL2NoYWNoYS5odG1sKS5cbiAqXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IGNyZWF0ZUNpcGhlciwgY3JlYXRlUFJHLCByb3RsIH0gZnJvbSBcIi4vX2FyeC5qc1wiO1xuaW1wb3J0IHsgcG9seTEzMDUgfSBmcm9tIFwiLi9fcG9seTEzMDUuanNcIjtcbmltcG9ydCB7IGFieXRlcywgY2xlYW4sIGVxdWFsQnl0ZXMsIGdldE91dHB1dCwgdTY0TGVuZ3Rocywgd3JhcENpcGhlciwgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLyoqXG4gKiBDaGFDaGEgY29yZSBmdW5jdGlvbi4gSXQgaXMgaW1wbGVtZW50ZWQgdHdpY2U6XG4gKiAxLiBTaW1wbGUgbG9vcCAoY2hhY2hhQ29yZV9zbWFsbCwgaGNoYWNoYV9zbWFsbClcbiAqIDIuIFVucm9sbGVkIGxvb3AgKGNoYWNoYUNvcmUsIGhjaGFjaGEpIC0gNHggZmFzdGVyLCBidXQgbGFyZ2VyICYgaGFyZGVyIHRvIHJlYWRcbiAqIFRoZSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBpcyBzZWxlY3RlZCBpbiBgY3JlYXRlQ2lwaGVyYCBiZWxvdy5cbiAqL1xuLyoqIHF1YXJ0ZXItcm91bmQgKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuZnVuY3Rpb24gY2hhY2hhUVIoeCwgYSwgYiwgYywgZCkge1xuICAgIHhbYV0gPSAoeFthXSArIHhbYl0pIHwgMDtcbiAgICB4W2RdID0gcm90bCh4W2RdIF4geFthXSwgMTYpO1xuICAgIHhbY10gPSAoeFtjXSArIHhbZF0pIHwgMDtcbiAgICB4W2JdID0gcm90bCh4W2JdIF4geFtjXSwgMTIpO1xuICAgIHhbYV0gPSAoeFthXSArIHhbYl0pIHwgMDtcbiAgICB4W2RdID0gcm90bCh4W2RdIF4geFthXSwgOCk7XG4gICAgeFtjXSA9ICh4W2NdICsgeFtkXSkgfCAwO1xuICAgIHhbYl0gPSByb3RsKHhbYl0gXiB4W2NdLCA3KTtcbn1cbi8qKiBzaW5nbGUgcm91bmQgKi9cbmZ1bmN0aW9uIGNoYWNoYVJvdW5kKHgsIHJvdW5kcyA9IDIwKSB7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCByb3VuZHM7IHIgKz0gMikge1xuICAgICAgICBjaGFjaGFRUih4LCAwLCA0LCA4LCAxMik7XG4gICAgICAgIGNoYWNoYVFSKHgsIDEsIDUsIDksIDEzKTtcbiAgICAgICAgY2hhY2hhUVIoeCwgMiwgNiwgMTAsIDE0KTtcbiAgICAgICAgY2hhY2hhUVIoeCwgMywgNywgMTEsIDE1KTtcbiAgICAgICAgY2hhY2hhUVIoeCwgMCwgNSwgMTAsIDE1KTtcbiAgICAgICAgY2hhY2hhUVIoeCwgMSwgNiwgMTEsIDEyKTtcbiAgICAgICAgY2hhY2hhUVIoeCwgMiwgNywgOCwgMTMpO1xuICAgICAgICBjaGFjaGFRUih4LCAzLCA0LCA5LCAxNCk7XG4gICAgfVxufVxuY29uc3QgY3RtcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoMTYpO1xuLyoqIFNtYWxsIHZlcnNpb24gb2YgY2hhY2hhIHdpdGhvdXQgbG9vcCB1bnJvbGxpbmcuIFVudXNlZCwgcHJvdmlkZWQgZm9yIGF1ZGl0YWJpbGl0eS4gKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuZnVuY3Rpb24gY2hhY2hhKHMsIGssIGksIG91dCwgaXNIQ2hhY2hhID0gdHJ1ZSwgcm91bmRzID0gMjApIHtcbiAgICAvLyBDcmVhdGUgaW5pdGlhbCBhcnJheSB1c2luZyBjb21tb24gcGF0dGVyblxuICAgIGNvbnN0IHkgPSBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAgICAgc1swXSwgc1sxXSwgc1syXSwgc1szXSwgLy8gXCJleHBhXCIgICBcIm5kIDNcIiAgXCIyLWJ5XCIgIFwidGUga1wiXG4gICAgICAgIGtbMF0sIGtbMV0sIGtbMl0sIGtbM10sIC8vIEtleSAgICAgIEtleSAgICAgS2V5ICAgICBLZXlcbiAgICAgICAga1s0XSwga1s1XSwga1s2XSwga1s3XSwgLy8gS2V5ICAgICAgS2V5ICAgICBLZXkgICAgIEtleVxuICAgICAgICBpWzBdLCBpWzFdLCBpWzJdLCBpWzNdLCAvLyBDb3VudGVyICBDb3VudGVyIE5vbmNlICAgTm9uY2VcbiAgICBdKTtcbiAgICBjb25zdCB4ID0gY3RtcDtcbiAgICB4LnNldCh5KTtcbiAgICBjaGFjaGFSb3VuZCh4LCByb3VuZHMpO1xuICAgIC8vIGhjaGFjaGEgZXh0cmFjdHMgOCBzcGVjaWZpYyBieXRlcywgY2hhY2hhIGFkZHMgb3JpZyB0byByZXN1bHRcbiAgICBpZiAoaXNIQ2hhY2hhKSB7XG4gICAgICAgIGNvbnN0IHhpbmRleGVzID0gWzAsIDEsIDIsIDMsIDEyLCAxMywgMTQsIDE1XTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspXG4gICAgICAgICAgICBvdXRbaV0gPSB4W3hpbmRleGVzW2ldXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKylcbiAgICAgICAgICAgIG91dFtpXSA9ICh5W2ldICsgeFtpXSkgfCAwO1xuICAgIH1cbn1cbi8qKiBJZGVudGljYWwgdG8gYGNoYWNoYUNvcmVgLiBVbnVzZWQuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBjaGFjaGFDb3JlX3NtYWxsID0gKHMsIGssIG4sIG91dCwgY250LCByb3VuZHMpID0+IGNoYWNoYShzLCBrLCBVaW50MzJBcnJheS5mcm9tKFtuWzBdLCBuWzFdLCBjbnQsIDBdKSwgb3V0LCBmYWxzZSwgcm91bmRzKTtcbi8qKiBJZGVudGljYWwgdG8gYGhjaGFjaGFgLiBVbnVzZWQuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBoY2hhY2hhX3NtYWxsID0gY2hhY2hhO1xuLyoqIElkZW50aWNhbCB0byBgY2hhY2hhQ29yZV9zbWFsbGAuIFVudXNlZC4gKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuZnVuY3Rpb24gY2hhY2hhQ29yZShzLCBrLCBuLCBvdXQsIGNudCwgcm91bmRzID0gMjApIHtcbiAgICBsZXQgeTAwID0gc1swXSwgeTAxID0gc1sxXSwgeTAyID0gc1syXSwgeTAzID0gc1szXSwgLy8gXCJleHBhXCIgICBcIm5kIDNcIiAgXCIyLWJ5XCIgIFwidGUga1wiXG4gICAgeTA0ID0ga1swXSwgeTA1ID0ga1sxXSwgeTA2ID0ga1syXSwgeTA3ID0ga1szXSwgLy8gS2V5ICAgICAgS2V5ICAgICBLZXkgICAgIEtleVxuICAgIHkwOCA9IGtbNF0sIHkwOSA9IGtbNV0sIHkxMCA9IGtbNl0sIHkxMSA9IGtbN10sIC8vIEtleSAgICAgIEtleSAgICAgS2V5ICAgICBLZXlcbiAgICB5MTIgPSBjbnQsIHkxMyA9IG5bMF0sIHkxNCA9IG5bMV0sIHkxNSA9IG5bMl07IC8vIENvdW50ZXIgIENvdW50ZXJcdE5vbmNlICAgTm9uY2VcbiAgICAvLyBTYXZlIHN0YXRlIHRvIHRlbXBvcmFyeSB2YXJpYWJsZXNcbiAgICBsZXQgeDAwID0geTAwLCB4MDEgPSB5MDEsIHgwMiA9IHkwMiwgeDAzID0geTAzLCB4MDQgPSB5MDQsIHgwNSA9IHkwNSwgeDA2ID0geTA2LCB4MDcgPSB5MDcsIHgwOCA9IHkwOCwgeDA5ID0geTA5LCB4MTAgPSB5MTAsIHgxMSA9IHkxMSwgeDEyID0geTEyLCB4MTMgPSB5MTMsIHgxNCA9IHkxNCwgeDE1ID0geTE1O1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgcm91bmRzOyByICs9IDIpIHtcbiAgICAgICAgeDAwID0gKHgwMCArIHgwNCkgfCAwO1xuICAgICAgICB4MTIgPSByb3RsKHgxMiBeIHgwMCwgMTYpO1xuICAgICAgICB4MDggPSAoeDA4ICsgeDEyKSB8IDA7XG4gICAgICAgIHgwNCA9IHJvdGwoeDA0IF4geDA4LCAxMik7XG4gICAgICAgIHgwMCA9ICh4MDAgKyB4MDQpIHwgMDtcbiAgICAgICAgeDEyID0gcm90bCh4MTIgXiB4MDAsIDgpO1xuICAgICAgICB4MDggPSAoeDA4ICsgeDEyKSB8IDA7XG4gICAgICAgIHgwNCA9IHJvdGwoeDA0IF4geDA4LCA3KTtcbiAgICAgICAgeDAxID0gKHgwMSArIHgwNSkgfCAwO1xuICAgICAgICB4MTMgPSByb3RsKHgxMyBeIHgwMSwgMTYpO1xuICAgICAgICB4MDkgPSAoeDA5ICsgeDEzKSB8IDA7XG4gICAgICAgIHgwNSA9IHJvdGwoeDA1IF4geDA5LCAxMik7XG4gICAgICAgIHgwMSA9ICh4MDEgKyB4MDUpIHwgMDtcbiAgICAgICAgeDEzID0gcm90bCh4MTMgXiB4MDEsIDgpO1xuICAgICAgICB4MDkgPSAoeDA5ICsgeDEzKSB8IDA7XG4gICAgICAgIHgwNSA9IHJvdGwoeDA1IF4geDA5LCA3KTtcbiAgICAgICAgeDAyID0gKHgwMiArIHgwNikgfCAwO1xuICAgICAgICB4MTQgPSByb3RsKHgxNCBeIHgwMiwgMTYpO1xuICAgICAgICB4MTAgPSAoeDEwICsgeDE0KSB8IDA7XG4gICAgICAgIHgwNiA9IHJvdGwoeDA2IF4geDEwLCAxMik7XG4gICAgICAgIHgwMiA9ICh4MDIgKyB4MDYpIHwgMDtcbiAgICAgICAgeDE0ID0gcm90bCh4MTQgXiB4MDIsIDgpO1xuICAgICAgICB4MTAgPSAoeDEwICsgeDE0KSB8IDA7XG4gICAgICAgIHgwNiA9IHJvdGwoeDA2IF4geDEwLCA3KTtcbiAgICAgICAgeDAzID0gKHgwMyArIHgwNykgfCAwO1xuICAgICAgICB4MTUgPSByb3RsKHgxNSBeIHgwMywgMTYpO1xuICAgICAgICB4MTEgPSAoeDExICsgeDE1KSB8IDA7XG4gICAgICAgIHgwNyA9IHJvdGwoeDA3IF4geDExLCAxMik7XG4gICAgICAgIHgwMyA9ICh4MDMgKyB4MDcpIHwgMDtcbiAgICAgICAgeDE1ID0gcm90bCh4MTUgXiB4MDMsIDgpO1xuICAgICAgICB4MTEgPSAoeDExICsgeDE1KSB8IDA7XG4gICAgICAgIHgwNyA9IHJvdGwoeDA3IF4geDExLCA3KTtcbiAgICAgICAgeDAwID0gKHgwMCArIHgwNSkgfCAwO1xuICAgICAgICB4MTUgPSByb3RsKHgxNSBeIHgwMCwgMTYpO1xuICAgICAgICB4MTAgPSAoeDEwICsgeDE1KSB8IDA7XG4gICAgICAgIHgwNSA9IHJvdGwoeDA1IF4geDEwLCAxMik7XG4gICAgICAgIHgwMCA9ICh4MDAgKyB4MDUpIHwgMDtcbiAgICAgICAgeDE1ID0gcm90bCh4MTUgXiB4MDAsIDgpO1xuICAgICAgICB4MTAgPSAoeDEwICsgeDE1KSB8IDA7XG4gICAgICAgIHgwNSA9IHJvdGwoeDA1IF4geDEwLCA3KTtcbiAgICAgICAgeDAxID0gKHgwMSArIHgwNikgfCAwO1xuICAgICAgICB4MTIgPSByb3RsKHgxMiBeIHgwMSwgMTYpO1xuICAgICAgICB4MTEgPSAoeDExICsgeDEyKSB8IDA7XG4gICAgICAgIHgwNiA9IHJvdGwoeDA2IF4geDExLCAxMik7XG4gICAgICAgIHgwMSA9ICh4MDEgKyB4MDYpIHwgMDtcbiAgICAgICAgeDEyID0gcm90bCh4MTIgXiB4MDEsIDgpO1xuICAgICAgICB4MTEgPSAoeDExICsgeDEyKSB8IDA7XG4gICAgICAgIHgwNiA9IHJvdGwoeDA2IF4geDExLCA3KTtcbiAgICAgICAgeDAyID0gKHgwMiArIHgwNykgfCAwO1xuICAgICAgICB4MTMgPSByb3RsKHgxMyBeIHgwMiwgMTYpO1xuICAgICAgICB4MDggPSAoeDA4ICsgeDEzKSB8IDA7XG4gICAgICAgIHgwNyA9IHJvdGwoeDA3IF4geDA4LCAxMik7XG4gICAgICAgIHgwMiA9ICh4MDIgKyB4MDcpIHwgMDtcbiAgICAgICAgeDEzID0gcm90bCh4MTMgXiB4MDIsIDgpO1xuICAgICAgICB4MDggPSAoeDA4ICsgeDEzKSB8IDA7XG4gICAgICAgIHgwNyA9IHJvdGwoeDA3IF4geDA4LCA3KTtcbiAgICAgICAgeDAzID0gKHgwMyArIHgwNCkgfCAwO1xuICAgICAgICB4MTQgPSByb3RsKHgxNCBeIHgwMywgMTYpO1xuICAgICAgICB4MDkgPSAoeDA5ICsgeDE0KSB8IDA7XG4gICAgICAgIHgwNCA9IHJvdGwoeDA0IF4geDA5LCAxMik7XG4gICAgICAgIHgwMyA9ICh4MDMgKyB4MDQpIHwgMDtcbiAgICAgICAgeDE0ID0gcm90bCh4MTQgXiB4MDMsIDgpO1xuICAgICAgICB4MDkgPSAoeDA5ICsgeDE0KSB8IDA7XG4gICAgICAgIHgwNCA9IHJvdGwoeDA0IF4geDA5LCA3KTtcbiAgICB9XG4gICAgLy8gV3JpdGUgb3V0cHV0XG4gICAgbGV0IG9pID0gMDtcbiAgICBvdXRbb2krK10gPSAoeTAwICsgeDAwKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwMSArIHgwMSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDIgKyB4MDIpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTAzICsgeDAzKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwNCArIHgwNCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDUgKyB4MDUpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA2ICsgeDA2KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwNyArIHgwNykgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDggKyB4MDgpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA5ICsgeDA5KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxMCArIHgxMCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTEgKyB4MTEpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTEyICsgeDEyKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxMyArIHgxMykgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTQgKyB4MTQpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTE1ICsgeDE1KSB8IDA7XG59XG4vKipcbiAqIGhjaGFjaGEgaGFzaGVzIGtleSBhbmQgbm9uY2UgaW50byBrZXknIGFuZCBub25jZScgZm9yIHhjaGFjaGEyMC5cbiAqIElkZW50aWNhbCB0byBgaGNoYWNoYV9zbWFsbGAuXG4gKiBOZWVkIHRvIGZpbmQgYSB3YXkgdG8gbWVyZ2UgaXQgd2l0aCBgY2hhY2hhQ29yZWAgd2l0aG91dCAyNSUgcGVyZm9ybWFuY2UgaGl0LlxuICovXG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCBmdW5jdGlvbiBoY2hhY2hhKHMsIGssIGksIG91dCkge1xuICAgIGxldCB4MDAgPSBzWzBdLCB4MDEgPSBzWzFdLCB4MDIgPSBzWzJdLCB4MDMgPSBzWzNdLCB4MDQgPSBrWzBdLCB4MDUgPSBrWzFdLCB4MDYgPSBrWzJdLCB4MDcgPSBrWzNdLCB4MDggPSBrWzRdLCB4MDkgPSBrWzVdLCB4MTAgPSBrWzZdLCB4MTEgPSBrWzddLCB4MTIgPSBpWzBdLCB4MTMgPSBpWzFdLCB4MTQgPSBpWzJdLCB4MTUgPSBpWzNdO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgMjA7IHIgKz0gMikge1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA0KSB8IDA7XG4gICAgICAgIHgxMiA9IHJvdGwoeDEyIF4geDAwLCAxNik7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTIpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDgsIDEyKTtcbiAgICAgICAgeDAwID0gKHgwMCArIHgwNCkgfCAwO1xuICAgICAgICB4MTIgPSByb3RsKHgxMiBeIHgwMCwgOCk7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTIpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDgsIDcpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA1KSB8IDA7XG4gICAgICAgIHgxMyA9IHJvdGwoeDEzIF4geDAxLCAxNik7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MDksIDEyKTtcbiAgICAgICAgeDAxID0gKHgwMSArIHgwNSkgfCAwO1xuICAgICAgICB4MTMgPSByb3RsKHgxMyBeIHgwMSwgOCk7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MDksIDcpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA2KSB8IDA7XG4gICAgICAgIHgxNCA9IHJvdGwoeDE0IF4geDAyLCAxNik7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTAsIDEyKTtcbiAgICAgICAgeDAyID0gKHgwMiArIHgwNikgfCAwO1xuICAgICAgICB4MTQgPSByb3RsKHgxNCBeIHgwMiwgOCk7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTAsIDcpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA3KSB8IDA7XG4gICAgICAgIHgxNSA9IHJvdGwoeDE1IF4geDAzLCAxNik7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MTEsIDEyKTtcbiAgICAgICAgeDAzID0gKHgwMyArIHgwNykgfCAwO1xuICAgICAgICB4MTUgPSByb3RsKHgxNSBeIHgwMywgOCk7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MTEsIDcpO1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA1KSB8IDA7XG4gICAgICAgIHgxNSA9IHJvdGwoeDE1IF4geDAwLCAxNik7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MTAsIDEyKTtcbiAgICAgICAgeDAwID0gKHgwMCArIHgwNSkgfCAwO1xuICAgICAgICB4MTUgPSByb3RsKHgxNSBeIHgwMCwgOCk7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MTAsIDcpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA2KSB8IDA7XG4gICAgICAgIHgxMiA9IHJvdGwoeDEyIF4geDAxLCAxNik7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTEsIDEyKTtcbiAgICAgICAgeDAxID0gKHgwMSArIHgwNikgfCAwO1xuICAgICAgICB4MTIgPSByb3RsKHgxMiBeIHgwMSwgOCk7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTEsIDcpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA3KSB8IDA7XG4gICAgICAgIHgxMyA9IHJvdGwoeDEzIF4geDAyLCAxNik7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTMpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MDgsIDEyKTtcbiAgICAgICAgeDAyID0gKHgwMiArIHgwNykgfCAwO1xuICAgICAgICB4MTMgPSByb3RsKHgxMyBeIHgwMiwgOCk7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTMpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MDgsIDcpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA0KSB8IDA7XG4gICAgICAgIHgxNCA9IHJvdGwoeDE0IF4geDAzLCAxNik7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDksIDEyKTtcbiAgICAgICAgeDAzID0gKHgwMyArIHgwNCkgfCAwO1xuICAgICAgICB4MTQgPSByb3RsKHgxNCBeIHgwMywgOCk7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDksIDcpO1xuICAgIH1cbiAgICBsZXQgb2kgPSAwO1xuICAgIG91dFtvaSsrXSA9IHgwMDtcbiAgICBvdXRbb2krK10gPSB4MDE7XG4gICAgb3V0W29pKytdID0geDAyO1xuICAgIG91dFtvaSsrXSA9IHgwMztcbiAgICBvdXRbb2krK10gPSB4MTI7XG4gICAgb3V0W29pKytdID0geDEzO1xuICAgIG91dFtvaSsrXSA9IHgxNDtcbiAgICBvdXRbb2krK10gPSB4MTU7XG59XG4vKiogT3JpZ2luYWwsIG5vbi1SRkMgY2hhY2hhMjAgZnJvbSBESkIuIDgtYnl0ZSBub25jZSwgOC1ieXRlIGNvdW50ZXIuICovXG5leHBvcnQgY29uc3QgY2hhY2hhMjBvcmlnID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUNpcGhlcihjaGFjaGFDb3JlLCB7XG4gICAgY291bnRlclJpZ2h0OiBmYWxzZSxcbiAgICBjb3VudGVyTGVuZ3RoOiA4LFxuICAgIGFsbG93U2hvcnRLZXlzOiB0cnVlLFxufSk7XG4vKipcbiAqIENoYUNoYSBzdHJlYW0gY2lwaGVyLiBDb25mb3JtcyB0byBSRkMgODQzOSAoSUVURiwgVExTKS4gMTItYnl0ZSBub25jZSwgNC1ieXRlIGNvdW50ZXIuXG4gKiBXaXRoIHNtYWxsZXIgbm9uY2UsIGl0J3Mgbm90IHNhZmUgdG8gbWFrZSBpdCByYW5kb20gKENTUFJORyksIGR1ZSB0byBjb2xsaXNpb24gY2hhbmNlLlxuICovXG5leHBvcnQgY29uc3QgY2hhY2hhMjAgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQ2lwaGVyKGNoYWNoYUNvcmUsIHtcbiAgICBjb3VudGVyUmlnaHQ6IGZhbHNlLFxuICAgIGNvdW50ZXJMZW5ndGg6IDQsXG4gICAgYWxsb3dTaG9ydEtleXM6IGZhbHNlLFxufSk7XG4vKipcbiAqIFhDaGFDaGEgZVh0ZW5kZWQtbm9uY2UgQ2hhQ2hhLiBXaXRoIDI0LWJ5dGUgbm9uY2UsIGl0J3Mgc2FmZSB0byBtYWtlIGl0IHJhbmRvbSAoQ1NQUk5HKS5cbiAqIFNlZSBbSVJURiBkcmFmdF0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmcteGNoYWNoYSkuXG4gKi9cbmV4cG9ydCBjb25zdCB4Y2hhY2hhMjAgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQ2lwaGVyKGNoYWNoYUNvcmUsIHtcbiAgICBjb3VudGVyUmlnaHQ6IGZhbHNlLFxuICAgIGNvdW50ZXJMZW5ndGg6IDgsXG4gICAgZXh0ZW5kTm9uY2VGbjogaGNoYWNoYSxcbiAgICBhbGxvd1Nob3J0S2V5czogZmFsc2UsXG59KTtcbi8qKiBSZWR1Y2VkIDgtcm91bmQgY2hhY2hhLCBkZXNjcmliZWQgaW4gb3JpZ2luYWwgcGFwZXIuICovXG5leHBvcnQgY29uc3QgY2hhY2hhOCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVDaXBoZXIoY2hhY2hhQ29yZSwge1xuICAgIGNvdW50ZXJSaWdodDogZmFsc2UsXG4gICAgY291bnRlckxlbmd0aDogNCxcbiAgICByb3VuZHM6IDgsXG59KTtcbi8qKiBSZWR1Y2VkIDEyLXJvdW5kIGNoYWNoYSwgZGVzY3JpYmVkIGluIG9yaWdpbmFsIHBhcGVyLiAqL1xuZXhwb3J0IGNvbnN0IGNoYWNoYTEyID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUNpcGhlcihjaGFjaGFDb3JlLCB7XG4gICAgY291bnRlclJpZ2h0OiBmYWxzZSxcbiAgICBjb3VudGVyTGVuZ3RoOiA0LFxuICAgIHJvdW5kczogMTIsXG59KTtcbmNvbnN0IFpFUk9TMTYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuLy8gUGFkIHRvIGRpZ2VzdCBzaXplIHdpdGggemVyb3NcbmNvbnN0IHVwZGF0ZVBhZGRlZCA9IChoLCBtc2cpID0+IHtcbiAgICBoLnVwZGF0ZShtc2cpO1xuICAgIGNvbnN0IGxlZnRvdmVyID0gbXNnLmxlbmd0aCAlIDE2O1xuICAgIGlmIChsZWZ0b3ZlcilcbiAgICAgICAgaC51cGRhdGUoWkVST1MxNi5zdWJhcnJheShsZWZ0b3ZlcikpO1xufTtcbmNvbnN0IFpFUk9TMzIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuZnVuY3Rpb24gY29tcHV0ZVRhZyhmbiwga2V5LCBub25jZSwgY2lwaGVydGV4dCwgQUFEKSB7XG4gICAgaWYgKEFBRCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBhYnl0ZXMoQUFELCB1bmRlZmluZWQsICdBQUQnKTtcbiAgICBjb25zdCBhdXRoS2V5ID0gZm4oa2V5LCBub25jZSwgWkVST1MzMik7XG4gICAgY29uc3QgbGVuZ3RocyA9IHU2NExlbmd0aHMoY2lwaGVydGV4dC5sZW5ndGgsIEFBRCA/IEFBRC5sZW5ndGggOiAwLCB0cnVlKTtcbiAgICAvLyBNZXRob2RzIGJlbG93IGNhbiBiZSByZXBsYWNlZCB3aXRoXG4gICAgLy8gcmV0dXJuIHBvbHkxMzA1X2NvbXB1dGVUYWdfc21hbGwoYXV0aEtleSwgbGVuZ3RocywgY2lwaGVydGV4dCwgQUFEKVxuICAgIGNvbnN0IGggPSBwb2x5MTMwNS5jcmVhdGUoYXV0aEtleSk7XG4gICAgaWYgKEFBRClcbiAgICAgICAgdXBkYXRlUGFkZGVkKGgsIEFBRCk7XG4gICAgdXBkYXRlUGFkZGVkKGgsIGNpcGhlcnRleHQpO1xuICAgIGgudXBkYXRlKGxlbmd0aHMpO1xuICAgIGNvbnN0IHJlcyA9IGguZGlnZXN0KCk7XG4gICAgY2xlYW4oYXV0aEtleSwgbGVuZ3Rocyk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQUVBRCBhbGdvcml0aG0gZnJvbSBSRkMgODQzOS5cbiAqIFNhbHNhMjAgYW5kIGNoYWNoYSAoUkZDIDg0MzkpIHVzZSBwb2x5MTMwNSBkaWZmZXJlbnRseS5cbiAqIFdlIGNvdWxkIGhhdmUgY29tcG9zZWQgdGhlbSwgYnV0IGl0J3MgaGFyZCBiZWNhdXNlIG9mIGF1dGhLZXk6XG4gKiBJbiBzYWxzYTIwLCBhdXRoS2V5IGNoYW5nZXMgcG9zaXRpb24gaW4gc2Fsc2Egc3RyZWFtLlxuICogSW4gY2hhY2hhLCBhdXRoS2V5IGNhbid0IGJlIGNvbXB1dGVkIGluc2lkZSBjb21wdXRlVGFnLCBpdCBtb2RpZmllcyB0aGUgY291bnRlci5cbiAqL1xuZXhwb3J0IGNvbnN0IF9wb2x5MTMwNV9hZWFkID0gKHhvclN0cmVhbSkgPT4gKGtleSwgbm9uY2UsIEFBRCkgPT4ge1xuICAgIGNvbnN0IHRhZ0xlbmd0aCA9IDE2O1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY3J5cHQocGxhaW50ZXh0LCBvdXRwdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBsZW5ndGggPSBwbGFpbnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgb3V0cHV0ID0gZ2V0T3V0cHV0KHBsZW5ndGggKyB0YWdMZW5ndGgsIG91dHB1dCwgZmFsc2UpO1xuICAgICAgICAgICAgb3V0cHV0LnNldChwbGFpbnRleHQpO1xuICAgICAgICAgICAgY29uc3Qgb1BsYWluID0gb3V0cHV0LnN1YmFycmF5KDAsIC10YWdMZW5ndGgpO1xuICAgICAgICAgICAgLy8gQWN0dWFsIGVuY3J5cHRpb25cbiAgICAgICAgICAgIHhvclN0cmVhbShrZXksIG5vbmNlLCBvUGxhaW4sIG9QbGFpbiwgMSk7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSBjb21wdXRlVGFnKHhvclN0cmVhbSwga2V5LCBub25jZSwgb1BsYWluLCBBQUQpO1xuICAgICAgICAgICAgb3V0cHV0LnNldCh0YWcsIHBsZW5ndGgpOyAvLyBhcHBlbmQgdGFnXG4gICAgICAgICAgICBjbGVhbih0YWcpO1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjcnlwdChjaXBoZXJ0ZXh0LCBvdXRwdXQpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGdldE91dHB1dChjaXBoZXJ0ZXh0Lmxlbmd0aCAtIHRhZ0xlbmd0aCwgb3V0cHV0LCBmYWxzZSk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gY2lwaGVydGV4dC5zdWJhcnJheSgwLCAtdGFnTGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhc3NlZFRhZyA9IGNpcGhlcnRleHQuc3ViYXJyYXkoLXRhZ0xlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSBjb21wdXRlVGFnKHhvclN0cmVhbSwga2V5LCBub25jZSwgZGF0YSwgQUFEKTtcbiAgICAgICAgICAgIGlmICghZXF1YWxCeXRlcyhwYXNzZWRUYWcsIHRhZykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHRhZycpO1xuICAgICAgICAgICAgb3V0cHV0LnNldChjaXBoZXJ0ZXh0LnN1YmFycmF5KDAsIC10YWdMZW5ndGgpKTtcbiAgICAgICAgICAgIC8vIEFjdHVhbCBkZWNyeXB0aW9uXG4gICAgICAgICAgICB4b3JTdHJlYW0oa2V5LCBub25jZSwgb3V0cHV0LCBvdXRwdXQsIDEpOyAvLyBzdGFydCBzdHJlYW0gd2l0aCBpPTFcbiAgICAgICAgICAgIGNsZWFuKHRhZyk7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuLyoqXG4gKiBDaGFDaGEyMC1Qb2x5MTMwNSBmcm9tIFJGQyA4NDM5LlxuICpcbiAqIFVuc2FmZSB0byB1c2UgcmFuZG9tIG5vbmNlcyB1bmRlciB0aGUgc2FtZSBrZXksIGR1ZSB0byBjb2xsaXNpb24gY2hhbmNlLlxuICogUHJlZmVyIFhDaGFDaGEgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNoYWNoYTIwcG9seTEzMDUgPSAvKiBAX19QVVJFX18gKi8gd3JhcENpcGhlcih7IGJsb2NrU2l6ZTogNjQsIG5vbmNlTGVuZ3RoOiAxMiwgdGFnTGVuZ3RoOiAxNiB9LCBfcG9seTEzMDVfYWVhZChjaGFjaGEyMCkpO1xuLyoqXG4gKiBYQ2hhQ2hhMjAtUG9seTEzMDUgZXh0ZW5kZWQtbm9uY2UgY2hhY2hhLlxuICpcbiAqIENhbiBiZSBzYWZlbHkgdXNlZCB3aXRoIHJhbmRvbSBub25jZXMgKENTUFJORykuXG4gKiBTZWUgW0lSVEYgZHJhZnRdKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLXhjaGFjaGEpLlxuICovXG5leHBvcnQgY29uc3QgeGNoYWNoYTIwcG9seTEzMDUgPSAvKiBAX19QVVJFX18gKi8gd3JhcENpcGhlcih7IGJsb2NrU2l6ZTogNjQsIG5vbmNlTGVuZ3RoOiAyNCwgdGFnTGVuZ3RoOiAxNiB9LCBfcG9seTEzMDVfYWVhZCh4Y2hhY2hhMjApKTtcbi8qKlxuICogQ2hhY2hhMjAgQ1NQUk5HIChjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcHNldWRvcmFuZG9tIG51bWJlciBnZW5lcmF0b3IpLlxuICogSXQncyBiZXN0IHRvIGxpbWl0IHVzYWdlIHRvIG5vbi1wcm9kdWN0aW9uLCBub24tY3JpdGljYWwgY2FzZXM6IGZvciBleGFtcGxlLCB0ZXN0LW9ubHkuXG4gKiBDb21wYXRpYmxlIHdpdGggbGlidG9tY3J5cHQuIEl0IGRvZXMgbm90IGhhdmUgYSBzcGVjaWZpY2F0aW9uLCBzbyB1bmNsZWFyIGhvdyBzZWN1cmUgaXQgaXMuXG4gKi9cbmV4cG9ydCBjb25zdCBybmdDaGFjaGEyMCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVQUkcoY2hhY2hhMjBvcmlnLCA2NCwgMzIsIDgpO1xuLyoqXG4gKiBDaGFjaGEyMC84IENTUFJORyAoY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHBzZXVkb3JhbmRvbSBudW1iZXIgZ2VuZXJhdG9yKS5cbiAqIEl0J3MgYmVzdCB0byBsaW1pdCB1c2FnZSB0byBub24tcHJvZHVjdGlvbiwgbm9uLWNyaXRpY2FsIGNhc2VzOiBmb3IgZXhhbXBsZSwgdGVzdC1vbmx5LlxuICogRmFzdGVyIHRoYW4gYHJuZ0NoYWNoYTIwYC5cbiAqL1xuZXhwb3J0IGNvbnN0IHJuZ0NoYWNoYTggPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlUFJHKGNoYWNoYTgsIDY0LCAzMiwgMTIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhY2hhLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/ciphers/chacha.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/ciphers/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/@noble/ciphers/utils.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abool: () => (/* binding */ abool),\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   aexists: () => (/* binding */ aexists),\n/* harmony export */   anumber: () => (/* binding */ anumber),\n/* harmony export */   aoutput: () => (/* binding */ aoutput),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToUtf8: () => (/* binding */ bytesToUtf8),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   clean: () => (/* binding */ clean),\n/* harmony export */   complexOverlapBytes: () => (/* binding */ complexOverlapBytes),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   copyBytes: () => (/* binding */ copyBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   getOutput: () => (/* binding */ getOutput),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   isAligned32: () => (/* binding */ isAligned32),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   managedNonce: () => (/* binding */ managedNonce),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   overlapBytes: () => (/* binding */ overlapBytes),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u64Lengths: () => (/* binding */ u64Lengths),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapCipher: () => (/* binding */ wrapCipher)\n/* harmony export */ });\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is boolean. */\nfunction abool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n/** Asserts something is positive integer. */\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(value, length, title = '') {\n    const bytes = isBytes(value);\n    const len = value?.length;\n    const needsLen = length !== undefined;\n    if (!bytes || (needsLen && len !== length)) {\n        const prefix = title && `\"${title}\" `;\n        const ofLen = needsLen ? ` of length ${length}` : '';\n        const got = bytes ? `length=${len}` : `type=${typeof value}`;\n        throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n    }\n    return value;\n}\n/** Asserts a hash instance has not been destroyed / finished */\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nfunction aoutput(out, instance) {\n    abytes(out, undefined, 'output');\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nfunction u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nfunction u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nfunction clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nfunction createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nconst isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// Used in micro\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return BigInt(hex === '' ? '0' : '0x' + hex); // Big Endian\n}\n// Used in ff1\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\n// Used in micro, ff1\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(new Uint8Array([97, 98, 99])) // 'abc'\n */\nfunction bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Checks if two U8A use same underlying buffer and overlaps.\n * This is invalid and can corrupt data.\n */\nfunction overlapBytes(a, b) {\n    return (a.buffer === b.buffer && // best we can do, may fail with an obscure Proxy\n        a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end\n        b.byteOffset < a.byteOffset + a.byteLength // b starts before a end\n    );\n}\n/**\n * If input and output overlap and input starts before output, we will overwrite end of input before\n * we start processing it, so this is not supported for most ciphers (except chacha/salse, which designed with this)\n */\nfunction complexOverlapBytes(input, output) {\n    // This is very cursed. It works somehow, but I'm completely unsure,\n    // reasoning about overlapping aligned windows is very hard.\n    if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)\n        throw new Error('complex overlap of input and output is not supported');\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nfunction checkOpts(defaults, opts) {\n    if (opts == null || typeof opts !== 'object')\n        throw new Error('options must be defined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** Compares 2 uint8array-s in kinda constant time. */\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * Wraps a cipher: validates args, ensures encrypt() can only be called once.\n * @__NO_SIDE_EFFECTS__\n */\nconst wrapCipher = (params, constructor) => {\n    function wrappedCipher(key, ...args) {\n        // Validate key\n        abytes(key, undefined, 'key');\n        // Big-Endian hardware is rare. Just in case someone still decides to run ciphers:\n        if (!isLE)\n            throw new Error('Non little-endian hardware is not yet supported');\n        // Validate nonce if nonceLength is present\n        if (params.nonceLength !== undefined) {\n            const nonce = args[0];\n            abytes(nonce, params.varSizeNonce ? undefined : params.nonceLength, 'nonce');\n        }\n        // Validate AAD if tagLength present\n        const tagl = params.tagLength;\n        if (tagl && args[1] !== undefined)\n            abytes(args[1], undefined, 'AAD');\n        const cipher = constructor(key, ...args);\n        const checkOutput = (fnLength, output) => {\n            if (output !== undefined) {\n                if (fnLength !== 2)\n                    throw new Error('cipher output not supported');\n                abytes(output, undefined, 'output');\n            }\n        };\n        // Create wrapped cipher with validation and single-use encryption\n        let called = false;\n        const wrCipher = {\n            encrypt(data, output) {\n                if (called)\n                    throw new Error('cannot encrypt() twice with same key + nonce');\n                called = true;\n                abytes(data);\n                checkOutput(cipher.encrypt.length, output);\n                return cipher.encrypt(data, output);\n            },\n            decrypt(data, output) {\n                abytes(data);\n                if (tagl && data.length < tagl)\n                    throw new Error('\"ciphertext\" expected length bigger than tagLength=' + tagl);\n                checkOutput(cipher.decrypt.length, output);\n                return cipher.decrypt(data, output);\n            },\n        };\n        return wrCipher;\n    }\n    Object.assign(wrappedCipher, params);\n    return wrappedCipher;\n};\n/**\n * By default, returns u8a of length.\n * When out is available, it checks it for validity and uses it.\n */\nfunction getOutput(expectedLength, out, onlyAligned = true) {\n    if (out === undefined)\n        return new Uint8Array(expectedLength);\n    if (out.length !== expectedLength)\n        throw new Error('\"output\" expected Uint8Array of length ' + expectedLength + ', got: ' + out.length);\n    if (onlyAligned && !isAligned32(out))\n        throw new Error('invalid output, must be aligned');\n    return out;\n}\nfunction u64Lengths(dataLength, aadLength, isLE) {\n    abool(isLE);\n    const num = new Uint8Array(16);\n    const view = createView(num);\n    view.setBigUint64(0, BigInt(aadLength), isLE);\n    view.setBigUint64(8, BigInt(dataLength), isLE);\n    return num;\n}\n// Is byte array aligned to 4 byte offset (u32)?\nfunction isAligned32(bytes) {\n    return bytes.byteOffset % 4 === 0;\n}\n// copy bytes to new u8a (aligned). Because Buffer.slice is broken.\nfunction copyBytes(bytes) {\n    return Uint8Array.from(bytes);\n}\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nfunction randomBytes(bytesLength = 32) {\n    const cr = typeof globalThis === 'object' ? globalThis.crypto : null;\n    if (typeof cr?.getRandomValues !== 'function')\n        throw new Error('crypto.getRandomValues must be defined');\n    return cr.getRandomValues(new Uint8Array(bytesLength));\n}\n/**\n * Uses CSPRG for nonce, nonce injected in ciphertext.\n * For `encrypt`, a `nonceBytes`-length buffer is fetched from CSPRNG and\n * prepended to encrypted ciphertext. For `decrypt`, first `nonceBytes` of ciphertext\n * are treated as nonce.\n *\n * NOTE: Under the same key, using random nonces (e.g. `managedNonce`) with AES-GCM and ChaCha\n * should be limited to `2**23` (8M) messages to get a collision chance of `2**-50`. Stretching to  * `2**32` (4B) messages, chance would become `2**-33` - still negligible, but creeping up.\n * @example\n * const gcm = managedNonce(aes.gcm);\n * const ciphr = gcm(key).encrypt(data);\n * const plain = gcm(key).decrypt(ciph);\n */\nfunction managedNonce(fn, randomBytes_ = randomBytes) {\n    const { nonceLength } = fn;\n    anumber(nonceLength);\n    const addNonce = (nonce, ciphertext) => {\n        const out = concatBytes(nonce, ciphertext);\n        ciphertext.fill(0);\n        return out;\n    };\n    // NOTE: we cannot support DST here, it would be mistake:\n    // - we don't know how much dst length cipher requires\n    // - nonce may unalign dst and break everything\n    // - we create new u8a anyway (concatBytes)\n    // - previously we passed all args to cipher, but that was mistake!\n    return ((key, ...args) => ({\n        encrypt(plaintext) {\n            abytes(plaintext);\n            const nonce = randomBytes_(nonceLength);\n            const encrypted = fn(key, nonce, ...args).encrypt(plaintext);\n            // @ts-ignore\n            if (encrypted instanceof Promise)\n                return encrypted.then((ct) => addNonce(nonce, ct));\n            return addNonce(nonce, encrypted);\n        },\n        decrypt(ciphertext) {\n            abytes(ciphertext);\n            const nonce = ciphertext.subarray(0, nonceLength);\n            const decrypted = ciphertext.subarray(nonceLength);\n            return fn(key, nonce, ...args).decrypt(decrypted);\n        },\n    }));\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2NpcGhlcnMvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE1BQU07QUFDMUMsK0NBQStDLE9BQU87QUFDdEQsc0NBQXNDLElBQUksWUFBWSxhQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUCxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXV0b3BsYW5jYW0vLi9ub2RlX21vZHVsZXMvQG5vYmxlL2NpcGhlcnMvdXRpbHMuanM/Y2ZiNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdGllcyBmb3IgaGV4LCBieXRlcywgQ1NQUk5HLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY2lwaGVycyAtIE1JVCBMaWNlbnNlIChjKSAyMDIzIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLyoqIENoZWNrcyBpZiBzb21ldGhpbmcgaXMgVWludDhBcnJheS4gQmUgY2FyZWZ1bDogbm9kZWpzIEJ1ZmZlciB3aWxsIHJldHVybiB0cnVlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiBhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCAoQXJyYXlCdWZmZXIuaXNWaWV3KGEpICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKTtcbn1cbi8qKiBBc3NlcnRzIHNvbWV0aGluZyBpcyBib29sZWFuLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBib29sZWFuIGV4cGVjdGVkLCBub3QgJHtifWApO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIHBvc2l0aXZlIGludGVnZXIuICovXG5leHBvcnQgZnVuY3Rpb24gYW51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb3NpdGl2ZSBpbnRlZ2VyIGV4cGVjdGVkLCBnb3QgJyArIG4pO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIFVpbnQ4QXJyYXkuICovXG5leHBvcnQgZnVuY3Rpb24gYWJ5dGVzKHZhbHVlLCBsZW5ndGgsIHRpdGxlID0gJycpIHtcbiAgICBjb25zdCBieXRlcyA9IGlzQnl0ZXModmFsdWUpO1xuICAgIGNvbnN0IGxlbiA9IHZhbHVlPy5sZW5ndGg7XG4gICAgY29uc3QgbmVlZHNMZW4gPSBsZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICBpZiAoIWJ5dGVzIHx8IChuZWVkc0xlbiAmJiBsZW4gIT09IGxlbmd0aCkpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gdGl0bGUgJiYgYFwiJHt0aXRsZX1cIiBgO1xuICAgICAgICBjb25zdCBvZkxlbiA9IG5lZWRzTGVuID8gYCBvZiBsZW5ndGggJHtsZW5ndGh9YCA6ICcnO1xuICAgICAgICBjb25zdCBnb3QgPSBieXRlcyA/IGBsZW5ndGg9JHtsZW59YCA6IGB0eXBlPSR7dHlwZW9mIHZhbHVlfWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcmVmaXggKyAnZXhwZWN0ZWQgVWludDhBcnJheScgKyBvZkxlbiArICcsIGdvdCAnICsgZ290KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqIEFzc2VydHMgYSBoYXNoIGluc3RhbmNlIGhhcyBub3QgYmVlbiBkZXN0cm95ZWQgLyBmaW5pc2hlZCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbi8qKiBBc3NlcnRzIG91dHB1dCBpcyBwcm9wZXJseS1zaXplZCBieXRlIGFycmF5ICovXG5leHBvcnQgZnVuY3Rpb24gYW91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYWJ5dGVzKG91dCwgdW5kZWZpbmVkLCAnb3V0cHV0Jyk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJyArIG1pbik7XG4gICAgfVxufVxuLyoqIENhc3QgdTggLyB1MTYgLyB1MzIgdG8gdTguICovXG5leHBvcnQgZnVuY3Rpb24gdTgoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG59XG4vKiogQ2FzdCB1OCAvIHUxNiAvIHUzMiB0byB1MzIuICovXG5leHBvcnQgZnVuY3Rpb24gdTMyKGFycikge1xuICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG59XG4vKiogWmVyb2l6ZSBhIGJ5dGUgYXJyYXkuIFdhcm5pbmc6IEpTIHByb3ZpZGVzIG5vIGd1YXJhbnRlZXMuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYW4oLi4uYXJyYXlzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXlzW2ldLmZpbGwoMCk7XG4gICAgfVxufVxuLyoqIENyZWF0ZSBEYXRhVmlldyBvZiBhbiBhcnJheSBmb3IgZWFzeSBieXRlLWxldmVsIG1hbmlwdWxhdGlvbi4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWaWV3KGFycikge1xuICAgIHJldHVybiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbn1cbi8qKiBJcyBjdXJyZW50IHBsYXRmb3JtIGxpdHRsZS1lbmRpYW4/IE1vc3QgYXJlLiBCaWctRW5kaWFuIHBsYXRmb3JtOiBJQk0gKi9cbmV4cG9ydCBjb25zdCBpc0xFID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0KSgpO1xuLy8gQnVpbHQtaW4gaGV4IGNvbnZlcnNpb24gaHR0cHM6Ly9jYW5pdXNlLmNvbS9tZG4tamF2YXNjcmlwdF9idWlsdGluc191aW50OGFycmF5X2Zyb21oZXhcbmNvbnN0IGhhc0hleEJ1aWx0aW4gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IFxuLy8gQHRzLWlnbm9yZVxudHlwZW9mIFVpbnQ4QXJyYXkuZnJvbShbXSkudG9IZXggPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFVpbnQ4QXJyYXkuZnJvbUhleCA9PT0gJ2Z1bmN0aW9uJykoKTtcbi8vIEFycmF5IHdoZXJlIGluZGV4IDB4ZjAgKDI0MCkgaXMgbWFwcGVkIHRvIHN0cmluZyAnZjAnXG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBDb252ZXJ0IGJ5dGUgYXJyYXkgdG8gaGV4IHN0cmluZy4gVXNlcyBidWlsdC1pbiBmdW5jdGlvbiwgd2hlbiBhdmFpbGFibGUuXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgYWJ5dGVzKGJ5dGVzKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGhhc0hleEJ1aWx0aW4pXG4gICAgICAgIHJldHVybiBieXRlcy50b0hleCgpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vLyBXZSB1c2Ugb3B0aW1pemVkIHRlY2huaXF1ZSB0byBjb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheVxuY29uc3QgYXNjaWlzID0geyBfMDogNDgsIF85OiA1NywgQTogNjUsIEY6IDcwLCBhOiA5NywgZjogMTAyIH07XG5mdW5jdGlvbiBhc2NpaVRvQmFzZTE2KGNoKSB7XG4gICAgaWYgKGNoID49IGFzY2lpcy5fMCAmJiBjaCA8PSBhc2NpaXMuXzkpXG4gICAgICAgIHJldHVybiBjaCAtIGFzY2lpcy5fMDsgLy8gJzInID0+IDUwLTQ4XG4gICAgaWYgKGNoID49IGFzY2lpcy5BICYmIGNoIDw9IGFzY2lpcy5GKVxuICAgICAgICByZXR1cm4gY2ggLSAoYXNjaWlzLkEgLSAxMCk7IC8vICdCJyA9PiA2Ni0oNjUtMTApXG4gICAgaWYgKGNoID49IGFzY2lpcy5hICYmIGNoIDw9IGFzY2lpcy5mKVxuICAgICAgICByZXR1cm4gY2ggLSAoYXNjaWlzLmEgLSAxMCk7IC8vICdiJyA9PiA5OC0oOTctMTApXG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBDb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheS4gVXNlcyBidWlsdC1pbiBmdW5jdGlvbiwgd2hlbiBhdmFpbGFibGUuXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoaGFzSGV4QnVpbHRpbilcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbUhleChoZXgpO1xuICAgIGNvbnN0IGhsID0gaGV4Lmxlbmd0aDtcbiAgICBjb25zdCBhbCA9IGhsIC8gMjtcbiAgICBpZiAoaGwgJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7IC8vIG11bHRpcGx5IGZpcnN0IG9jdGV0LCBlLmcuICdhMycgPT4gMTAqMTYrMyA9PiAxNjAgKyAzID0+IDE2M1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBVc2VkIGluIG1pY3JvXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgcmV0dXJuIEJpZ0ludChoZXggPT09ICcnID8gJzAnIDogJzB4JyArIGhleCk7IC8vIEJpZyBFbmRpYW5cbn1cbi8vIFVzZWQgaW4gZmYxXG4vLyBCRTogQmlnIEVuZGlhbiwgTEU6IExpdHRsZSBFbmRpYW5cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpIHtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xufVxuLy8gVXNlZCBpbiBtaWNybywgZmYxXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KGxlbiAqIDIsICcwJykpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBzdHJpbmcgdG8gYnl0ZXMgdXNpbmcgVVRGOCBlbmNvZGluZy5cbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLyoqXG4gKiBDb252ZXJ0cyBieXRlcyB0byBzdHJpbmcgdXNpbmcgVVRGOCBlbmNvZGluZy5cbiAqIEBleGFtcGxlIGJ5dGVzVG9VdGY4KG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSkpIC8vICdhYmMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvVXRmOChieXRlcykge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIFU4QSB1c2Ugc2FtZSB1bmRlcmx5aW5nIGJ1ZmZlciBhbmQgb3ZlcmxhcHMuXG4gKiBUaGlzIGlzIGludmFsaWQgYW5kIGNhbiBjb3JydXB0IGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvdmVybGFwQnl0ZXMoYSwgYikge1xuICAgIHJldHVybiAoYS5idWZmZXIgPT09IGIuYnVmZmVyICYmIC8vIGJlc3Qgd2UgY2FuIGRvLCBtYXkgZmFpbCB3aXRoIGFuIG9ic2N1cmUgUHJveHlcbiAgICAgICAgYS5ieXRlT2Zmc2V0IDwgYi5ieXRlT2Zmc2V0ICsgYi5ieXRlTGVuZ3RoICYmIC8vIGEgc3RhcnRzIGJlZm9yZSBiIGVuZFxuICAgICAgICBiLmJ5dGVPZmZzZXQgPCBhLmJ5dGVPZmZzZXQgKyBhLmJ5dGVMZW5ndGggLy8gYiBzdGFydHMgYmVmb3JlIGEgZW5kXG4gICAgKTtcbn1cbi8qKlxuICogSWYgaW5wdXQgYW5kIG91dHB1dCBvdmVybGFwIGFuZCBpbnB1dCBzdGFydHMgYmVmb3JlIG91dHB1dCwgd2Ugd2lsbCBvdmVyd3JpdGUgZW5kIG9mIGlucHV0IGJlZm9yZVxuICogd2Ugc3RhcnQgcHJvY2Vzc2luZyBpdCwgc28gdGhpcyBpcyBub3Qgc3VwcG9ydGVkIGZvciBtb3N0IGNpcGhlcnMgKGV4Y2VwdCBjaGFjaGEvc2Fsc2UsIHdoaWNoIGRlc2lnbmVkIHdpdGggdGhpcylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBsZXhPdmVybGFwQnl0ZXMoaW5wdXQsIG91dHB1dCkge1xuICAgIC8vIFRoaXMgaXMgdmVyeSBjdXJzZWQuIEl0IHdvcmtzIHNvbWVob3csIGJ1dCBJJ20gY29tcGxldGVseSB1bnN1cmUsXG4gICAgLy8gcmVhc29uaW5nIGFib3V0IG92ZXJsYXBwaW5nIGFsaWduZWQgd2luZG93cyBpcyB2ZXJ5IGhhcmQuXG4gICAgaWYgKG92ZXJsYXBCeXRlcyhpbnB1dCwgb3V0cHV0KSAmJiBpbnB1dC5ieXRlT2Zmc2V0IDwgb3V0cHV0LmJ5dGVPZmZzZXQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29tcGxleCBvdmVybGFwIG9mIGlucHV0IGFuZCBvdXRwdXQgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIGFieXRlcyhhKTtcbiAgICAgICAgc3VtICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzID09IG51bGwgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbi8qKiBDb21wYXJlcyAyIHVpbnQ4YXJyYXktcyBpbiBraW5kYSBjb25zdGFudCB0aW1lLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsQnl0ZXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZGlmZiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBkaWZmIHw9IGFbaV0gXiBiW2ldO1xuICAgIHJldHVybiBkaWZmID09PSAwO1xufVxuLyoqXG4gKiBXcmFwcyBhIGNpcGhlcjogdmFsaWRhdGVzIGFyZ3MsIGVuc3VyZXMgZW5jcnlwdCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZXhwb3J0IGNvbnN0IHdyYXBDaXBoZXIgPSAocGFyYW1zLCBjb25zdHJ1Y3RvcikgPT4ge1xuICAgIGZ1bmN0aW9uIHdyYXBwZWRDaXBoZXIoa2V5LCAuLi5hcmdzKSB7XG4gICAgICAgIC8vIFZhbGlkYXRlIGtleVxuICAgICAgICBhYnl0ZXMoa2V5LCB1bmRlZmluZWQsICdrZXknKTtcbiAgICAgICAgLy8gQmlnLUVuZGlhbiBoYXJkd2FyZSBpcyByYXJlLiBKdXN0IGluIGNhc2Ugc29tZW9uZSBzdGlsbCBkZWNpZGVzIHRvIHJ1biBjaXBoZXJzOlxuICAgICAgICBpZiAoIWlzTEUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCB5ZXQgc3VwcG9ydGVkJyk7XG4gICAgICAgIC8vIFZhbGlkYXRlIG5vbmNlIGlmIG5vbmNlTGVuZ3RoIGlzIHByZXNlbnRcbiAgICAgICAgaWYgKHBhcmFtcy5ub25jZUxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBub25jZSA9IGFyZ3NbMF07XG4gICAgICAgICAgICBhYnl0ZXMobm9uY2UsIHBhcmFtcy52YXJTaXplTm9uY2UgPyB1bmRlZmluZWQgOiBwYXJhbXMubm9uY2VMZW5ndGgsICdub25jZScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFZhbGlkYXRlIEFBRCBpZiB0YWdMZW5ndGggcHJlc2VudFxuICAgICAgICBjb25zdCB0YWdsID0gcGFyYW1zLnRhZ0xlbmd0aDtcbiAgICAgICAgaWYgKHRhZ2wgJiYgYXJnc1sxXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgYWJ5dGVzKGFyZ3NbMV0sIHVuZGVmaW5lZCwgJ0FBRCcpO1xuICAgICAgICBjb25zdCBjaXBoZXIgPSBjb25zdHJ1Y3RvcihrZXksIC4uLmFyZ3MpO1xuICAgICAgICBjb25zdCBjaGVja091dHB1dCA9IChmbkxlbmd0aCwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICBpZiAob3V0cHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm5MZW5ndGggIT09IDIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2lwaGVyIG91dHB1dCBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgYWJ5dGVzKG91dHB1dCwgdW5kZWZpbmVkLCAnb3V0cHV0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIENyZWF0ZSB3cmFwcGVkIGNpcGhlciB3aXRoIHZhbGlkYXRpb24gYW5kIHNpbmdsZS11c2UgZW5jcnlwdGlvblxuICAgICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHdyQ2lwaGVyID0ge1xuICAgICAgICAgICAgZW5jcnlwdChkYXRhLCBvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGVkKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBlbmNyeXB0KCkgdHdpY2Ugd2l0aCBzYW1lIGtleSArIG5vbmNlJyk7XG4gICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhYnl0ZXMoZGF0YSk7XG4gICAgICAgICAgICAgICAgY2hlY2tPdXRwdXQoY2lwaGVyLmVuY3J5cHQubGVuZ3RoLCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaXBoZXIuZW5jcnlwdChkYXRhLCBvdXRwdXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY3J5cHQoZGF0YSwgb3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgYWJ5dGVzKGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmICh0YWdsICYmIGRhdGEubGVuZ3RoIDwgdGFnbClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImNpcGhlcnRleHRcIiBleHBlY3RlZCBsZW5ndGggYmlnZ2VyIHRoYW4gdGFnTGVuZ3RoPScgKyB0YWdsKTtcbiAgICAgICAgICAgICAgICBjaGVja091dHB1dChjaXBoZXIuZGVjcnlwdC5sZW5ndGgsIG91dHB1dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNpcGhlci5kZWNyeXB0KGRhdGEsIG91dHB1dCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gd3JDaXBoZXI7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24od3JhcHBlZENpcGhlciwgcGFyYW1zKTtcbiAgICByZXR1cm4gd3JhcHBlZENpcGhlcjtcbn07XG4vKipcbiAqIEJ5IGRlZmF1bHQsIHJldHVybnMgdThhIG9mIGxlbmd0aC5cbiAqIFdoZW4gb3V0IGlzIGF2YWlsYWJsZSwgaXQgY2hlY2tzIGl0IGZvciB2YWxpZGl0eSBhbmQgdXNlcyBpdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE91dHB1dChleHBlY3RlZExlbmd0aCwgb3V0LCBvbmx5QWxpZ25lZCA9IHRydWUpIHtcbiAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShleHBlY3RlZExlbmd0aCk7XG4gICAgaWYgKG91dC5sZW5ndGggIT09IGV4cGVjdGVkTGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wib3V0cHV0XCIgZXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJyArIGV4cGVjdGVkTGVuZ3RoICsgJywgZ290OiAnICsgb3V0Lmxlbmd0aCk7XG4gICAgaWYgKG9ubHlBbGlnbmVkICYmICFpc0FsaWduZWQzMihvdXQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgb3V0cHV0LCBtdXN0IGJlIGFsaWduZWQnKTtcbiAgICByZXR1cm4gb3V0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHU2NExlbmd0aHMoZGF0YUxlbmd0aCwgYWFkTGVuZ3RoLCBpc0xFKSB7XG4gICAgYWJvb2woaXNMRSk7XG4gICAgY29uc3QgbnVtID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgIGNvbnN0IHZpZXcgPSBjcmVhdGVWaWV3KG51bSk7XG4gICAgdmlldy5zZXRCaWdVaW50NjQoMCwgQmlnSW50KGFhZExlbmd0aCksIGlzTEUpO1xuICAgIHZpZXcuc2V0QmlnVWludDY0KDgsIEJpZ0ludChkYXRhTGVuZ3RoKSwgaXNMRSk7XG4gICAgcmV0dXJuIG51bTtcbn1cbi8vIElzIGJ5dGUgYXJyYXkgYWxpZ25lZCB0byA0IGJ5dGUgb2Zmc2V0ICh1MzIpP1xuZXhwb3J0IGZ1bmN0aW9uIGlzQWxpZ25lZDMyKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGJ5dGVzLmJ5dGVPZmZzZXQgJSA0ID09PSAwO1xufVxuLy8gY29weSBieXRlcyB0byBuZXcgdThhIChhbGlnbmVkKS4gQmVjYXVzZSBCdWZmZXIuc2xpY2UgaXMgYnJva2VuLlxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlCeXRlcyhieXRlcykge1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYnl0ZXMpO1xufVxuLyoqIENyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBQUk5HLiBVc2VzIGludGVybmFsIE9TLWxldmVsIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYC4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgY29uc3QgY3IgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgPyBnbG9iYWxUaGlzLmNyeXB0byA6IG51bGw7XG4gICAgaWYgKHR5cGVvZiBjcj8uZ2V0UmFuZG9tVmFsdWVzICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuIGNyLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xufVxuLyoqXG4gKiBVc2VzIENTUFJHIGZvciBub25jZSwgbm9uY2UgaW5qZWN0ZWQgaW4gY2lwaGVydGV4dC5cbiAqIEZvciBgZW5jcnlwdGAsIGEgYG5vbmNlQnl0ZXNgLWxlbmd0aCBidWZmZXIgaXMgZmV0Y2hlZCBmcm9tIENTUFJORyBhbmRcbiAqIHByZXBlbmRlZCB0byBlbmNyeXB0ZWQgY2lwaGVydGV4dC4gRm9yIGBkZWNyeXB0YCwgZmlyc3QgYG5vbmNlQnl0ZXNgIG9mIGNpcGhlcnRleHRcbiAqIGFyZSB0cmVhdGVkIGFzIG5vbmNlLlxuICpcbiAqIE5PVEU6IFVuZGVyIHRoZSBzYW1lIGtleSwgdXNpbmcgcmFuZG9tIG5vbmNlcyAoZS5nLiBgbWFuYWdlZE5vbmNlYCkgd2l0aCBBRVMtR0NNIGFuZCBDaGFDaGFcbiAqIHNob3VsZCBiZSBsaW1pdGVkIHRvIGAyKioyM2AgKDhNKSBtZXNzYWdlcyB0byBnZXQgYSBjb2xsaXNpb24gY2hhbmNlIG9mIGAyKiotNTBgLiBTdHJldGNoaW5nIHRvICAqIGAyKiozMmAgKDRCKSBtZXNzYWdlcywgY2hhbmNlIHdvdWxkIGJlY29tZSBgMioqLTMzYCAtIHN0aWxsIG5lZ2xpZ2libGUsIGJ1dCBjcmVlcGluZyB1cC5cbiAqIEBleGFtcGxlXG4gKiBjb25zdCBnY20gPSBtYW5hZ2VkTm9uY2UoYWVzLmdjbSk7XG4gKiBjb25zdCBjaXBociA9IGdjbShrZXkpLmVuY3J5cHQoZGF0YSk7XG4gKiBjb25zdCBwbGFpbiA9IGdjbShrZXkpLmRlY3J5cHQoY2lwaCk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYW5hZ2VkTm9uY2UoZm4sIHJhbmRvbUJ5dGVzXyA9IHJhbmRvbUJ5dGVzKSB7XG4gICAgY29uc3QgeyBub25jZUxlbmd0aCB9ID0gZm47XG4gICAgYW51bWJlcihub25jZUxlbmd0aCk7XG4gICAgY29uc3QgYWRkTm9uY2UgPSAobm9uY2UsIGNpcGhlcnRleHQpID0+IHtcbiAgICAgICAgY29uc3Qgb3V0ID0gY29uY2F0Qnl0ZXMobm9uY2UsIGNpcGhlcnRleHQpO1xuICAgICAgICBjaXBoZXJ0ZXh0LmZpbGwoMCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICAvLyBOT1RFOiB3ZSBjYW5ub3Qgc3VwcG9ydCBEU1QgaGVyZSwgaXQgd291bGQgYmUgbWlzdGFrZTpcbiAgICAvLyAtIHdlIGRvbid0IGtub3cgaG93IG11Y2ggZHN0IGxlbmd0aCBjaXBoZXIgcmVxdWlyZXNcbiAgICAvLyAtIG5vbmNlIG1heSB1bmFsaWduIGRzdCBhbmQgYnJlYWsgZXZlcnl0aGluZ1xuICAgIC8vIC0gd2UgY3JlYXRlIG5ldyB1OGEgYW55d2F5IChjb25jYXRCeXRlcylcbiAgICAvLyAtIHByZXZpb3VzbHkgd2UgcGFzc2VkIGFsbCBhcmdzIHRvIGNpcGhlciwgYnV0IHRoYXQgd2FzIG1pc3Rha2UhXG4gICAgcmV0dXJuICgoa2V5LCAuLi5hcmdzKSA9PiAoe1xuICAgICAgICBlbmNyeXB0KHBsYWludGV4dCkge1xuICAgICAgICAgICAgYWJ5dGVzKHBsYWludGV4dCk7XG4gICAgICAgICAgICBjb25zdCBub25jZSA9IHJhbmRvbUJ5dGVzXyhub25jZUxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBlbmNyeXB0ZWQgPSBmbihrZXksIG5vbmNlLCAuLi5hcmdzKS5lbmNyeXB0KHBsYWludGV4dCk7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAoZW5jcnlwdGVkIGluc3RhbmNlb2YgUHJvbWlzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jcnlwdGVkLnRoZW4oKGN0KSA9PiBhZGROb25jZShub25jZSwgY3QpKTtcbiAgICAgICAgICAgIHJldHVybiBhZGROb25jZShub25jZSwgZW5jcnlwdGVkKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjcnlwdChjaXBoZXJ0ZXh0KSB7XG4gICAgICAgICAgICBhYnl0ZXMoY2lwaGVydGV4dCk7XG4gICAgICAgICAgICBjb25zdCBub25jZSA9IGNpcGhlcnRleHQuc3ViYXJyYXkoMCwgbm9uY2VMZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgZGVjcnlwdGVkID0gY2lwaGVydGV4dC5zdWJhcnJheShub25jZUxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gZm4oa2V5LCBub25jZSwgLi4uYXJncykuZGVjcnlwdChkZWNyeXB0ZWQpO1xuICAgICAgICB9LFxuICAgIH0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/ciphers/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/hashes/_md.js":
/*!*******************************************!*\
  !*** ./node_modules/@noble/hashes/_md.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: () => (/* binding */ Chi),\n/* harmony export */   HashMD: () => (/* binding */ HashMD),\n/* harmony export */   Maj: () => (/* binding */ Maj),\n/* harmony export */   SHA224_IV: () => (/* binding */ SHA224_IV),\n/* harmony export */   SHA256_IV: () => (/* binding */ SHA256_IV),\n/* harmony export */   SHA384_IV: () => (/* binding */ SHA384_IV),\n/* harmony export */   SHA512_IV: () => (/* binding */ SHA512_IV)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@noble/hashes/utils.js\");\n/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\n\n/** Choice: a ? b : c */\nfunction Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nfunction Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD {\n    blockLen;\n    outputLen;\n    padOffset;\n    isLE;\n    // For partial updates less than block size\n    buffer;\n    view;\n    finished = false;\n    length = 0;\n    pos = 0;\n    destroyed = false;\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aoutput)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which must be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen must be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to ||= new this.constructor();\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nconst SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nconst SHA224_IV = /* @__PURE__ */ Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nconst SHA384_IV = /* @__PURE__ */ Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nconst SHA512_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fbWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUN5RTtBQUN6RTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQVU7QUFDOUI7QUFDQTtBQUNBLFFBQVEsa0RBQU87QUFDZixRQUFRLGlEQUFNO0FBQ2QsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxREFBVTtBQUMzQyx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTztBQUNmLFFBQVEsa0RBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQSxRQUFRLGdEQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2F1dG9wbGFuY2FtLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX21kLmpzPzg5NjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbnRlcm5hbCBNZXJrbGUtRGFtZ2FyZCBoYXNoIHV0aWxzLlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyBhYnl0ZXMsIGFleGlzdHMsIGFvdXRwdXQsIGNsZWFuLCBjcmVhdGVWaWV3IH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8qKiBDaG9pY2U6IGEgPyBiIDogYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIENoaShhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChhICYgYikgXiAofmEgJiBjKTtcbn1cbi8qKiBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHV0cyBpcyB0cnVlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE1haihhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbn1cbi8qKlxuICogTWVya2xlLURhbWdhcmQgaGFzaCBjb25zdHJ1Y3Rpb24gYmFzZSBjbGFzcy5cbiAqIENvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIE1ENSwgUklQRU1ELCBTSEExLCBTSEEyLlxuICovXG5leHBvcnQgY2xhc3MgSGFzaE1EIHtcbiAgICBibG9ja0xlbjtcbiAgICBvdXRwdXRMZW47XG4gICAgcGFkT2Zmc2V0O1xuICAgIGlzTEU7XG4gICAgLy8gRm9yIHBhcnRpYWwgdXBkYXRlcyBsZXNzIHRoYW4gYmxvY2sgc2l6ZVxuICAgIGJ1ZmZlcjtcbiAgICB2aWV3O1xuICAgIGZpbmlzaGVkID0gZmFsc2U7XG4gICAgbGVuZ3RoID0gMDtcbiAgICBwb3MgPSAwO1xuICAgIGRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICBhYnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYWV4aXN0cyh0aGlzKTtcbiAgICAgICAgYW91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIGNsZWFuKHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykpO1xuICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluXG4gICAgICAgIC8vIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgICAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgICAgICB2aWV3LnNldEJpZ1VpbnQ2NChibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIG11c3QgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgICAgICBpZiAobGVuICUgNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBtdXN0IGJlIGFsaWduZWQgdG8gMzJiaXQnKTtcbiAgICAgICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgICAgICBpZiAob3V0TGVuID4gc3RhdGUubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspXG4gICAgICAgICAgICBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvIHx8PSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbi8qKlxuICogSW5pdGlhbCBTSEEtMiBzdGF0ZTogZnJhY3Rpb25hbCBwYXJ0cyBvZiBzcXVhcmUgcm9vdHMgb2YgZmlyc3QgMTYgcHJpbWVzIDIuLjUzLlxuICogQ2hlY2sgb3V0IGB0ZXN0L21pc2Mvc2hhMi1nZW4taXYuanNgIGZvciByZWNvbXB1dGF0aW9uIGd1aWRlLlxuICovXG4vKiogSW5pdGlhbCBTSEEyNTYgc3RhdGUuIEJpdHMgMC4uMzIgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIuLjE5ICovXG5leHBvcnQgY29uc3QgU0hBMjU2X0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTksXG5dKTtcbi8qKiBJbml0aWFsIFNIQTIyNCBzdGF0ZS4gQml0cyAzMi4uNjQgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIzLi41MyAqL1xuZXhwb3J0IGNvbnN0IFNIQTIyNF9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweGMxMDU5ZWQ4LCAweDM2N2NkNTA3LCAweDMwNzBkZDE3LCAweGY3MGU1OTM5LCAweGZmYzAwYjMxLCAweDY4NTgxNTExLCAweDY0Zjk4ZmE3LCAweGJlZmE0ZmE0LFxuXSk7XG4vKiogSW5pdGlhbCBTSEEzODQgc3RhdGUuIEJpdHMgMC4uNjQgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIzLi41MyAqL1xuZXhwb3J0IGNvbnN0IFNIQTM4NF9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweGNiYmI5ZDVkLCAweGMxMDU5ZWQ4LCAweDYyOWEyOTJhLCAweDM2N2NkNTA3LCAweDkxNTkwMTVhLCAweDMwNzBkZDE3LCAweDE1MmZlY2Q4LCAweGY3MGU1OTM5LFxuICAgIDB4NjczMzI2NjcsIDB4ZmZjMDBiMzEsIDB4OGViNDRhODcsIDB4Njg1ODE1MTEsIDB4ZGIwYzJlMGQsIDB4NjRmOThmYTcsIDB4NDdiNTQ4MWQsIDB4YmVmYTRmYTQsXG5dKTtcbi8qKiBJbml0aWFsIFNIQTUxMiBzdGF0ZS4gQml0cyAwLi42NCBvZiBmcmFjIHBhcnQgb2Ygc3FydCBvZiBwcmltZXMgMi4uMTkgKi9cbmV4cG9ydCBjb25zdCBTSEE1MTJfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg2YTA5ZTY2NywgMHhmM2JjYzkwOCwgMHhiYjY3YWU4NSwgMHg4NGNhYTczYiwgMHgzYzZlZjM3MiwgMHhmZTk0ZjgyYiwgMHhhNTRmZjUzYSwgMHg1ZjFkMzZmMSxcbiAgICAweDUxMGU1MjdmLCAweGFkZTY4MmQxLCAweDliMDU2ODhjLCAweDJiM2U2YzFmLCAweDFmODNkOWFiLCAweGZiNDFiZDZiLCAweDViZTBjZDE5LCAweDEzN2UyMTc5LFxuXSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fbWQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/hashes/_md.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/hashes/_u64.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/_u64.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\n/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64);\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fdTY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0IsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnTDtBQUNoTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxHQUFHLEVBQUM7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hdXRvcGxhbmNhbS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL191NjQuanM/ODZjMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEludGVybmFsIGhlbHBlcnMgZm9yIHU2NC4gQmlnVWludDY0QXJyYXkgaXMgdG9vIHNsb3cgYXMgcGVyIDIwMjUsIHNvIHdlIGltcGxlbWVudCBpdCB1c2luZyBVaW50MzJBcnJheS5cbiAqIEB0b2RvIHJlLWNoZWNrIGh0dHBzOi8vaXNzdWVzLmNocm9taXVtLm9yZy9pc3N1ZXMvNDIyMTI1ODhcbiAqIEBtb2R1bGVcbiAqL1xuY29uc3QgVTMyX01BU0s2NCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuY29uc3QgXzMybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMzIpO1xuZnVuY3Rpb24gZnJvbUJpZyhuLCBsZSA9IGZhbHNlKSB7XG4gICAgaWYgKGxlKVxuICAgICAgICByZXR1cm4geyBoOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpLCBsOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB9O1xuICAgIHJldHVybiB7IGg6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSB8IDAgfTtcbn1cbmZ1bmN0aW9uIHNwbGl0KGxzdCwgbGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxlbiA9IGxzdC5sZW5ndGg7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxlbik7XG4gICAgbGV0IEFsID0gbmV3IFVpbnQzMkFycmF5KGxlbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIF9sLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChfaCwgbCkgPT4gbDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgX2wpID0+IGg7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCB7IGFkZCwgYWRkM0gsIGFkZDNMLCBhZGQ0SCwgYWRkNEwsIGFkZDVILCBhZGQ1TCwgZnJvbUJpZywgcm90bEJILCByb3RsQkwsIHJvdGxTSCwgcm90bFNMLCByb3RyMzJILCByb3RyMzJMLCByb3RyQkgsIHJvdHJCTCwgcm90clNILCByb3RyU0wsIHNoclNILCBzaHJTTCwgc3BsaXQsIHRvQmlnIH07XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHU2NCA9IHtcbiAgICBmcm9tQmlnLCBzcGxpdCwgdG9CaWcsXG4gICAgc2hyU0gsIHNoclNMLFxuICAgIHJvdHJTSCwgcm90clNMLCByb3RyQkgsIHJvdHJCTCxcbiAgICByb3RyMzJILCByb3RyMzJMLFxuICAgIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCxcbiAgICBhZGQsIGFkZDNMLCBhZGQzSCwgYWRkNEwsIGFkZDRILCBhZGQ1SCwgYWRkNUwsXG59O1xuZXhwb3J0IGRlZmF1bHQgdTY0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3U2NC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/hashes/_u64.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/hashes/hmac.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/hmac.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _HMAC: () => (/* binding */ _HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@noble/hashes/utils.js\");\n/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\n\n/** Internal class for HMAC. */\nclass _HMAC {\n    oHash;\n    iHash;\n    blockLen;\n    outputLen;\n    finished = false;\n    destroyed = false;\n    constructor(hash, key) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ahash)(hash);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(key, undefined, 'key');\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(pad);\n    }\n    update(buf) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(out, this.outputLen, 'output');\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to ||= Object.create(Object.getPrototypeOf(this), {});\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nconst hmac = (hash, key, message) => new _HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new _HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9obWFjLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQzJEO0FBQzNEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQUs7QUFDYixRQUFRLGlEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0EsUUFBUSxnREFBSztBQUNiO0FBQ0E7QUFDQSxRQUFRLGtEQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFPO0FBQ2YsUUFBUSxpREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVELGdCQUFnQix5REFBeUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXV0b3BsYW5jYW0vLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9obWFjLmpzPzdmMjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBtb2R1bGVcbiAqL1xuaW1wb3J0IHsgYWJ5dGVzLCBhZXhpc3RzLCBhaGFzaCwgY2xlYW4gfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLyoqIEludGVybmFsIGNsYXNzIGZvciBITUFDLiAqL1xuZXhwb3J0IGNsYXNzIF9ITUFDIHtcbiAgICBvSGFzaDtcbiAgICBpSGFzaDtcbiAgICBibG9ja0xlbjtcbiAgICBvdXRwdXRMZW47XG4gICAgZmluaXNoZWQgPSBmYWxzZTtcbiAgICBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBrZXkpIHtcbiAgICAgICAgYWhhc2goaGFzaCk7XG4gICAgICAgIGFieXRlcyhrZXksIHVuZGVmaW5lZCwgJ2tleScpO1xuICAgICAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoJyk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgICAgICBjb25zdCBibG9ja0xlbiA9IHRoaXMuYmxvY2tMZW47XG4gICAgICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgLy8gYmxvY2tMZW4gY2FuIGJlIGJpZ2dlciB0aGFuIG91dHB1dExlblxuICAgICAgICBwYWQuc2V0KGtleS5sZW5ndGggPiBibG9ja0xlbiA/IGhhc2guY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICAvLyBCeSBkb2luZyB1cGRhdGUgKHByb2Nlc3Npbmcgb2YgZmlyc3QgYmxvY2spIG9mIG91dGVyIGhhc2ggaGVyZSB3ZSBjYW4gcmUtdXNlIGl0IGJldHdlZW4gbXVsdGlwbGUgY2FsbHMgdmlhIGNsb25lXG4gICAgICAgIHRoaXMub0hhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1JcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIGNsZWFuKHBhZCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgYWV4aXN0cyh0aGlzKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIGFieXRlcyhvdXQsIHRoaXMub3V0cHV0TGVuLCAnb3V0cHV0Jyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlIYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3Igc2luY2Uga2V5IGFscmVhZHkgaW4gc3RhdGUgYW5kIHdlIGRvbid0IGtub3cgaXQuXG4gICAgICAgIHRvIHx8PSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pO1xuICAgICAgICBjb25zdCB7IG9IYXNoLCBpSGFzaCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgYmxvY2tMZW4sIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdG8gPSB0bztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICB0by5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLm9IYXNoID0gb0hhc2guX2Nsb25lSW50byh0by5vSGFzaCk7XG4gICAgICAgIHRvLmlIYXNoID0gaUhhc2guX2Nsb25lSW50byh0by5pSGFzaCk7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9IYXNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pSGFzaC5kZXN0cm95KCk7XG4gICAgfVxufVxuLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBwYXJhbSBoYXNoIC0gZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0ga2V5IC0gbWVzc2FnZSBrZXlcbiAqIEBwYXJhbSBtZXNzYWdlIC0gbWVzc2FnZSBkYXRhXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaG1hYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvaG1hYyc7XG4gKiBpbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTInO1xuICogY29uc3QgbWFjMSA9IGhtYWMoc2hhMjU2LCAna2V5JywgJ21lc3NhZ2UnKTtcbiAqL1xuZXhwb3J0IGNvbnN0IGhtYWMgPSAoaGFzaCwga2V5LCBtZXNzYWdlKSA9PiBuZXcgX0hNQUMoaGFzaCwga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCk7XG5obWFjLmNyZWF0ZSA9IChoYXNoLCBrZXkpID0+IG5ldyBfSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/hashes/hmac.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/hashes/pbkdf2.js":
/*!**********************************************!*\
  !*** ./node_modules/@noble/hashes/pbkdf2.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pbkdf2: () => (/* binding */ pbkdf2),\n/* harmony export */   pbkdf2Async: () => (/* binding */ pbkdf2Async)\n/* harmony export */ });\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hmac.js */ \"(rsc)/./node_modules/@noble/hashes/hmac.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@noble/hashes/utils.js\");\n/**\n * PBKDF (RFC 2898). Can be used to create a key from password and salt.\n * @module\n */\n\n// prettier-ignore\n\n// Common start and end for sync/async functions\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ahash)(hash);\n    const opts = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);\n    const { c, dkLen, asyncTick } = opts;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(c, 'c');\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(dkLen, 'dkLen');\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(asyncTick, 'asyncTick');\n    if (c < 1)\n        throw new Error('iterations (c) must be >= 1');\n    const password = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.kdfInputToBytes)(_password, 'password');\n    const salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.kdfInputToBytes)(_salt, 'salt');\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n    const DK = new Uint8Array(dkLen);\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    const PRF = _hmac_js__WEBPACK_IMPORTED_MODULE_1__.hmac.create(hash, password);\n    const PRFSalt = PRF._cloneInto().update(salt);\n    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW)\n        prfW.destroy();\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(u);\n    return DK;\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n * @example\n * const key = pbkdf2(sha256, 'password', 'salt', { dkLen: 32, c: Math.pow(2, 18) });\n */\nfunction pbkdf2(hash, password, salt, opts) {\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + ⋯ + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for (let ui = 1; ui < c; ui++) {\n            // Uc = PRF(Password, Uc−1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        }\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function. Async version.\n * @example\n * await pbkdf2Async(sha256, 'password', 'salt', { dkLen: 32, c: 500_000 });\n */\nasync function pbkdf2Async(hash, password, salt, opts) {\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + ⋯ + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.asyncLoop)(c - 1, asyncTick, () => {\n            // Uc = PRF(Password, Uc−1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        });\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n//# sourceMappingURL=pbkdf2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9wYmtkZjIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2lDO0FBQ2pDO0FBQ3NHO0FBQ3RHO0FBQ0E7QUFDQSxJQUFJLGdEQUFLO0FBQ1QsaUJBQWlCLG9EQUFTLEdBQUcsMEJBQTBCO0FBQ3ZELFlBQVksc0JBQXNCO0FBQ2xDLElBQUksa0RBQU87QUFDWCxJQUFJLGtEQUFPO0FBQ1gsSUFBSSxrREFBTztBQUNYO0FBQ0E7QUFDQSxxQkFBcUIsMERBQWU7QUFDcEMsaUJBQWlCLDBEQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQ0FBSTtBQUNwQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdEQUFLO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBLG9EQUFvRCwrQkFBK0I7QUFDbkY7QUFDTztBQUNQLFlBQVksNkJBQTZCO0FBQ3pDLGNBQWM7QUFDZDtBQUNBLGlCQUFpQixxREFBVTtBQUMzQjtBQUNBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx1QkFBdUI7QUFDMUU7QUFDTztBQUNQLFlBQVksd0NBQXdDO0FBQ3BELGNBQWM7QUFDZDtBQUNBLGlCQUFpQixxREFBVTtBQUMzQjtBQUNBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9EQUFTO0FBQ3ZCO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2F1dG9wbGFuY2FtLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvcGJrZGYyLmpzPzYzYmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQQktERiAoUkZDIDI4OTgpLiBDYW4gYmUgdXNlZCB0byBjcmVhdGUgYSBrZXkgZnJvbSBwYXNzd29yZCBhbmQgc2FsdC5cbiAqIEBtb2R1bGVcbiAqL1xuaW1wb3J0IHsgaG1hYyB9IGZyb20gXCIuL2htYWMuanNcIjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuaW1wb3J0IHsgYWhhc2gsIGFudW1iZXIsIGFzeW5jTG9vcCwgY2hlY2tPcHRzLCBjbGVhbiwgY3JlYXRlVmlldywga2RmSW5wdXRUb0J5dGVzIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8vIENvbW1vbiBzdGFydCBhbmQgZW5kIGZvciBzeW5jL2FzeW5jIGZ1bmN0aW9uc1xuZnVuY3Rpb24gcGJrZGYySW5pdChoYXNoLCBfcGFzc3dvcmQsIF9zYWx0LCBfb3B0cykge1xuICAgIGFoYXNoKGhhc2gpO1xuICAgIGNvbnN0IG9wdHMgPSBjaGVja09wdHMoeyBka0xlbjogMzIsIGFzeW5jVGljazogMTAgfSwgX29wdHMpO1xuICAgIGNvbnN0IHsgYywgZGtMZW4sIGFzeW5jVGljayB9ID0gb3B0cztcbiAgICBhbnVtYmVyKGMsICdjJyk7XG4gICAgYW51bWJlcihka0xlbiwgJ2RrTGVuJyk7XG4gICAgYW51bWJlcihhc3luY1RpY2ssICdhc3luY1RpY2snKTtcbiAgICBpZiAoYyA8IDEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaXRlcmF0aW9ucyAoYykgbXVzdCBiZSA+PSAxJyk7XG4gICAgY29uc3QgcGFzc3dvcmQgPSBrZGZJbnB1dFRvQnl0ZXMoX3Bhc3N3b3JkLCAncGFzc3dvcmQnKTtcbiAgICBjb25zdCBzYWx0ID0ga2RmSW5wdXRUb0J5dGVzKF9zYWx0LCAnc2FsdCcpO1xuICAgIC8vIERLID0gUEJLREYyKFBSRiwgUGFzc3dvcmQsIFNhbHQsIGMsIGRrTGVuKTtcbiAgICBjb25zdCBESyA9IG5ldyBVaW50OEFycmF5KGRrTGVuKTtcbiAgICAvLyBVMSA9IFBSRihQYXNzd29yZCwgU2FsdCArIElOVF8zMl9CRShpKSlcbiAgICBjb25zdCBQUkYgPSBobWFjLmNyZWF0ZShoYXNoLCBwYXNzd29yZCk7XG4gICAgY29uc3QgUFJGU2FsdCA9IFBSRi5fY2xvbmVJbnRvKCkudXBkYXRlKHNhbHQpO1xuICAgIHJldHVybiB7IGMsIGRrTGVuLCBhc3luY1RpY2ssIERLLCBQUkYsIFBSRlNhbHQgfTtcbn1cbmZ1bmN0aW9uIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KSB7XG4gICAgUFJGLmRlc3Ryb3koKTtcbiAgICBQUkZTYWx0LmRlc3Ryb3koKTtcbiAgICBpZiAocHJmVylcbiAgICAgICAgcHJmVy5kZXN0cm95KCk7XG4gICAgY2xlYW4odSk7XG4gICAgcmV0dXJuIERLO1xufVxuLyoqXG4gKiBQQktERjItSE1BQzogUkZDIDI4OTgga2V5IGRlcml2YXRpb24gZnVuY3Rpb25cbiAqIEBwYXJhbSBoYXNoIC0gaGFzaCBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBwYXNzd29yZCAtIHBhc3N3b3JkIGZyb20gd2hpY2ggYSBkZXJpdmVkIGtleSBpcyBnZW5lcmF0ZWRcbiAqIEBwYXJhbSBzYWx0IC0gY3J5cHRvZ3JhcGhpYyBzYWx0XG4gKiBAcGFyYW0gb3B0cyAtIHtjLCBka0xlbn0gd2hlcmUgYyBpcyB3b3JrIGZhY3RvciBhbmQgZGtMZW4gaXMgb3V0cHV0IG1lc3NhZ2Ugc2l6ZVxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGtleSA9IHBia2RmMihzaGEyNTYsICdwYXNzd29yZCcsICdzYWx0JywgeyBka0xlbjogMzIsIGM6IE1hdGgucG93KDIsIDE4KSB9KTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBia2RmMihoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cykge1xuICAgIGNvbnN0IHsgYywgZGtMZW4sIERLLCBQUkYsIFBSRlNhbHQgfSA9IHBia2RmMkluaXQoaGFzaCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpO1xuICAgIGxldCBwcmZXOyAvLyBXb3JraW5nIGNvcHlcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBjb25zdCB2aWV3ID0gY3JlYXRlVmlldyhhcnIpO1xuICAgIGNvbnN0IHUgPSBuZXcgVWludDhBcnJheShQUkYub3V0cHV0TGVuKTtcbiAgICAvLyBESyA9IFQxICsgVDIgKyDii68gKyBUZGtsZW4vaGxlblxuICAgIGZvciAobGV0IHRpID0gMSwgcG9zID0gMDsgcG9zIDwgZGtMZW47IHRpKyssIHBvcyArPSBQUkYub3V0cHV0TGVuKSB7XG4gICAgICAgIC8vIFRpID0gRihQYXNzd29yZCwgU2FsdCwgYywgaSlcbiAgICAgICAgY29uc3QgVGkgPSBESy5zdWJhcnJheShwb3MsIHBvcyArIFBSRi5vdXRwdXRMZW4pO1xuICAgICAgICB2aWV3LnNldEludDMyKDAsIHRpLCBmYWxzZSk7XG4gICAgICAgIC8vIEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpID0gVTEgXiBVMiBeIOKLryBeIFVjXG4gICAgICAgIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxuICAgICAgICAocHJmVyA9IFBSRlNhbHQuX2Nsb25lSW50byhwcmZXKSkudXBkYXRlKGFycikuZGlnZXN0SW50byh1KTtcbiAgICAgICAgVGkuc2V0KHUuc3ViYXJyYXkoMCwgVGkubGVuZ3RoKSk7XG4gICAgICAgIGZvciAobGV0IHVpID0gMTsgdWkgPCBjOyB1aSsrKSB7XG4gICAgICAgICAgICAvLyBVYyA9IFBSRihQYXNzd29yZCwgVWPiiJIxKVxuICAgICAgICAgICAgUFJGLl9jbG9uZUludG8ocHJmVykudXBkYXRlKHUpLmRpZ2VzdEludG8odSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRpLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIFRpW2ldIF49IHVbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KTtcbn1cbi8qKlxuICogUEJLREYyLUhNQUM6IFJGQyAyODk4IGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLiBBc3luYyB2ZXJzaW9uLlxuICogQGV4YW1wbGVcbiAqIGF3YWl0IHBia2RmMkFzeW5jKHNoYTI1NiwgJ3Bhc3N3b3JkJywgJ3NhbHQnLCB7IGRrTGVuOiAzMiwgYzogNTAwXzAwMCB9KTtcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBia2RmMkFzeW5jKGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBjLCBka0xlbiwgYXN5bmNUaWNrLCBESywgUFJGLCBQUkZTYWx0IH0gPSBwYmtkZjJJbml0KGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcbiAgICBsZXQgcHJmVzsgLy8gV29ya2luZyBjb3B5XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgY29uc3QgdmlldyA9IGNyZWF0ZVZpZXcoYXJyKTtcbiAgICBjb25zdCB1ID0gbmV3IFVpbnQ4QXJyYXkoUFJGLm91dHB1dExlbik7XG4gICAgLy8gREsgPSBUMSArIFQyICsg4ouvICsgVGRrbGVuL2hsZW5cbiAgICBmb3IgKGxldCB0aSA9IDEsIHBvcyA9IDA7IHBvcyA8IGRrTGVuOyB0aSsrLCBwb3MgKz0gUFJGLm91dHB1dExlbikge1xuICAgICAgICAvLyBUaSA9IEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpXG4gICAgICAgIGNvbnN0IFRpID0gREsuc3ViYXJyYXkocG9zLCBwb3MgKyBQUkYub3V0cHV0TGVuKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCB0aSwgZmFsc2UpO1xuICAgICAgICAvLyBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKSA9IFUxIF4gVTIgXiDii68gXiBVY1xuICAgICAgICAvLyBVMSA9IFBSRihQYXNzd29yZCwgU2FsdCArIElOVF8zMl9CRShpKSlcbiAgICAgICAgKHByZlcgPSBQUkZTYWx0Ll9jbG9uZUludG8ocHJmVykpLnVwZGF0ZShhcnIpLmRpZ2VzdEludG8odSk7XG4gICAgICAgIFRpLnNldCh1LnN1YmFycmF5KDAsIFRpLmxlbmd0aCkpO1xuICAgICAgICBhd2FpdCBhc3luY0xvb3AoYyAtIDEsIGFzeW5jVGljaywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gVWMgPSBQUkYoUGFzc3dvcmQsIFVj4oiSMSlcbiAgICAgICAgICAgIFBSRi5fY2xvbmVJbnRvKHByZlcpLnVwZGF0ZSh1KS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBUaS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBUaVtpXSBePSB1W2ldO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBia2RmMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/hashes/pbkdf2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/hashes/scrypt.js":
/*!**********************************************!*\
  !*** ./node_modules/@noble/hashes/scrypt.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scrypt: () => (/* binding */ scrypt),\n/* harmony export */   scryptAsync: () => (/* binding */ scryptAsync)\n/* harmony export */ });\n/* harmony import */ var _pbkdf2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pbkdf2.js */ \"(rsc)/./node_modules/@noble/hashes/pbkdf2.js\");\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sha2.js */ \"(rsc)/./node_modules/@noble/hashes/sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@noble/hashes/utils.js\");\n/**\n * RFC 7914 Scrypt KDF. Can be used to create a key from password and salt.\n * @module\n */\n\n\n// prettier-ignore\n\n// The main Scrypt loop: uses Salsa extensively.\n// Six versions of the function were tried, this is the fastest one.\n// prettier-ignore\nfunction XorAndSalsa(prev, pi, input, ii, out, oi) {\n    // Based on https://cr.yp.to/salsa20.html\n    // Xor blocks\n    let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];\n    let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];\n    let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];\n    let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];\n    let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];\n    let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];\n    let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];\n    let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];\n    // Save state to temporary variables (salsa)\n    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n    // Main loop (salsa)\n    for (let i = 0; i < 8; i += 2) {\n        x04 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x00 + x12 | 0, 7);\n        x08 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 + x00 | 0, 9);\n        x12 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x08 + x04 | 0, 13);\n        x00 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 + x08 | 0, 18);\n        x09 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 + x01 | 0, 7);\n        x13 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x09 + x05 | 0, 9);\n        x01 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 + x09 | 0, 13);\n        x05 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x01 + x13 | 0, 18);\n        x14 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x10 + x06 | 0, 7);\n        x02 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 + x10 | 0, 9);\n        x06 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x02 + x14 | 0, 13);\n        x10 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 + x02 | 0, 18);\n        x03 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 + x11 | 0, 7);\n        x07 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x03 + x15 | 0, 9);\n        x11 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 + x03 | 0, 13);\n        x15 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x11 + x07 | 0, 18);\n        x01 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x00 + x03 | 0, 7);\n        x02 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x01 + x00 | 0, 9);\n        x03 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x02 + x01 | 0, 13);\n        x00 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x03 + x02 | 0, 18);\n        x06 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 + x04 | 0, 7);\n        x07 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 + x05 | 0, 9);\n        x04 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 + x06 | 0, 13);\n        x05 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 + x07 | 0, 18);\n        x11 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x10 + x09 | 0, 7);\n        x08 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x11 + x10 | 0, 9);\n        x09 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x08 + x11 | 0, 13);\n        x10 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x09 + x08 | 0, 18);\n        x12 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 + x14 | 0, 7);\n        x13 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 + x15 | 0, 9);\n        x14 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 + x12 | 0, 13);\n        x15 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 + x13 | 0, 18);\n    }\n    // Write output (salsa)\n    out[oi++] = (y00 + x00) | 0;\n    out[oi++] = (y01 + x01) | 0;\n    out[oi++] = (y02 + x02) | 0;\n    out[oi++] = (y03 + x03) | 0;\n    out[oi++] = (y04 + x04) | 0;\n    out[oi++] = (y05 + x05) | 0;\n    out[oi++] = (y06 + x06) | 0;\n    out[oi++] = (y07 + x07) | 0;\n    out[oi++] = (y08 + x08) | 0;\n    out[oi++] = (y09 + x09) | 0;\n    out[oi++] = (y10 + x10) | 0;\n    out[oi++] = (y11 + x11) | 0;\n    out[oi++] = (y12 + x12) | 0;\n    out[oi++] = (y13 + x13) | 0;\n    out[oi++] = (y14 + x14) | 0;\n    out[oi++] = (y15 + x15) | 0;\n}\nfunction BlockMix(input, ii, out, oi, r) {\n    // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)\n    let head = oi + 0;\n    let tail = oi + 16 * r;\n    for (let i = 0; i < 16; i++)\n        out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X ← B[2r−1]\n    for (let i = 0; i < r; i++, head += 16, ii += 16) {\n        // We write odd & even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1\n        XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2*i] ^ tail[i-1])\n        if (i > 0)\n            tail += 16; // First iteration overwrites tmp value in tail\n        XorAndSalsa(out, head, input, (ii += 16), out, tail); // tail[i] = Salsa(blockIn[2*i+1] ^ head[i])\n    }\n}\n// Common prologue and epilogue for sync/async functions\nfunction scryptInit(password, salt, _opts) {\n    // Maxmem - 1GB+1KB by default\n    const opts = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.checkOpts)({\n        dkLen: 32,\n        asyncTick: 10,\n        maxmem: 1024 ** 3 + 1024,\n    }, _opts);\n    const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(N, 'N');\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(r, 'r');\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(p, 'p');\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(dkLen, 'dkLen');\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(asyncTick, 'asyncTick');\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber)(maxmem, 'maxmem');\n    if (onProgress !== undefined && typeof onProgress !== 'function')\n        throw new Error('progressCb must be a function');\n    const blockSize = 128 * r;\n    const blockSize32 = blockSize / 4;\n    // Max N is 2^32 (Integrify is 32-bit).\n    // Real limit can be 2^22: some JS engines limit Uint8Array to 4GB.\n    // Spec check `N >= 2^(blockSize / 8)` is not done for compat with popular libs,\n    // which used incorrect r: 1, p: 8. Also, the check seems to be a spec error:\n    // https://www.rfc-editor.org/errata_search.php?rfc=7914\n    const pow32 = Math.pow(2, 32);\n    if (N <= 1 || (N & (N - 1)) !== 0 || N > pow32)\n        throw new Error('\"N\" expected a power of 2, and 2^1 <= N <= 2^32');\n    if (p < 1 || p > ((pow32 - 1) * 32) / blockSize)\n        throw new Error('\"p\" expected integer 1..((2^32 - 1) * 32) / (128 * r)');\n    if (dkLen < 1 || dkLen > (pow32 - 1) * 32)\n        throw new Error('\"dkLen\" expected integer 1..(2^32 - 1) * 32');\n    const memUsed = blockSize * (N + p);\n    if (memUsed > maxmem)\n        throw new Error('\"maxmem\" limit was hit, expected 128*r*(N+p) <= \"maxmem\"=' + maxmem);\n    // [B0...Bp−1] ← PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)\n    // Since it has only one iteration there is no reason to use async variant\n    const B = (0,_pbkdf2_js__WEBPACK_IMPORTED_MODULE_1__.pbkdf2)(_sha2_js__WEBPACK_IMPORTED_MODULE_2__.sha256, password, salt, { c: 1, dkLen: blockSize * p });\n    const B32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(B);\n    // Re-used between parallel iterations. Array(iterations) of B\n    const V = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(new Uint8Array(blockSize * N));\n    const tmp = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(new Uint8Array(blockSize));\n    let blockMixCb = () => { };\n    if (onProgress) {\n        const totalBlockMix = 2 * N * p;\n        // Invoke callback if progress changes from 10.01 to 10.02\n        // Allows to draw smooth progress bar on up to 8K screen\n        const callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);\n        let blockMixCnt = 0;\n        blockMixCb = () => {\n            blockMixCnt++;\n            if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))\n                onProgress(blockMixCnt / totalBlockMix);\n        };\n    }\n    return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };\n}\nfunction scryptOutput(password, dkLen, B, V, tmp) {\n    const res = (0,_pbkdf2_js__WEBPACK_IMPORTED_MODULE_1__.pbkdf2)(_sha2_js__WEBPACK_IMPORTED_MODULE_2__.sha256, password, B, { c: 1, dkLen });\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(B, V, tmp);\n    return res;\n}\n/**\n * Scrypt KDF from RFC 7914. See {@link ScryptOpts}.\n * @example\n * scrypt('password', 'salt', { N: 2**18, r: 8, p: 1, dkLen: 32 });\n */\nfunction scrypt(password, salt, opts) {\n    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.swap32IfBE)(B32);\n    for (let pi = 0; pi < p; pi++) {\n        const Pi = blockSize32 * pi;\n        for (let i = 0; i < blockSize32; i++)\n            V[i] = B32[Pi + i]; // V[0] = B[i]\n        for (let i = 0, pos = 0; i < N - 1; i++) {\n            BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\n            blockMixCb();\n        }\n        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n        blockMixCb();\n        for (let i = 0; i < N; i++) {\n            // First u32 of the last 64-byte block (u32 is LE)\n            // & (N - 1) is % N as N is a power of 2, N & (N - 1) = 0 is checked above; >>> 0 for unsigned, input fits in u32\n            const j = (B32[Pi + blockSize32 - 16] & (N - 1)) >>> 0; // j = Integrify(X) % iterations\n            for (let k = 0; k < blockSize32; k++)\n                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n            blockMixCb();\n        }\n    }\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.swap32IfBE)(B32);\n    return scryptOutput(password, dkLen, B, V, tmp);\n}\n/**\n * Scrypt KDF from RFC 7914. Async version. See {@link ScryptOpts}.\n * @example\n * await scryptAsync('password', 'salt', { N: 2**18, r: 8, p: 1, dkLen: 32 });\n */\nasync function scryptAsync(password, salt, opts) {\n    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.swap32IfBE)(B32);\n    for (let pi = 0; pi < p; pi++) {\n        const Pi = blockSize32 * pi;\n        for (let i = 0; i < blockSize32; i++)\n            V[i] = B32[Pi + i]; // V[0] = B[i]\n        let pos = 0;\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.asyncLoop)(N - 1, asyncTick, () => {\n            BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\n            blockMixCb();\n        });\n        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n        blockMixCb();\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.asyncLoop)(N, asyncTick, () => {\n            // First u32 of the last 64-byte block (u32 is LE)\n            // & (N - 1) is % N as N is a power of 2, N & (N - 1) = 0 is checked above; >>> 0 for unsigned, input fits in u32\n            const j = (B32[Pi + blockSize32 - 16] & (N - 1)) >>> 0; // j = Integrify(X) % iterations\n            for (let k = 0; k < blockSize32; k++)\n                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n            blockMixCb();\n        });\n    }\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.swap32IfBE)(B32);\n    return scryptOutput(password, dkLen, B, V, tmp);\n}\n//# sourceMappingURL=scrypt.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zY3J5cHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQztBQUNGO0FBQ25DO0FBQ3lGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixlQUFlLCtDQUFJO0FBQ25CLGVBQWUsK0NBQUk7QUFDbkIsZUFBZSwrQ0FBSTtBQUNuQixlQUFlLCtDQUFJO0FBQ25CLGVBQWUsK0NBQUk7QUFDbkIsZUFBZSwrQ0FBSTtBQUNuQixlQUFlLCtDQUFJO0FBQ25CLGVBQWUsK0NBQUk7QUFDbkIsZUFBZSwrQ0FBSTtBQUNuQixlQUFlLCtDQUFJO0FBQ25CLGVBQWUsK0NBQUk7QUFDbkIsZUFBZSwrQ0FBSTtBQUNuQixlQUFlLCtDQUFJO0FBQ25CLGVBQWUsK0NBQUk7QUFDbkIsZUFBZSwrQ0FBSTtBQUNuQixlQUFlLCtDQUFJO0FBQ25CLGVBQWUsK0NBQUk7QUFDbkIsZUFBZSwrQ0FBSTtBQUNuQixlQUFlLCtDQUFJO0FBQ25CLGVBQWUsK0NBQUk7QUFDbkIsZUFBZSwrQ0FBSTtBQUNuQixlQUFlLCtDQUFJO0FBQ25CLGVBQWUsK0NBQUk7QUFDbkIsZUFBZSwrQ0FBSTtBQUNuQixlQUFlLCtDQUFJO0FBQ25CLGVBQWUsK0NBQUk7QUFDbkIsZUFBZSwrQ0FBSTtBQUNuQixlQUFlLCtDQUFJO0FBQ25CLGVBQWUsK0NBQUk7QUFDbkIsZUFBZSwrQ0FBSTtBQUNuQixlQUFlLCtDQUFJO0FBQ25CLGVBQWUsK0NBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCLDBEQUEwRDtBQUMxRCxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLHdCQUF3QjtBQUN4Qiw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvREFBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxnREFBZ0Q7QUFDNUQsSUFBSSxrREFBTztBQUNYLElBQUksa0RBQU87QUFDWCxJQUFJLGtEQUFPO0FBQ1gsSUFBSSxrREFBTztBQUNYLElBQUksa0RBQU87QUFDWCxJQUFJLGtEQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrREFBTSxDQUFDLDRDQUFNLG9CQUFvQiw0QkFBNEI7QUFDM0UsZ0JBQWdCLDhDQUFHO0FBQ25CO0FBQ0EsY0FBYyw4Q0FBRztBQUNqQixnQkFBZ0IsOENBQUc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQixrREFBTSxDQUFDLDRDQUFNLGlCQUFpQixhQUFhO0FBQzNELElBQUksZ0RBQUs7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25EO0FBQ0EsZ0NBQWdDLGlDQUFpQztBQUNqRTtBQUNPO0FBQ1AsWUFBWSwwREFBMEQ7QUFDdEUsSUFBSSxxREFBVTtBQUNkLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QyxnQ0FBZ0M7QUFDaEMsaUNBQWlDLFdBQVc7QUFDNUMsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBLHdGQUF3RjtBQUN4RixvRUFBb0U7QUFDcEUsNEJBQTRCLGlCQUFpQjtBQUM3QywrREFBK0Q7QUFDL0QsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLElBQUkscURBQVU7QUFDZDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUJBQWlCO0FBQ2xFO0FBQ0EsMkNBQTJDLGlDQUFpQztBQUM1RTtBQUNPO0FBQ1AsWUFBWSxxRUFBcUU7QUFDakYsSUFBSSxxREFBVTtBQUNkLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QyxnQ0FBZ0M7QUFDaEM7QUFDQSxjQUFjLG9EQUFTO0FBQ3ZCLDBEQUEwRDtBQUMxRDtBQUNBLFNBQVM7QUFDVCx3REFBd0Q7QUFDeEQ7QUFDQSxjQUFjLG9EQUFTO0FBQ3ZCO0FBQ0Esd0ZBQXdGO0FBQ3hGLG9FQUFvRTtBQUNwRSw0QkFBNEIsaUJBQWlCO0FBQzdDLCtEQUErRDtBQUMvRCwwQ0FBMEM7QUFDMUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxJQUFJLHFEQUFVO0FBQ2Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXV0b3BsYW5jYW0vLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zY3J5cHQuanM/MjU0YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJGQyA3OTE0IFNjcnlwdCBLREYuIENhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIGtleSBmcm9tIHBhc3N3b3JkIGFuZCBzYWx0LlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyBwYmtkZjIgfSBmcm9tIFwiLi9wYmtkZjIuanNcIjtcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gXCIuL3NoYTIuanNcIjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuaW1wb3J0IHsgYW51bWJlciwgYXN5bmNMb29wLCBjaGVja09wdHMsIGNsZWFuLCByb3RsLCBzd2FwMzJJZkJFLCB1MzIgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLy8gVGhlIG1haW4gU2NyeXB0IGxvb3A6IHVzZXMgU2Fsc2EgZXh0ZW5zaXZlbHkuXG4vLyBTaXggdmVyc2lvbnMgb2YgdGhlIGZ1bmN0aW9uIHdlcmUgdHJpZWQsIHRoaXMgaXMgdGhlIGZhc3Rlc3Qgb25lLlxuLy8gcHJldHRpZXItaWdub3JlXG5mdW5jdGlvbiBYb3JBbmRTYWxzYShwcmV2LCBwaSwgaW5wdXQsIGlpLCBvdXQsIG9pKSB7XG4gICAgLy8gQmFzZWQgb24gaHR0cHM6Ly9jci55cC50by9zYWxzYTIwLmh0bWxcbiAgICAvLyBYb3IgYmxvY2tzXG4gICAgbGV0IHkwMCA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTAxID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIGxldCB5MDIgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkwMyA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcbiAgICBsZXQgeTA0ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MDUgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gICAgbGV0IHkwNiA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTA3ID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIGxldCB5MDggPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkwOSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcbiAgICBsZXQgeTEwID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdLCB5MTEgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK107XG4gICAgbGV0IHkxMiA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXSwgeTEzID0gcHJldltwaSsrXSBeIGlucHV0W2lpKytdO1xuICAgIGxldCB5MTQgPSBwcmV2W3BpKytdIF4gaW5wdXRbaWkrK10sIHkxNSA9IHByZXZbcGkrK10gXiBpbnB1dFtpaSsrXTtcbiAgICAvLyBTYXZlIHN0YXRlIHRvIHRlbXBvcmFyeSB2YXJpYWJsZXMgKHNhbHNhKVxuICAgIGxldCB4MDAgPSB5MDAsIHgwMSA9IHkwMSwgeDAyID0geTAyLCB4MDMgPSB5MDMsIHgwNCA9IHkwNCwgeDA1ID0geTA1LCB4MDYgPSB5MDYsIHgwNyA9IHkwNywgeDA4ID0geTA4LCB4MDkgPSB5MDksIHgxMCA9IHkxMCwgeDExID0geTExLCB4MTIgPSB5MTIsIHgxMyA9IHkxMywgeDE0ID0geTE0LCB4MTUgPSB5MTU7XG4gICAgLy8gTWFpbiBsb29wIChzYWxzYSlcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkgKz0gMikge1xuICAgICAgICB4MDQgXj0gcm90bCh4MDAgKyB4MTIgfCAwLCA3KTtcbiAgICAgICAgeDA4IF49IHJvdGwoeDA0ICsgeDAwIHwgMCwgOSk7XG4gICAgICAgIHgxMiBePSByb3RsKHgwOCArIHgwNCB8IDAsIDEzKTtcbiAgICAgICAgeDAwIF49IHJvdGwoeDEyICsgeDA4IHwgMCwgMTgpO1xuICAgICAgICB4MDkgXj0gcm90bCh4MDUgKyB4MDEgfCAwLCA3KTtcbiAgICAgICAgeDEzIF49IHJvdGwoeDA5ICsgeDA1IHwgMCwgOSk7XG4gICAgICAgIHgwMSBePSByb3RsKHgxMyArIHgwOSB8IDAsIDEzKTtcbiAgICAgICAgeDA1IF49IHJvdGwoeDAxICsgeDEzIHwgMCwgMTgpO1xuICAgICAgICB4MTQgXj0gcm90bCh4MTAgKyB4MDYgfCAwLCA3KTtcbiAgICAgICAgeDAyIF49IHJvdGwoeDE0ICsgeDEwIHwgMCwgOSk7XG4gICAgICAgIHgwNiBePSByb3RsKHgwMiArIHgxNCB8IDAsIDEzKTtcbiAgICAgICAgeDEwIF49IHJvdGwoeDA2ICsgeDAyIHwgMCwgMTgpO1xuICAgICAgICB4MDMgXj0gcm90bCh4MTUgKyB4MTEgfCAwLCA3KTtcbiAgICAgICAgeDA3IF49IHJvdGwoeDAzICsgeDE1IHwgMCwgOSk7XG4gICAgICAgIHgxMSBePSByb3RsKHgwNyArIHgwMyB8IDAsIDEzKTtcbiAgICAgICAgeDE1IF49IHJvdGwoeDExICsgeDA3IHwgMCwgMTgpO1xuICAgICAgICB4MDEgXj0gcm90bCh4MDAgKyB4MDMgfCAwLCA3KTtcbiAgICAgICAgeDAyIF49IHJvdGwoeDAxICsgeDAwIHwgMCwgOSk7XG4gICAgICAgIHgwMyBePSByb3RsKHgwMiArIHgwMSB8IDAsIDEzKTtcbiAgICAgICAgeDAwIF49IHJvdGwoeDAzICsgeDAyIHwgMCwgMTgpO1xuICAgICAgICB4MDYgXj0gcm90bCh4MDUgKyB4MDQgfCAwLCA3KTtcbiAgICAgICAgeDA3IF49IHJvdGwoeDA2ICsgeDA1IHwgMCwgOSk7XG4gICAgICAgIHgwNCBePSByb3RsKHgwNyArIHgwNiB8IDAsIDEzKTtcbiAgICAgICAgeDA1IF49IHJvdGwoeDA0ICsgeDA3IHwgMCwgMTgpO1xuICAgICAgICB4MTEgXj0gcm90bCh4MTAgKyB4MDkgfCAwLCA3KTtcbiAgICAgICAgeDA4IF49IHJvdGwoeDExICsgeDEwIHwgMCwgOSk7XG4gICAgICAgIHgwOSBePSByb3RsKHgwOCArIHgxMSB8IDAsIDEzKTtcbiAgICAgICAgeDEwIF49IHJvdGwoeDA5ICsgeDA4IHwgMCwgMTgpO1xuICAgICAgICB4MTIgXj0gcm90bCh4MTUgKyB4MTQgfCAwLCA3KTtcbiAgICAgICAgeDEzIF49IHJvdGwoeDEyICsgeDE1IHwgMCwgOSk7XG4gICAgICAgIHgxNCBePSByb3RsKHgxMyArIHgxMiB8IDAsIDEzKTtcbiAgICAgICAgeDE1IF49IHJvdGwoeDE0ICsgeDEzIHwgMCwgMTgpO1xuICAgIH1cbiAgICAvLyBXcml0ZSBvdXRwdXQgKHNhbHNhKVxuICAgIG91dFtvaSsrXSA9ICh5MDAgKyB4MDApIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTAxICsgeDAxKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwMiArIHgwMikgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDMgKyB4MDMpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA0ICsgeDA0KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwNSArIHgwNSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDYgKyB4MDYpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA3ICsgeDA3KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwOCArIHgwOCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDkgKyB4MDkpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTEwICsgeDEwKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxMSArIHgxMSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTIgKyB4MTIpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTEzICsgeDEzKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxNCArIHgxNCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTUgKyB4MTUpIHwgMDtcbn1cbmZ1bmN0aW9uIEJsb2NrTWl4KGlucHV0LCBpaSwgb3V0LCBvaSwgcikge1xuICAgIC8vIFRoZSBibG9jayBCIGlzIHIgMTI4LWJ5dGUgY2h1bmtzICh3aGljaCBpcyBlcXVpdmFsZW50IG9mIDJyIDY0LWJ5dGUgY2h1bmtzKVxuICAgIGxldCBoZWFkID0gb2kgKyAwO1xuICAgIGxldCB0YWlsID0gb2kgKyAxNiAqIHI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgICAgICBvdXRbdGFpbCArIGldID0gaW5wdXRbaWkgKyAoMiAqIHIgLSAxKSAqIDE2ICsgaV07IC8vIFgg4oaQIEJbMnLiiJIxXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcjsgaSsrLCBoZWFkICs9IDE2LCBpaSArPSAxNikge1xuICAgICAgICAvLyBXZSB3cml0ZSBvZGQgJiBldmVuIFlpIGF0IHNhbWUgdGltZS4gRXZlbjogMGJYWFhYWDAgT2RkOiAgMGJYWFhYWDFcbiAgICAgICAgWG9yQW5kU2Fsc2Eob3V0LCB0YWlsLCBpbnB1dCwgaWksIG91dCwgaGVhZCk7IC8vIGhlYWRbaV0gPSBTYWxzYShibG9ja0luWzIqaV0gXiB0YWlsW2ktMV0pXG4gICAgICAgIGlmIChpID4gMClcbiAgICAgICAgICAgIHRhaWwgKz0gMTY7IC8vIEZpcnN0IGl0ZXJhdGlvbiBvdmVyd3JpdGVzIHRtcCB2YWx1ZSBpbiB0YWlsXG4gICAgICAgIFhvckFuZFNhbHNhKG91dCwgaGVhZCwgaW5wdXQsIChpaSArPSAxNiksIG91dCwgdGFpbCk7IC8vIHRhaWxbaV0gPSBTYWxzYShibG9ja0luWzIqaSsxXSBeIGhlYWRbaV0pXG4gICAgfVxufVxuLy8gQ29tbW9uIHByb2xvZ3VlIGFuZCBlcGlsb2d1ZSBmb3Igc3luYy9hc3luYyBmdW5jdGlvbnNcbmZ1bmN0aW9uIHNjcnlwdEluaXQocGFzc3dvcmQsIHNhbHQsIF9vcHRzKSB7XG4gICAgLy8gTWF4bWVtIC0gMUdCKzFLQiBieSBkZWZhdWx0XG4gICAgY29uc3Qgb3B0cyA9IGNoZWNrT3B0cyh7XG4gICAgICAgIGRrTGVuOiAzMixcbiAgICAgICAgYXN5bmNUaWNrOiAxMCxcbiAgICAgICAgbWF4bWVtOiAxMDI0ICoqIDMgKyAxMDI0LFxuICAgIH0sIF9vcHRzKTtcbiAgICBjb25zdCB7IE4sIHIsIHAsIGRrTGVuLCBhc3luY1RpY2ssIG1heG1lbSwgb25Qcm9ncmVzcyB9ID0gb3B0cztcbiAgICBhbnVtYmVyKE4sICdOJyk7XG4gICAgYW51bWJlcihyLCAncicpO1xuICAgIGFudW1iZXIocCwgJ3AnKTtcbiAgICBhbnVtYmVyKGRrTGVuLCAnZGtMZW4nKTtcbiAgICBhbnVtYmVyKGFzeW5jVGljaywgJ2FzeW5jVGljaycpO1xuICAgIGFudW1iZXIobWF4bWVtLCAnbWF4bWVtJyk7XG4gICAgaWYgKG9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb25Qcm9ncmVzcyAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9ncmVzc0NiIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIGNvbnN0IGJsb2NrU2l6ZSA9IDEyOCAqIHI7XG4gICAgY29uc3QgYmxvY2tTaXplMzIgPSBibG9ja1NpemUgLyA0O1xuICAgIC8vIE1heCBOIGlzIDJeMzIgKEludGVncmlmeSBpcyAzMi1iaXQpLlxuICAgIC8vIFJlYWwgbGltaXQgY2FuIGJlIDJeMjI6IHNvbWUgSlMgZW5naW5lcyBsaW1pdCBVaW50OEFycmF5IHRvIDRHQi5cbiAgICAvLyBTcGVjIGNoZWNrIGBOID49IDJeKGJsb2NrU2l6ZSAvIDgpYCBpcyBub3QgZG9uZSBmb3IgY29tcGF0IHdpdGggcG9wdWxhciBsaWJzLFxuICAgIC8vIHdoaWNoIHVzZWQgaW5jb3JyZWN0IHI6IDEsIHA6IDguIEFsc28sIHRoZSBjaGVjayBzZWVtcyB0byBiZSBhIHNwZWMgZXJyb3I6XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvZXJyYXRhX3NlYXJjaC5waHA/cmZjPTc5MTRcbiAgICBjb25zdCBwb3czMiA9IE1hdGgucG93KDIsIDMyKTtcbiAgICBpZiAoTiA8PSAxIHx8IChOICYgKE4gLSAxKSkgIT09IDAgfHwgTiA+IHBvdzMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiTlwiIGV4cGVjdGVkIGEgcG93ZXIgb2YgMiwgYW5kIDJeMSA8PSBOIDw9IDJeMzInKTtcbiAgICBpZiAocCA8IDEgfHwgcCA+ICgocG93MzIgLSAxKSAqIDMyKSAvIGJsb2NrU2l6ZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInBcIiBleHBlY3RlZCBpbnRlZ2VyIDEuLigoMl4zMiAtIDEpICogMzIpIC8gKDEyOCAqIHIpJyk7XG4gICAgaWYgKGRrTGVuIDwgMSB8fCBka0xlbiA+IChwb3czMiAtIDEpICogMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCJka0xlblwiIGV4cGVjdGVkIGludGVnZXIgMS4uKDJeMzIgLSAxKSAqIDMyJyk7XG4gICAgY29uc3QgbWVtVXNlZCA9IGJsb2NrU2l6ZSAqIChOICsgcCk7XG4gICAgaWYgKG1lbVVzZWQgPiBtYXhtZW0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCJtYXhtZW1cIiBsaW1pdCB3YXMgaGl0LCBleHBlY3RlZCAxMjgqciooTitwKSA8PSBcIm1heG1lbVwiPScgKyBtYXhtZW0pO1xuICAgIC8vIFtCMC4uLkJw4oiSMV0g4oaQIFBCS0RGMkhNQUMtU0hBMjU2KFBhc3NwaHJhc2UsIFNhbHQsIDEsIGJsb2NrU2l6ZSpQYXJhbGxlbGl6YXRpb25GYWN0b3IpXG4gICAgLy8gU2luY2UgaXQgaGFzIG9ubHkgb25lIGl0ZXJhdGlvbiB0aGVyZSBpcyBubyByZWFzb24gdG8gdXNlIGFzeW5jIHZhcmlhbnRcbiAgICBjb25zdCBCID0gcGJrZGYyKHNoYTI1NiwgcGFzc3dvcmQsIHNhbHQsIHsgYzogMSwgZGtMZW46IGJsb2NrU2l6ZSAqIHAgfSk7XG4gICAgY29uc3QgQjMyID0gdTMyKEIpO1xuICAgIC8vIFJlLXVzZWQgYmV0d2VlbiBwYXJhbGxlbCBpdGVyYXRpb25zLiBBcnJheShpdGVyYXRpb25zKSBvZiBCXG4gICAgY29uc3QgViA9IHUzMihuZXcgVWludDhBcnJheShibG9ja1NpemUgKiBOKSk7XG4gICAgY29uc3QgdG1wID0gdTMyKG5ldyBVaW50OEFycmF5KGJsb2NrU2l6ZSkpO1xuICAgIGxldCBibG9ja01peENiID0gKCkgPT4geyB9O1xuICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAgIGNvbnN0IHRvdGFsQmxvY2tNaXggPSAyICogTiAqIHA7XG4gICAgICAgIC8vIEludm9rZSBjYWxsYmFjayBpZiBwcm9ncmVzcyBjaGFuZ2VzIGZyb20gMTAuMDEgdG8gMTAuMDJcbiAgICAgICAgLy8gQWxsb3dzIHRvIGRyYXcgc21vb3RoIHByb2dyZXNzIGJhciBvbiB1cCB0byA4SyBzY3JlZW5cbiAgICAgICAgY29uc3QgY2FsbGJhY2tQZXIgPSBNYXRoLm1heChNYXRoLmZsb29yKHRvdGFsQmxvY2tNaXggLyAxMDAwMCksIDEpO1xuICAgICAgICBsZXQgYmxvY2tNaXhDbnQgPSAwO1xuICAgICAgICBibG9ja01peENiID0gKCkgPT4ge1xuICAgICAgICAgICAgYmxvY2tNaXhDbnQrKztcbiAgICAgICAgICAgIGlmIChvblByb2dyZXNzICYmICghKGJsb2NrTWl4Q250ICUgY2FsbGJhY2tQZXIpIHx8IGJsb2NrTWl4Q250ID09PSB0b3RhbEJsb2NrTWl4KSlcbiAgICAgICAgICAgICAgICBvblByb2dyZXNzKGJsb2NrTWl4Q250IC8gdG90YWxCbG9ja01peCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IE4sIHIsIHAsIGRrTGVuLCBibG9ja1NpemUzMiwgViwgQjMyLCBCLCB0bXAsIGJsb2NrTWl4Q2IsIGFzeW5jVGljayB9O1xufVxuZnVuY3Rpb24gc2NyeXB0T3V0cHV0KHBhc3N3b3JkLCBka0xlbiwgQiwgViwgdG1wKSB7XG4gICAgY29uc3QgcmVzID0gcGJrZGYyKHNoYTI1NiwgcGFzc3dvcmQsIEIsIHsgYzogMSwgZGtMZW4gfSk7XG4gICAgY2xlYW4oQiwgViwgdG1wKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBTY3J5cHQgS0RGIGZyb20gUkZDIDc5MTQuIFNlZSB7QGxpbmsgU2NyeXB0T3B0c30uXG4gKiBAZXhhbXBsZVxuICogc2NyeXB0KCdwYXNzd29yZCcsICdzYWx0JywgeyBOOiAyKioxOCwgcjogOCwgcDogMSwgZGtMZW46IDMyIH0pO1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2NyeXB0KHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBOLCByLCBwLCBka0xlbiwgYmxvY2tTaXplMzIsIFYsIEIzMiwgQiwgdG1wLCBibG9ja01peENiIH0gPSBzY3J5cHRJbml0KHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcbiAgICBzd2FwMzJJZkJFKEIzMik7XG4gICAgZm9yIChsZXQgcGkgPSAwOyBwaSA8IHA7IHBpKyspIHtcbiAgICAgICAgY29uc3QgUGkgPSBibG9ja1NpemUzMiAqIHBpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrU2l6ZTMyOyBpKyspXG4gICAgICAgICAgICBWW2ldID0gQjMyW1BpICsgaV07IC8vIFZbMF0gPSBCW2ldXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgTiAtIDE7IGkrKykge1xuICAgICAgICAgICAgQmxvY2tNaXgoViwgcG9zLCBWLCAocG9zICs9IGJsb2NrU2l6ZTMyKSwgcik7IC8vIFZbaV0gPSBCbG9ja01peChWW2ktMV0pO1xuICAgICAgICAgICAgYmxvY2tNaXhDYigpO1xuICAgICAgICB9XG4gICAgICAgIEJsb2NrTWl4KFYsIChOIC0gMSkgKiBibG9ja1NpemUzMiwgQjMyLCBQaSwgcik7IC8vIFByb2Nlc3MgbGFzdCBlbGVtZW50XG4gICAgICAgIGJsb2NrTWl4Q2IoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IHUzMiBvZiB0aGUgbGFzdCA2NC1ieXRlIGJsb2NrICh1MzIgaXMgTEUpXG4gICAgICAgICAgICAvLyAmIChOIC0gMSkgaXMgJSBOIGFzIE4gaXMgYSBwb3dlciBvZiAyLCBOICYgKE4gLSAxKSA9IDAgaXMgY2hlY2tlZCBhYm92ZTsgPj4+IDAgZm9yIHVuc2lnbmVkLCBpbnB1dCBmaXRzIGluIHUzMlxuICAgICAgICAgICAgY29uc3QgaiA9IChCMzJbUGkgKyBibG9ja1NpemUzMiAtIDE2XSAmIChOIC0gMSkpID4+PiAwOyAvLyBqID0gSW50ZWdyaWZ5KFgpICUgaXRlcmF0aW9uc1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBibG9ja1NpemUzMjsgaysrKVxuICAgICAgICAgICAgICAgIHRtcFtrXSA9IEIzMltQaSArIGtdIF4gVltqICogYmxvY2tTaXplMzIgKyBrXTsgLy8gdG1wID0gQiBeIFZbal1cbiAgICAgICAgICAgIEJsb2NrTWl4KHRtcCwgMCwgQjMyLCBQaSwgcik7IC8vIEIgPSBCbG9ja01peChCIF4gVltqXSlcbiAgICAgICAgICAgIGJsb2NrTWl4Q2IoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzd2FwMzJJZkJFKEIzMik7XG4gICAgcmV0dXJuIHNjcnlwdE91dHB1dChwYXNzd29yZCwgZGtMZW4sIEIsIFYsIHRtcCk7XG59XG4vKipcbiAqIFNjcnlwdCBLREYgZnJvbSBSRkMgNzkxNC4gQXN5bmMgdmVyc2lvbi4gU2VlIHtAbGluayBTY3J5cHRPcHRzfS5cbiAqIEBleGFtcGxlXG4gKiBhd2FpdCBzY3J5cHRBc3luYygncGFzc3dvcmQnLCAnc2FsdCcsIHsgTjogMioqMTgsIHI6IDgsIHA6IDEsIGRrTGVuOiAzMiB9KTtcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNjcnlwdEFzeW5jKHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBOLCByLCBwLCBka0xlbiwgYmxvY2tTaXplMzIsIFYsIEIzMiwgQiwgdG1wLCBibG9ja01peENiLCBhc3luY1RpY2sgfSA9IHNjcnlwdEluaXQocGFzc3dvcmQsIHNhbHQsIG9wdHMpO1xuICAgIHN3YXAzMklmQkUoQjMyKTtcbiAgICBmb3IgKGxldCBwaSA9IDA7IHBpIDwgcDsgcGkrKykge1xuICAgICAgICBjb25zdCBQaSA9IGJsb2NrU2l6ZTMyICogcGk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tTaXplMzI7IGkrKylcbiAgICAgICAgICAgIFZbaV0gPSBCMzJbUGkgKyBpXTsgLy8gVlswXSA9IEJbaV1cbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGF3YWl0IGFzeW5jTG9vcChOIC0gMSwgYXN5bmNUaWNrLCAoKSA9PiB7XG4gICAgICAgICAgICBCbG9ja01peChWLCBwb3MsIFYsIChwb3MgKz0gYmxvY2tTaXplMzIpLCByKTsgLy8gVltpXSA9IEJsb2NrTWl4KFZbaS0xXSk7XG4gICAgICAgICAgICBibG9ja01peENiKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBCbG9ja01peChWLCAoTiAtIDEpICogYmxvY2tTaXplMzIsIEIzMiwgUGksIHIpOyAvLyBQcm9jZXNzIGxhc3QgZWxlbWVudFxuICAgICAgICBibG9ja01peENiKCk7XG4gICAgICAgIGF3YWl0IGFzeW5jTG9vcChOLCBhc3luY1RpY2ssICgpID0+IHtcbiAgICAgICAgICAgIC8vIEZpcnN0IHUzMiBvZiB0aGUgbGFzdCA2NC1ieXRlIGJsb2NrICh1MzIgaXMgTEUpXG4gICAgICAgICAgICAvLyAmIChOIC0gMSkgaXMgJSBOIGFzIE4gaXMgYSBwb3dlciBvZiAyLCBOICYgKE4gLSAxKSA9IDAgaXMgY2hlY2tlZCBhYm92ZTsgPj4+IDAgZm9yIHVuc2lnbmVkLCBpbnB1dCBmaXRzIGluIHUzMlxuICAgICAgICAgICAgY29uc3QgaiA9IChCMzJbUGkgKyBibG9ja1NpemUzMiAtIDE2XSAmIChOIC0gMSkpID4+PiAwOyAvLyBqID0gSW50ZWdyaWZ5KFgpICUgaXRlcmF0aW9uc1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBibG9ja1NpemUzMjsgaysrKVxuICAgICAgICAgICAgICAgIHRtcFtrXSA9IEIzMltQaSArIGtdIF4gVltqICogYmxvY2tTaXplMzIgKyBrXTsgLy8gdG1wID0gQiBeIFZbal1cbiAgICAgICAgICAgIEJsb2NrTWl4KHRtcCwgMCwgQjMyLCBQaSwgcik7IC8vIEIgPSBCbG9ja01peChCIF4gVltqXSlcbiAgICAgICAgICAgIGJsb2NrTWl4Q2IoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN3YXAzMklmQkUoQjMyKTtcbiAgICByZXR1cm4gc2NyeXB0T3V0cHV0KHBhc3N3b3JkLCBka0xlbiwgQiwgViwgdG1wKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcnlwdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/hashes/scrypt.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/hashes/sha2.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/sha2.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _SHA224: () => (/* binding */ _SHA224),\n/* harmony export */   _SHA256: () => (/* binding */ _SHA256),\n/* harmony export */   _SHA384: () => (/* binding */ _SHA384),\n/* harmony export */   _SHA512: () => (/* binding */ _SHA512),\n/* harmony export */   _SHA512_224: () => (/* binding */ _SHA512_224),\n/* harmony export */   _SHA512_256: () => (/* binding */ _SHA512_256),\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   sha384: () => (/* binding */ sha384),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   sha512_224: () => (/* binding */ sha512_224),\n/* harmony export */   sha512_256: () => (/* binding */ sha512_256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"(rsc)/./node_modules/@noble/hashes/_md.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_u64.js */ \"(rsc)/./node_modules/@noble/hashes/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@noble/hashes/utils.js\");\n/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://www.rfc-editor.org/rfc/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\n\n\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\n/** Internal 32-byte base SHA2 hash class. */\nclass SHA2_32B extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(outputLen) {\n        super(64, outputLen, 8, false);\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n    }\n}\n/** Internal SHA2-256 hash class. */\nclass _SHA256 extends SHA2_32B {\n    // We cannot use array here since array allows indexing by variable\n    // which means optimizer/compiler cannot use registers.\n    A = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[0] | 0;\n    B = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[1] | 0;\n    C = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[2] | 0;\n    D = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[3] | 0;\n    E = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[4] | 0;\n    F = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[5] | 0;\n    G = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[6] | 0;\n    H = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[7] | 0;\n    constructor() {\n        super(32);\n    }\n}\n/** Internal SHA2-224 hash class. */\nclass _SHA224 extends SHA2_32B {\n    A = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[0] | 0;\n    B = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[1] | 0;\n    C = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[2] | 0;\n    D = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[3] | 0;\n    E = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[4] | 0;\n    F = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[5] | 0;\n    G = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[6] | 0;\n    H = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[7] | 0;\n    constructor() {\n        super(28);\n    }\n}\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => _u64_js__WEBPACK_IMPORTED_MODULE_2__.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n/** Internal 64-byte base SHA2 hash class. */\nclass SHA2_64B extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(outputLen) {\n        super(128, outputLen, 16, false);\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\n/** Internal SHA2-512 hash class. */\nclass _SHA512 extends SHA2_64B {\n    Ah = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[0] | 0;\n    Al = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[1] | 0;\n    Bh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[2] | 0;\n    Bl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[3] | 0;\n    Ch = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[4] | 0;\n    Cl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[5] | 0;\n    Dh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[6] | 0;\n    Dl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[7] | 0;\n    Eh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[8] | 0;\n    El = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[9] | 0;\n    Fh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[10] | 0;\n    Fl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[11] | 0;\n    Gh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[12] | 0;\n    Gl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[13] | 0;\n    Hh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[14] | 0;\n    Hl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[15] | 0;\n    constructor() {\n        super(64);\n    }\n}\n/** Internal SHA2-384 hash class. */\nclass _SHA384 extends SHA2_64B {\n    Ah = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[0] | 0;\n    Al = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[1] | 0;\n    Bh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[2] | 0;\n    Bl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[3] | 0;\n    Ch = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[4] | 0;\n    Cl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[5] | 0;\n    Dh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[6] | 0;\n    Dl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[7] | 0;\n    Eh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[8] | 0;\n    El = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[9] | 0;\n    Fh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[10] | 0;\n    Fl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[11] | 0;\n    Gh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[12] | 0;\n    Gl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[13] | 0;\n    Hh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[14] | 0;\n    Hl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[15] | 0;\n    constructor() {\n        super(48);\n    }\n}\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\n/** Internal SHA2-512/224 hash class. */\nclass _SHA512_224 extends SHA2_64B {\n    Ah = T224_IV[0] | 0;\n    Al = T224_IV[1] | 0;\n    Bh = T224_IV[2] | 0;\n    Bl = T224_IV[3] | 0;\n    Ch = T224_IV[4] | 0;\n    Cl = T224_IV[5] | 0;\n    Dh = T224_IV[6] | 0;\n    Dl = T224_IV[7] | 0;\n    Eh = T224_IV[8] | 0;\n    El = T224_IV[9] | 0;\n    Fh = T224_IV[10] | 0;\n    Fl = T224_IV[11] | 0;\n    Gh = T224_IV[12] | 0;\n    Gl = T224_IV[13] | 0;\n    Hh = T224_IV[14] | 0;\n    Hl = T224_IV[15] | 0;\n    constructor() {\n        super(28);\n    }\n}\n/** Internal SHA2-512/256 hash class. */\nclass _SHA512_256 extends SHA2_64B {\n    Ah = T256_IV[0] | 0;\n    Al = T256_IV[1] | 0;\n    Bh = T256_IV[2] | 0;\n    Bl = T256_IV[3] | 0;\n    Ch = T256_IV[4] | 0;\n    Cl = T256_IV[5] | 0;\n    Dh = T256_IV[6] | 0;\n    Dl = T256_IV[7] | 0;\n    Eh = T256_IV[8] | 0;\n    El = T256_IV[9] | 0;\n    Fh = T256_IV[10] | 0;\n    Fl = T256_IV[11] | 0;\n    Gh = T256_IV[12] | 0;\n    Gl = T256_IV[13] | 0;\n    Hh = T256_IV[14] | 0;\n    Hl = T256_IV[15] | 0;\n    constructor() {\n        super(32);\n    }\n}\n/**\n * SHA2-256 hash function from RFC 4634. In JS it's the fastest: even faster than Blake3. Some info:\n *\n * - Trying 2^128 hashes would get 50% chance of collision, using birthday attack.\n * - BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n * - Each sha256 hash is executing 2^18 bit operations.\n * - Good 2024 ASICs can do 200Th/sec with 3500 watts of power, corresponding to 2^36 hashes/joule.\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new _SHA256(), \n/* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.oidNist)(0x01));\n/** SHA2-224 hash function from RFC 4634 */\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new _SHA224(), \n/* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.oidNist)(0x04));\n/** SHA2-512 hash function from RFC 4634. */\nconst sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new _SHA512(), \n/* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.oidNist)(0x03));\n/** SHA2-384 hash function from RFC 4634. */\nconst sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new _SHA384(), \n/* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.oidNist)(0x02));\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nconst sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new _SHA512_256(), \n/* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.oidNist)(0x06));\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nconst sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new _SHA512_224(), \n/* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.oidNist)(0x05));\n//# sourceMappingURL=sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3dGO0FBQ3ZEO0FBQytCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQ0FBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUMsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkMsd0JBQXdCLFFBQVE7QUFDaEMsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRCxxQ0FBcUMsMkNBQUc7QUFDeEMsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRCxpQ0FBaUMsMkNBQUc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBSztBQUNiO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxRQUFRLDZDQUFTO0FBQ2pCLFFBQVEsNkNBQVM7QUFDakIsUUFBUSw2Q0FBUztBQUNqQixRQUFRLDZDQUFTO0FBQ2pCLFFBQVEsNkNBQVM7QUFDakIsUUFBUSw2Q0FBUztBQUNqQixRQUFRLDZDQUFTO0FBQ2pCLFFBQVEsNkNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsUUFBUSw2Q0FBUztBQUNqQixRQUFRLDZDQUFTO0FBQ2pCLFFBQVEsNkNBQVM7QUFDakIsUUFBUSw2Q0FBUztBQUNqQixRQUFRLDZDQUFTO0FBQ2pCLFFBQVEsNkNBQVM7QUFDakIsUUFBUSw2Q0FBUztBQUNqQixRQUFRLDZDQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMENBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBDQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUVBQWlFO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkNBQVUsa0JBQWtCLDJDQUFVLGtCQUFrQiwwQ0FBUztBQUN6Rix3QkFBd0IsMkNBQVUsa0JBQWtCLDJDQUFVLGtCQUFrQiwwQ0FBUztBQUN6RjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkNBQVUsaUJBQWlCLDJDQUFVLGlCQUFpQiwwQ0FBUztBQUN2Rix3QkFBd0IsMkNBQVUsaUJBQWlCLDJDQUFVLGlCQUFpQiwwQ0FBUztBQUN2RjtBQUNBLHlCQUF5QiwwQ0FBUztBQUNsQyx5QkFBeUIsMENBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpRUFBaUU7QUFDL0U7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLDRCQUE0QiwyQ0FBVSxlQUFlLDJDQUFVLGVBQWUsMkNBQVU7QUFDeEYsNEJBQTRCLDJDQUFVLGVBQWUsMkNBQVUsZUFBZSwyQ0FBVTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBDQUFTO0FBQ2xDLHdCQUF3QiwwQ0FBUztBQUNqQztBQUNBO0FBQ0EsNEJBQTRCLDJDQUFVLGVBQWUsMkNBQVUsZUFBZSwyQ0FBVTtBQUN4Riw0QkFBNEIsMkNBQVUsZUFBZSwyQ0FBVSxlQUFlLDJDQUFVO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWUsRUFBRSx3Q0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMENBQVM7QUFDakMsaUJBQWlCLDBDQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZSxFQUFFLHdDQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLHdDQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLHdDQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLHdDQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLHdDQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLHdDQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLHdDQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLHdDQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQUs7QUFDYjtBQUNBO0FBQ0EsUUFBUSxnREFBSztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxTQUFTLDZDQUFTO0FBQ2xCLFNBQVMsNkNBQVM7QUFDbEIsU0FBUyw2Q0FBUztBQUNsQixTQUFTLDZDQUFTO0FBQ2xCLFNBQVMsNkNBQVM7QUFDbEIsU0FBUyw2Q0FBUztBQUNsQixTQUFTLDZDQUFTO0FBQ2xCLFNBQVMsNkNBQVM7QUFDbEIsU0FBUyw2Q0FBUztBQUNsQixTQUFTLDZDQUFTO0FBQ2xCLFNBQVMsNkNBQVM7QUFDbEIsU0FBUyw2Q0FBUztBQUNsQixTQUFTLDZDQUFTO0FBQ2xCLFNBQVMsNkNBQVM7QUFDbEIsU0FBUyw2Q0FBUztBQUNsQixTQUFTLDZDQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFNBQVMsNkNBQVM7QUFDbEIsU0FBUyw2Q0FBUztBQUNsQixTQUFTLDZDQUFTO0FBQ2xCLFNBQVMsNkNBQVM7QUFDbEIsU0FBUyw2Q0FBUztBQUNsQixTQUFTLDZDQUFTO0FBQ2xCLFNBQVMsNkNBQVM7QUFDbEIsU0FBUyw2Q0FBUztBQUNsQixTQUFTLDZDQUFTO0FBQ2xCLFNBQVMsNkNBQVM7QUFDbEIsU0FBUyw2Q0FBUztBQUNsQixTQUFTLDZDQUFTO0FBQ2xCLFNBQVMsNkNBQVM7QUFDbEIsU0FBUyw2Q0FBUztBQUNsQixTQUFTLDZDQUFTO0FBQ2xCLFNBQVMsNkNBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLHVEQUFZO0FBQ2xELGdCQUFnQixrREFBTztBQUN2QjtBQUNPLCtCQUErQix1REFBWTtBQUNsRCxnQkFBZ0Isa0RBQU87QUFDdkI7QUFDTywrQkFBK0IsdURBQVk7QUFDbEQsZ0JBQWdCLGtEQUFPO0FBQ3ZCO0FBQ08sK0JBQStCLHVEQUFZO0FBQ2xELGdCQUFnQixrREFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQyx1REFBWTtBQUN0RCxnQkFBZ0Isa0RBQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQ0FBbUMsdURBQVk7QUFDdEQsZ0JBQWdCLGtEQUFPO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXV0b3BsYW5jYW0vLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEyLmpzPzNiODIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTSEEyIGhhc2ggZnVuY3Rpb24uIEEuay5hLiBzaGEyNTYsIHNoYTM4NCwgc2hhNTEyLCBzaGE1MTJfMjI0LCBzaGE1MTJfMjU2LlxuICogU0hBMjU2IGlzIHRoZSBmYXN0ZXN0IGhhc2ggaW1wbGVtZW50YWJsZSBpbiBKUywgZXZlbiBmYXN0ZXIgdGhhbiBCbGFrZTMuXG4gKiBDaGVjayBvdXQgW1JGQyA0NjM0XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNDYzNCkgYW5kXG4gKiBbRklQUyAxODAtNF0oaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZikuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IENoaSwgSGFzaE1ELCBNYWosIFNIQTIyNF9JViwgU0hBMjU2X0lWLCBTSEEzODRfSVYsIFNIQTUxMl9JViB9IGZyb20gXCIuL19tZC5qc1wiO1xuaW1wb3J0ICogYXMgdTY0IGZyb20gXCIuL191NjQuanNcIjtcbmltcG9ydCB7IGNsZWFuLCBjcmVhdGVIYXNoZXIsIG9pZE5pc3QsIHJvdHIgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLyoqXG4gKiBSb3VuZCBjb25zdGFudHM6XG4gKiBGaXJzdCAzMiBiaXRzIG9mIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4gKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8qKiBSZXVzYWJsZSB0ZW1wb3JhcnkgYnVmZmVyLiBcIldcIiBjb21lcyBzdHJhaWdodCBmcm9tIHNwZWMuICovXG5jb25zdCBTSEEyNTZfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoNjQpO1xuLyoqIEludGVybmFsIDMyLWJ5dGUgYmFzZSBTSEEyIGhhc2ggY2xhc3MuICovXG5jbGFzcyBTSEEyXzMyQiBleHRlbmRzIEhhc2hNRCB7XG4gICAgY29uc3RydWN0b3Iob3V0cHV0TGVuKSB7XG4gICAgICAgIHN1cGVyKDY0LCBvdXRwdXRMZW4sIDgsIGZhbHNlKTtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBjbGVhbihTSEEyNTZfVyk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlcik7XG4gICAgfVxufVxuLyoqIEludGVybmFsIFNIQTItMjU2IGhhc2ggY2xhc3MuICovXG5leHBvcnQgY2xhc3MgX1NIQTI1NiBleHRlbmRzIFNIQTJfMzJCIHtcbiAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgIEEgPSBTSEEyNTZfSVZbMF0gfCAwO1xuICAgIEIgPSBTSEEyNTZfSVZbMV0gfCAwO1xuICAgIEMgPSBTSEEyNTZfSVZbMl0gfCAwO1xuICAgIEQgPSBTSEEyNTZfSVZbM10gfCAwO1xuICAgIEUgPSBTSEEyNTZfSVZbNF0gfCAwO1xuICAgIEYgPSBTSEEyNTZfSVZbNV0gfCAwO1xuICAgIEcgPSBTSEEyNTZfSVZbNl0gfCAwO1xuICAgIEggPSBTSEEyNTZfSVZbN10gfCAwO1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigzMik7XG4gICAgfVxufVxuLyoqIEludGVybmFsIFNIQTItMjI0IGhhc2ggY2xhc3MuICovXG5leHBvcnQgY2xhc3MgX1NIQTIyNCBleHRlbmRzIFNIQTJfMzJCIHtcbiAgICBBID0gU0hBMjI0X0lWWzBdIHwgMDtcbiAgICBCID0gU0hBMjI0X0lWWzFdIHwgMDtcbiAgICBDID0gU0hBMjI0X0lWWzJdIHwgMDtcbiAgICBEID0gU0hBMjI0X0lWWzNdIHwgMDtcbiAgICBFID0gU0hBMjI0X0lWWzRdIHwgMDtcbiAgICBGID0gU0hBMjI0X0lWWzVdIHwgMDtcbiAgICBHID0gU0hBMjI0X0lWWzZdIHwgMDtcbiAgICBIID0gU0hBMjI0X0lWWzddIHwgMDtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMjgpO1xuICAgIH1cbn1cbi8vIFNIQTItNTEyIGlzIHNsb3dlciB0aGFuIHNoYTI1NiBpbiBqcyBiZWNhdXNlIHU2NCBvcGVyYXRpb25zIGFyZSBzbG93LlxuLy8gUm91bmQgY29udGFudHNcbi8vIEZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDgwIHByaW1lcyAyLi40MDlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgSzUxMiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdTY0LnNwbGl0KFtcbiAgICAnMHg0MjhhMmY5OGQ3MjhhZTIyJywgJzB4NzEzNzQ0OTEyM2VmNjVjZCcsICcweGI1YzBmYmNmZWM0ZDNiMmYnLCAnMHhlOWI1ZGJhNTgxODlkYmJjJyxcbiAgICAnMHgzOTU2YzI1YmYzNDhiNTM4JywgJzB4NTlmMTExZjFiNjA1ZDAxOScsICcweDkyM2Y4MmE0YWYxOTRmOWInLCAnMHhhYjFjNWVkNWRhNmQ4MTE4JyxcbiAgICAnMHhkODA3YWE5OGEzMDMwMjQyJywgJzB4MTI4MzViMDE0NTcwNmZiZScsICcweDI0MzE4NWJlNGVlNGIyOGMnLCAnMHg1NTBjN2RjM2Q1ZmZiNGUyJyxcbiAgICAnMHg3MmJlNWQ3NGYyN2I4OTZmJywgJzB4ODBkZWIxZmUzYjE2OTZiMScsICcweDliZGMwNmE3MjVjNzEyMzUnLCAnMHhjMTliZjE3NGNmNjkyNjk0JyxcbiAgICAnMHhlNDliNjljMTllZjE0YWQyJywgJzB4ZWZiZTQ3ODYzODRmMjVlMycsICcweDBmYzE5ZGM2OGI4Y2Q1YjUnLCAnMHgyNDBjYTFjYzc3YWM5YzY1JyxcbiAgICAnMHgyZGU5MmM2ZjU5MmIwMjc1JywgJzB4NGE3NDg0YWE2ZWE2ZTQ4MycsICcweDVjYjBhOWRjYmQ0MWZiZDQnLCAnMHg3NmY5ODhkYTgzMTE1M2I1JyxcbiAgICAnMHg5ODNlNTE1MmVlNjZkZmFiJywgJzB4YTgzMWM2NmQyZGI0MzIxMCcsICcweGIwMDMyN2M4OThmYjIxM2YnLCAnMHhiZjU5N2ZjN2JlZWYwZWU0JyxcbiAgICAnMHhjNmUwMGJmMzNkYTg4ZmMyJywgJzB4ZDVhNzkxNDc5MzBhYTcyNScsICcweDA2Y2E2MzUxZTAwMzgyNmYnLCAnMHgxNDI5Mjk2NzBhMGU2ZTcwJyxcbiAgICAnMHgyN2I3MGE4NTQ2ZDIyZmZjJywgJzB4MmUxYjIxMzg1YzI2YzkyNicsICcweDRkMmM2ZGZjNWFjNDJhZWQnLCAnMHg1MzM4MGQxMzlkOTViM2RmJyxcbiAgICAnMHg2NTBhNzM1NDhiYWY2M2RlJywgJzB4NzY2YTBhYmIzYzc3YjJhOCcsICcweDgxYzJjOTJlNDdlZGFlZTYnLCAnMHg5MjcyMmM4NTE0ODIzNTNiJyxcbiAgICAnMHhhMmJmZThhMTRjZjEwMzY0JywgJzB4YTgxYTY2NGJiYzQyMzAwMScsICcweGMyNGI4YjcwZDBmODk3OTEnLCAnMHhjNzZjNTFhMzA2NTRiZTMwJyxcbiAgICAnMHhkMTkyZTgxOWQ2ZWY1MjE4JywgJzB4ZDY5OTA2MjQ1NTY1YTkxMCcsICcweGY0MGUzNTg1NTc3MTIwMmEnLCAnMHgxMDZhYTA3MDMyYmJkMWI4JyxcbiAgICAnMHgxOWE0YzExNmI4ZDJkMGM4JywgJzB4MWUzNzZjMDg1MTQxYWI1MycsICcweDI3NDg3NzRjZGY4ZWViOTknLCAnMHgzNGIwYmNiNWUxOWI0OGE4JyxcbiAgICAnMHgzOTFjMGNiM2M1Yzk1YTYzJywgJzB4NGVkOGFhNGFlMzQxOGFjYicsICcweDViOWNjYTRmNzc2M2UzNzMnLCAnMHg2ODJlNmZmM2Q2YjJiOGEzJyxcbiAgICAnMHg3NDhmODJlZTVkZWZiMmZjJywgJzB4NzhhNTYzNmY0MzE3MmY2MCcsICcweDg0Yzg3ODE0YTFmMGFiNzInLCAnMHg4Y2M3MDIwODFhNjQzOWVjJyxcbiAgICAnMHg5MGJlZmZmYTIzNjMxZTI4JywgJzB4YTQ1MDZjZWJkZTgyYmRlOScsICcweGJlZjlhM2Y3YjJjNjc5MTUnLCAnMHhjNjcxNzhmMmUzNzI1MzJiJyxcbiAgICAnMHhjYTI3M2VjZWVhMjY2MTljJywgJzB4ZDE4NmI4YzcyMWMwYzIwNycsICcweGVhZGE3ZGQ2Y2RlMGViMWUnLCAnMHhmNTdkNGY3ZmVlNmVkMTc4JyxcbiAgICAnMHgwNmYwNjdhYTcyMTc2ZmJhJywgJzB4MGE2MzdkYzVhMmM4OThhNicsICcweDExM2Y5ODA0YmVmOTBkYWUnLCAnMHgxYjcxMGIzNTEzMWM0NzFiJyxcbiAgICAnMHgyOGRiNzdmNTIzMDQ3ZDg0JywgJzB4MzJjYWFiN2I0MGM3MjQ5MycsICcweDNjOWViZTBhMTVjOWJlYmMnLCAnMHg0MzFkNjdjNDljMTAwZDRjJyxcbiAgICAnMHg0Y2M1ZDRiZWNiM2U0MmI2JywgJzB4NTk3ZjI5OWNmYzY1N2UyYScsICcweDVmY2I2ZmFiM2FkNmZhZWMnLCAnMHg2YzQ0MTk4YzRhNDc1ODE3J1xuXS5tYXAobiA9PiBCaWdJbnQobikpKSkoKTtcbmNvbnN0IFNIQTUxMl9LaCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gSzUxMlswXSkoKTtcbmNvbnN0IFNIQTUxMl9LbCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gSzUxMlsxXSkoKTtcbi8vIFJldXNhYmxlIHRlbXBvcmFyeSBidWZmZXJzXG5jb25zdCBTSEE1MTJfV19IID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg4MCk7XG5jb25zdCBTSEE1MTJfV19MID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg4MCk7XG4vKiogSW50ZXJuYWwgNjQtYnl0ZSBiYXNlIFNIQTIgaGFzaCBjbGFzcy4gKi9cbmNsYXNzIFNIQTJfNjRCIGV4dGVuZHMgSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcihvdXRwdXRMZW4pIHtcbiAgICAgICAgc3VwZXIoMTI4LCBvdXRwdXRMZW4sIDE2LCBmYWxzZSk7XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCkge1xuICAgICAgICB0aGlzLkFoID0gQWggfCAwO1xuICAgICAgICB0aGlzLkFsID0gQWwgfCAwO1xuICAgICAgICB0aGlzLkJoID0gQmggfCAwO1xuICAgICAgICB0aGlzLkJsID0gQmwgfCAwO1xuICAgICAgICB0aGlzLkNoID0gQ2ggfCAwO1xuICAgICAgICB0aGlzLkNsID0gQ2wgfCAwO1xuICAgICAgICB0aGlzLkRoID0gRGggfCAwO1xuICAgICAgICB0aGlzLkRsID0gRGwgfCAwO1xuICAgICAgICB0aGlzLkVoID0gRWggfCAwO1xuICAgICAgICB0aGlzLkVsID0gRWwgfCAwO1xuICAgICAgICB0aGlzLkZoID0gRmggfCAwO1xuICAgICAgICB0aGlzLkZsID0gRmwgfCAwO1xuICAgICAgICB0aGlzLkdoID0gR2ggfCAwO1xuICAgICAgICB0aGlzLkdsID0gR2wgfCAwO1xuICAgICAgICB0aGlzLkhoID0gSGggfCAwO1xuICAgICAgICB0aGlzLkhsID0gSGwgfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA2NCB3b3JkcyB3WzE2Li43OV0gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNCkge1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gdmlldy5nZXRVaW50MzIoKG9mZnNldCArPSA0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gczAgOj0gKHdbaS0xNV0gcmlnaHRyb3RhdGUgMSkgeG9yICh3W2ktMTVdIHJpZ2h0cm90YXRlIDgpIHhvciAod1tpLTE1XSByaWdodHNoaWZ0IDcpXG4gICAgICAgICAgICBjb25zdCBXMTVoID0gU0hBNTEyX1dfSFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcxNWwgPSBTSEE1MTJfV19MW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczBoID0gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0goVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICBjb25zdCBzMGwgPSB1NjQucm90clNMKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTTChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIC8vIHMxIDo9ICh3W2ktMl0gcmlnaHRyb3RhdGUgMTkpIHhvciAod1tpLTJdIHJpZ2h0cm90YXRlIDYxKSB4b3IgKHdbaS0yXSByaWdodHNoaWZ0IDYpXG4gICAgICAgICAgICBjb25zdCBXMmggPSBTSEE1MTJfV19IW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMmwgPSBTSEE1MTJfV19MW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMWggPSB1NjQucm90clNIKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJIKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0goVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgY29uc3QgczFsID0gdTY0LnJvdHJTTChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCTChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNMKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIC8vIFNIQTI1Nl9XW2ldID0gczAgKyBzMSArIFNIQTI1Nl9XW2kgLSA3XSArIFNIQTI1Nl9XW2kgLSAxNl07XG4gICAgICAgICAgICBjb25zdCBTVU1sID0gdTY0LmFkZDRMKHMwbCwgczFsLCBTSEE1MTJfV19MW2kgLSA3XSwgU0hBNTEyX1dfTFtpIC0gMTZdKTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWggPSB1NjQuYWRkNEgoU1VNbCwgczBoLCBzMWgsIFNIQTUxMl9XX0hbaSAtIDddLCBTSEE1MTJfV19IW2kgLSAxNl0pO1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IFNVTWggfCAwO1xuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IFNVTWwgfCAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDgwIHJvdW5kc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFMxIDo9IChlIHJpZ2h0cm90YXRlIDE0KSB4b3IgKGUgcmlnaHRyb3RhdGUgMTgpIHhvciAoZSByaWdodHJvdGF0ZSA0MSlcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWggPSB1NjQucm90clNIKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTSChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkgoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTFsID0gdTY0LnJvdHJTTChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0woRWgsIEVsLCAxOCkgXiB1NjQucm90ckJMKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgLy9jb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3QgQ0hJaCA9IChFaCAmIEZoKSBeICh+RWggJiBHaCk7XG4gICAgICAgICAgICBjb25zdCBDSElsID0gKEVsICYgRmwpIF4gKH5FbCAmIEdsKTtcbiAgICAgICAgICAgIC8vIFQxID0gSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTUxMl9LW2ldICsgU0hBNTEyX1dbaV1cbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgVDFsbCA9IHU2NC5hZGQ1TChIbCwgc2lnbWExbCwgQ0hJbCwgU0hBNTEyX0tsW2ldLCBTSEE1MTJfV19MW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxaCA9IHU2NC5hZGQ1SChUMWxsLCBIaCwgc2lnbWExaCwgQ0hJaCwgU0hBNTEyX0toW2ldLCBTSEE1MTJfV19IW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxbCA9IFQxbGwgfCAwO1xuICAgICAgICAgICAgLy8gUzAgOj0gKGEgcmlnaHRyb3RhdGUgMjgpIHhvciAoYSByaWdodHJvdGF0ZSAzNCkgeG9yIChhIHJpZ2h0cm90YXRlIDM5KVxuICAgICAgICAgICAgY29uc3Qgc2lnbWEwaCA9IHU2NC5yb3RyU0goQWgsIEFsLCAyOCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCSChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGwgPSB1NjQucm90clNMKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzOSk7XG4gICAgICAgICAgICBjb25zdCBNQUpoID0gKEFoICYgQmgpIF4gKEFoICYgQ2gpIF4gKEJoICYgQ2gpO1xuICAgICAgICAgICAgY29uc3QgTUFKbCA9IChBbCAmIEJsKSBeIChBbCAmIENsKSBeIChCbCAmIENsKTtcbiAgICAgICAgICAgIEhoID0gR2ggfCAwO1xuICAgICAgICAgICAgSGwgPSBHbCB8IDA7XG4gICAgICAgICAgICBHaCA9IEZoIHwgMDtcbiAgICAgICAgICAgIEdsID0gRmwgfCAwO1xuICAgICAgICAgICAgRmggPSBFaCB8IDA7XG4gICAgICAgICAgICBGbCA9IEVsIHwgMDtcbiAgICAgICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZChEaCB8IDAsIERsIHwgMCwgVDFoIHwgMCwgVDFsIHwgMCkpO1xuICAgICAgICAgICAgRGggPSBDaCB8IDA7XG4gICAgICAgICAgICBEbCA9IENsIHwgMDtcbiAgICAgICAgICAgIENoID0gQmggfCAwO1xuICAgICAgICAgICAgQ2wgPSBCbCB8IDA7XG4gICAgICAgICAgICBCaCA9IEFoIHwgMDtcbiAgICAgICAgICAgIEJsID0gQWwgfCAwO1xuICAgICAgICAgICAgY29uc3QgQWxsID0gdTY0LmFkZDNMKFQxbCwgc2lnbWEwbCwgTUFKbCk7XG4gICAgICAgICAgICBBaCA9IHU2NC5hZGQzSChBbGwsIFQxaCwgc2lnbWEwaCwgTUFKaCk7XG4gICAgICAgICAgICBBbCA9IEFsbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgKHsgaDogQWgsIGw6IEFsIH0gPSB1NjQuYWRkKHRoaXMuQWggfCAwLCB0aGlzLkFsIHwgMCwgQWggfCAwLCBBbCB8IDApKTtcbiAgICAgICAgKHsgaDogQmgsIGw6IEJsIH0gPSB1NjQuYWRkKHRoaXMuQmggfCAwLCB0aGlzLkJsIHwgMCwgQmggfCAwLCBCbCB8IDApKTtcbiAgICAgICAgKHsgaDogQ2gsIGw6IENsIH0gPSB1NjQuYWRkKHRoaXMuQ2ggfCAwLCB0aGlzLkNsIHwgMCwgQ2ggfCAwLCBDbCB8IDApKTtcbiAgICAgICAgKHsgaDogRGgsIGw6IERsIH0gPSB1NjQuYWRkKHRoaXMuRGggfCAwLCB0aGlzLkRsIHwgMCwgRGggfCAwLCBEbCB8IDApKTtcbiAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKHRoaXMuRWggfCAwLCB0aGlzLkVsIHwgMCwgRWggfCAwLCBFbCB8IDApKTtcbiAgICAgICAgKHsgaDogRmgsIGw6IEZsIH0gPSB1NjQuYWRkKHRoaXMuRmggfCAwLCB0aGlzLkZsIHwgMCwgRmggfCAwLCBGbCB8IDApKTtcbiAgICAgICAgKHsgaDogR2gsIGw6IEdsIH0gPSB1NjQuYWRkKHRoaXMuR2ggfCAwLCB0aGlzLkdsIHwgMCwgR2ggfCAwLCBHbCB8IDApKTtcbiAgICAgICAgKHsgaDogSGgsIGw6IEhsIH0gPSB1NjQuYWRkKHRoaXMuSGggfCAwLCB0aGlzLkhsIHwgMCwgSGggfCAwLCBIbCB8IDApKTtcbiAgICAgICAgdGhpcy5zZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBjbGVhbihTSEE1MTJfV19ILCBTSEE1MTJfV19MKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYW4odGhpcy5idWZmZXIpO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG4vKiogSW50ZXJuYWwgU0hBMi01MTIgaGFzaCBjbGFzcy4gKi9cbmV4cG9ydCBjbGFzcyBfU0hBNTEyIGV4dGVuZHMgU0hBMl82NEIge1xuICAgIEFoID0gU0hBNTEyX0lWWzBdIHwgMDtcbiAgICBBbCA9IFNIQTUxMl9JVlsxXSB8IDA7XG4gICAgQmggPSBTSEE1MTJfSVZbMl0gfCAwO1xuICAgIEJsID0gU0hBNTEyX0lWWzNdIHwgMDtcbiAgICBDaCA9IFNIQTUxMl9JVls0XSB8IDA7XG4gICAgQ2wgPSBTSEE1MTJfSVZbNV0gfCAwO1xuICAgIERoID0gU0hBNTEyX0lWWzZdIHwgMDtcbiAgICBEbCA9IFNIQTUxMl9JVls3XSB8IDA7XG4gICAgRWggPSBTSEE1MTJfSVZbOF0gfCAwO1xuICAgIEVsID0gU0hBNTEyX0lWWzldIHwgMDtcbiAgICBGaCA9IFNIQTUxMl9JVlsxMF0gfCAwO1xuICAgIEZsID0gU0hBNTEyX0lWWzExXSB8IDA7XG4gICAgR2ggPSBTSEE1MTJfSVZbMTJdIHwgMDtcbiAgICBHbCA9IFNIQTUxMl9JVlsxM10gfCAwO1xuICAgIEhoID0gU0hBNTEyX0lWWzE0XSB8IDA7XG4gICAgSGwgPSBTSEE1MTJfSVZbMTVdIHwgMDtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQpO1xuICAgIH1cbn1cbi8qKiBJbnRlcm5hbCBTSEEyLTM4NCBoYXNoIGNsYXNzLiAqL1xuZXhwb3J0IGNsYXNzIF9TSEEzODQgZXh0ZW5kcyBTSEEyXzY0QiB7XG4gICAgQWggPSBTSEEzODRfSVZbMF0gfCAwO1xuICAgIEFsID0gU0hBMzg0X0lWWzFdIHwgMDtcbiAgICBCaCA9IFNIQTM4NF9JVlsyXSB8IDA7XG4gICAgQmwgPSBTSEEzODRfSVZbM10gfCAwO1xuICAgIENoID0gU0hBMzg0X0lWWzRdIHwgMDtcbiAgICBDbCA9IFNIQTM4NF9JVls1XSB8IDA7XG4gICAgRGggPSBTSEEzODRfSVZbNl0gfCAwO1xuICAgIERsID0gU0hBMzg0X0lWWzddIHwgMDtcbiAgICBFaCA9IFNIQTM4NF9JVls4XSB8IDA7XG4gICAgRWwgPSBTSEEzODRfSVZbOV0gfCAwO1xuICAgIEZoID0gU0hBMzg0X0lWWzEwXSB8IDA7XG4gICAgRmwgPSBTSEEzODRfSVZbMTFdIHwgMDtcbiAgICBHaCA9IFNIQTM4NF9JVlsxMl0gfCAwO1xuICAgIEdsID0gU0hBMzg0X0lWWzEzXSB8IDA7XG4gICAgSGggPSBTSEEzODRfSVZbMTRdIHwgMDtcbiAgICBIbCA9IFNIQTM4NF9JVlsxNV0gfCAwO1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig0OCk7XG4gICAgfVxufVxuLyoqXG4gKiBUcnVuY2F0ZWQgU0hBNTEyLzI1NiBhbmQgU0hBNTEyLzIyNC5cbiAqIFNIQTUxMl9JViBpcyBYT1JlZCB3aXRoIDB4YTVhNWE1YTVhNWE1YTVhNSwgdGhlbiB1c2VkIGFzIFwiaW50ZXJtZWRpYXJ5XCIgSVYgb2YgU0hBNTEyL3QuXG4gKiBUaGVuIHQgaGFzaGVzIHN0cmluZyB0byBwcm9kdWNlIHJlc3VsdCBJVi5cbiAqIFNlZSBgdGVzdC9taXNjL3NoYTItZ2VuLWl2LmpzYC5cbiAqL1xuLyoqIFNIQTUxMi8yMjQgSVYgKi9cbmNvbnN0IFQyMjRfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg4YzNkMzdjOCwgMHgxOTU0NGRhMiwgMHg3M2UxOTk2NiwgMHg4OWRjZDRkNiwgMHgxZGZhYjdhZSwgMHgzMmZmOWM4MiwgMHg2NzlkZDUxNCwgMHg1ODJmOWZjZixcbiAgICAweDBmNmQyYjY5LCAweDdiZDQ0ZGE4LCAweDc3ZTM2ZjczLCAweDA0YzQ4OTQyLCAweDNmOWQ4NWE4LCAweDZhMWQzNmM4LCAweDExMTJlNmFkLCAweDkxZDY5MmExLFxuXSk7XG4vKiogU0hBNTEyLzI1NiBJViAqL1xuY29uc3QgVDI1Nl9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweDIyMzEyMTk0LCAweGZjMmJmNzJjLCAweDlmNTU1ZmEzLCAweGM4NGM2NGMyLCAweDIzOTNiODZiLCAweDZmNTNiMTUxLCAweDk2Mzg3NzE5LCAweDU5NDBlYWJkLFxuICAgIDB4OTYyODNlZTIsIDB4YTg4ZWZmZTMsIDB4YmU1ZTFlMjUsIDB4NTM4NjM5OTIsIDB4MmIwMTk5ZmMsIDB4MmM4NWI4YWEsIDB4MGViNzJkZGMsIDB4ODFjNTJjYTIsXG5dKTtcbi8qKiBJbnRlcm5hbCBTSEEyLTUxMi8yMjQgaGFzaCBjbGFzcy4gKi9cbmV4cG9ydCBjbGFzcyBfU0hBNTEyXzIyNCBleHRlbmRzIFNIQTJfNjRCIHtcbiAgICBBaCA9IFQyMjRfSVZbMF0gfCAwO1xuICAgIEFsID0gVDIyNF9JVlsxXSB8IDA7XG4gICAgQmggPSBUMjI0X0lWWzJdIHwgMDtcbiAgICBCbCA9IFQyMjRfSVZbM10gfCAwO1xuICAgIENoID0gVDIyNF9JVls0XSB8IDA7XG4gICAgQ2wgPSBUMjI0X0lWWzVdIHwgMDtcbiAgICBEaCA9IFQyMjRfSVZbNl0gfCAwO1xuICAgIERsID0gVDIyNF9JVls3XSB8IDA7XG4gICAgRWggPSBUMjI0X0lWWzhdIHwgMDtcbiAgICBFbCA9IFQyMjRfSVZbOV0gfCAwO1xuICAgIEZoID0gVDIyNF9JVlsxMF0gfCAwO1xuICAgIEZsID0gVDIyNF9JVlsxMV0gfCAwO1xuICAgIEdoID0gVDIyNF9JVlsxMl0gfCAwO1xuICAgIEdsID0gVDIyNF9JVlsxM10gfCAwO1xuICAgIEhoID0gVDIyNF9JVlsxNF0gfCAwO1xuICAgIEhsID0gVDIyNF9JVlsxNV0gfCAwO1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigyOCk7XG4gICAgfVxufVxuLyoqIEludGVybmFsIFNIQTItNTEyLzI1NiBoYXNoIGNsYXNzLiAqL1xuZXhwb3J0IGNsYXNzIF9TSEE1MTJfMjU2IGV4dGVuZHMgU0hBMl82NEIge1xuICAgIEFoID0gVDI1Nl9JVlswXSB8IDA7XG4gICAgQWwgPSBUMjU2X0lWWzFdIHwgMDtcbiAgICBCaCA9IFQyNTZfSVZbMl0gfCAwO1xuICAgIEJsID0gVDI1Nl9JVlszXSB8IDA7XG4gICAgQ2ggPSBUMjU2X0lWWzRdIHwgMDtcbiAgICBDbCA9IFQyNTZfSVZbNV0gfCAwO1xuICAgIERoID0gVDI1Nl9JVls2XSB8IDA7XG4gICAgRGwgPSBUMjU2X0lWWzddIHwgMDtcbiAgICBFaCA9IFQyNTZfSVZbOF0gfCAwO1xuICAgIEVsID0gVDI1Nl9JVls5XSB8IDA7XG4gICAgRmggPSBUMjU2X0lWWzEwXSB8IDA7XG4gICAgRmwgPSBUMjU2X0lWWzExXSB8IDA7XG4gICAgR2ggPSBUMjU2X0lWWzEyXSB8IDA7XG4gICAgR2wgPSBUMjU2X0lWWzEzXSB8IDA7XG4gICAgSGggPSBUMjU2X0lWWzE0XSB8IDA7XG4gICAgSGwgPSBUMjU2X0lWWzE1XSB8IDA7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDMyKTtcbiAgICB9XG59XG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb24gZnJvbSBSRkMgNDYzNC4gSW4gSlMgaXQncyB0aGUgZmFzdGVzdDogZXZlbiBmYXN0ZXIgdGhhbiBCbGFrZTMuIFNvbWUgaW5mbzpcbiAqXG4gKiAtIFRyeWluZyAyXjEyOCBoYXNoZXMgd291bGQgZ2V0IDUwJSBjaGFuY2Ugb2YgY29sbGlzaW9uLCB1c2luZyBiaXJ0aGRheSBhdHRhY2suXG4gKiAtIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNzAgaGFzaGVzL3NlYyAoMl45NSBoYXNoZXMveWVhcikgYXMgcGVyIDIwMjUuXG4gKiAtIEVhY2ggc2hhMjU2IGhhc2ggaXMgZXhlY3V0aW5nIDJeMTggYml0IG9wZXJhdGlvbnMuXG4gKiAtIEdvb2QgMjAyNCBBU0lDcyBjYW4gZG8gMjAwVGgvc2VjIHdpdGggMzUwMCB3YXR0cyBvZiBwb3dlciwgY29ycmVzcG9uZGluZyB0byAyXjM2IGhhc2hlcy9qb3VsZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoKCkgPT4gbmV3IF9TSEEyNTYoKSwgXG4vKiBAX19QVVJFX18gKi8gb2lkTmlzdCgweDAxKSk7XG4vKiogU0hBMi0yMjQgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0ICovXG5leHBvcnQgY29uc3Qgc2hhMjI0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgX1NIQTIyNCgpLCBcbi8qIEBfX1BVUkVfXyAqLyBvaWROaXN0KDB4MDQpKTtcbi8qKiBTSEEyLTUxMiBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQuICovXG5leHBvcnQgY29uc3Qgc2hhNTEyID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgX1NIQTUxMigpLCBcbi8qIEBfX1BVUkVfXyAqLyBvaWROaXN0KDB4MDMpKTtcbi8qKiBTSEEyLTM4NCBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQuICovXG5leHBvcnQgY29uc3Qgc2hhMzg0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgX1NIQTM4NCgpLCBcbi8qIEBfX1BVUkVfXyAqLyBvaWROaXN0KDB4MDIpKTtcbi8qKlxuICogU0hBMi01MTIvMjU2IFwidHJ1bmNhdGVkXCIgaGFzaCBmdW5jdGlvbiwgd2l0aCBpbXByb3ZlZCByZXNpc3RhbmNlIHRvIGxlbmd0aCBleHRlbnNpb24gYXR0YWNrcy5cbiAqIFNlZSB0aGUgcGFwZXIgb24gW3RydW5jYXRlZCBTSEE1MTJdKGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTAvNTQ4LnBkZikuXG4gKi9cbmV4cG9ydCBjb25zdCBzaGE1MTJfMjU2ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgX1NIQTUxMl8yNTYoKSwgXG4vKiBAX19QVVJFX18gKi8gb2lkTmlzdCgweDA2KSk7XG4vKipcbiAqIFNIQTItNTEyLzIyNCBcInRydW5jYXRlZFwiIGhhc2ggZnVuY3Rpb24sIHdpdGggaW1wcm92ZWQgcmVzaXN0YW5jZSB0byBsZW5ndGggZXh0ZW5zaW9uIGF0dGFja3MuXG4gKiBTZWUgdGhlIHBhcGVyIG9uIFt0cnVuY2F0ZWQgU0hBNTEyXShodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEwLzU0OC5wZGYpLlxuICovXG5leHBvcnQgY29uc3Qgc2hhNTEyXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoKCkgPT4gbmV3IF9TSEE1MTJfMjI0KCksIFxuLyogQF9fUFVSRV9fICovIG9pZE5pc3QoMHgwNSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/hashes/sha2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/hashes/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/@noble/hashes/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   aexists: () => (/* binding */ aexists),\n/* harmony export */   ahash: () => (/* binding */ ahash),\n/* harmony export */   anumber: () => (/* binding */ anumber),\n/* harmony export */   aoutput: () => (/* binding */ aoutput),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   byteSwap: () => (/* binding */ byteSwap),\n/* harmony export */   byteSwap32: () => (/* binding */ byteSwap32),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   clean: () => (/* binding */ clean),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   kdfInputToBytes: () => (/* binding */ kdfInputToBytes),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   oidNist: () => (/* binding */ oidNist),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotl: () => (/* binding */ rotl),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   swap32IfBE: () => (/* binding */ swap32IfBE),\n/* harmony export */   swap8IfBE: () => (/* binding */ swap8IfBE),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes)\n/* harmony export */ });\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nfunction anumber(n, title = '') {\n    if (!Number.isSafeInteger(n) || n < 0) {\n        const prefix = title && `\"${title}\" `;\n        throw new Error(`${prefix}expected integer >= 0, got ${n}`);\n    }\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(value, length, title = '') {\n    const bytes = isBytes(value);\n    const len = value?.length;\n    const needsLen = length !== undefined;\n    if (!bytes || (needsLen && len !== length)) {\n        const prefix = title && `\"${title}\" `;\n        const ofLen = needsLen ? ` of length ${length}` : '';\n        const got = bytes ? `length=${len}` : `type=${typeof value}`;\n        throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n    }\n    return value;\n}\n/** Asserts something is hash */\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash must wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nfunction aoutput(out, instance) {\n    abytes(out, undefined, 'digestInto() output');\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('\"digestInto() output\" expected to be of length >=' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nfunction u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nfunction u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nfunction clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nfunction createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nfunction rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nfunction rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nconst isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nfunction byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nconst swap8IfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** In place byte swap for Uint32Array */\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nconst swap32IfBE = isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nconst nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * Built-in doesn't validate input to be string: we do the check.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nfunction kdfInputToBytes(data, errorTitle = '') {\n    if (typeof data === 'string')\n        return utf8ToBytes(data);\n    return abytes(data, undefined, errorTitle);\n}\n/** Copies several Uint8Arrays into one. */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n/** Merges default options and passed options. */\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options must be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** Creates function with outputLen, blockLen, create properties from a class constructor. */\nfunction createHasher(hashCons, info = {}) {\n    const hashC = (msg, opts) => hashCons(opts).update(msg).digest();\n    const tmp = hashCons(undefined);\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    Object.assign(hashC, info);\n    return Object.freeze(hashC);\n}\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nfunction randomBytes(bytesLength = 32) {\n    const cr = typeof globalThis === 'object' ? globalThis.crypto : null;\n    if (typeof cr?.getRandomValues !== 'function')\n        throw new Error('crypto.getRandomValues must be defined');\n    return cr.getRandomValues(new Uint8Array(bytesLength));\n}\n/** Creates OID opts for NIST hashes, with prefix 06 09 60 86 48 01 65 03 04 02. */\nconst oidNist = (suffix) => ({\n    oid: Uint8Array.from([0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, suffix]),\n});\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0NBQW9DLE1BQU07QUFDMUMsMkJBQTJCLE9BQU8sNkJBQTZCLEVBQUU7QUFDakU7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxNQUFNO0FBQzFDLCtDQUErQyxPQUFPO0FBQ3RELHNDQUFzQyxJQUFJLFlBQVksYUFBYTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUCxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08seUNBQXlDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL2F1dG9wbGFuY2FtLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvdXRpbHMuanM/YWI2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdGllcyBmb3IgaGV4LCBieXRlcywgQ1NQUk5HLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vKiogQ2hlY2tzIGlmIHNvbWV0aGluZyBpcyBVaW50OEFycmF5LiBCZSBjYXJlZnVsOiBub2RlanMgQnVmZmVyIHdpbGwgcmV0dXJuIHRydWUuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIHBvc2l0aXZlIGludGVnZXIuICovXG5leHBvcnQgZnVuY3Rpb24gYW51bWJlcihuLCB0aXRsZSA9ICcnKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMCkge1xuICAgICAgICBjb25zdCBwcmVmaXggPSB0aXRsZSAmJiBgXCIke3RpdGxlfVwiIGA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtwcmVmaXh9ZXhwZWN0ZWQgaW50ZWdlciA+PSAwLCBnb3QgJHtufWApO1xuICAgIH1cbn1cbi8qKiBBc3NlcnRzIHNvbWV0aGluZyBpcyBVaW50OEFycmF5LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFieXRlcyh2YWx1ZSwgbGVuZ3RoLCB0aXRsZSA9ICcnKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBpc0J5dGVzKHZhbHVlKTtcbiAgICBjb25zdCBsZW4gPSB2YWx1ZT8ubGVuZ3RoO1xuICAgIGNvbnN0IG5lZWRzTGVuID0gbGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKCFieXRlcyB8fCAobmVlZHNMZW4gJiYgbGVuICE9PSBsZW5ndGgpKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHRpdGxlICYmIGBcIiR7dGl0bGV9XCIgYDtcbiAgICAgICAgY29uc3Qgb2ZMZW4gPSBuZWVkc0xlbiA/IGAgb2YgbGVuZ3RoICR7bGVuZ3RofWAgOiAnJztcbiAgICAgICAgY29uc3QgZ290ID0gYnl0ZXMgPyBgbGVuZ3RoPSR7bGVufWAgOiBgdHlwZT0ke3R5cGVvZiB2YWx1ZX1gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJlZml4ICsgJ2V4cGVjdGVkIFVpbnQ4QXJyYXknICsgb2ZMZW4gKyAnLCBnb3QgJyArIGdvdCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKiBBc3NlcnRzIHNvbWV0aGluZyBpcyBoYXNoICovXG5leHBvcnQgZnVuY3Rpb24gYWhhc2goaCkge1xuICAgIGlmICh0eXBlb2YgaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBtdXN0IHdyYXBwZWQgYnkgdXRpbHMuY3JlYXRlSGFzaGVyJyk7XG4gICAgYW51bWJlcihoLm91dHB1dExlbik7XG4gICAgYW51bWJlcihoLmJsb2NrTGVuKTtcbn1cbi8qKiBBc3NlcnRzIGEgaGFzaCBpbnN0YW5jZSBoYXMgbm90IGJlZW4gZGVzdHJveWVkIC8gZmluaXNoZWQgKi9cbmV4cG9ydCBmdW5jdGlvbiBhZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG4vKiogQXNzZXJ0cyBvdXRwdXQgaXMgcHJvcGVybHktc2l6ZWQgYnl0ZSBhcnJheSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGFieXRlcyhvdXQsIHVuZGVmaW5lZCwgJ2RpZ2VzdEludG8oKSBvdXRwdXQnKTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImRpZ2VzdEludG8oKSBvdXRwdXRcIiBleHBlY3RlZCB0byBiZSBvZiBsZW5ndGggPj0nICsgbWluKTtcbiAgICB9XG59XG4vKiogQ2FzdCB1OCAvIHUxNiAvIHUzMiB0byB1OC4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1OChhcnIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbn1cbi8qKiBDYXN0IHU4IC8gdTE2IC8gdTMyIHRvIHUzMi4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1MzIoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbn1cbi8qKiBaZXJvaXplIGEgYnl0ZSBhcnJheS4gV2FybmluZzogSlMgcHJvdmlkZXMgbm8gZ3VhcmFudGVlcy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbiguLi5hcnJheXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheXNbaV0uZmlsbCgwKTtcbiAgICB9XG59XG4vKiogQ3JlYXRlIERhdGFWaWV3IG9mIGFuIGFycmF5IGZvciBlYXN5IGJ5dGUtbGV2ZWwgbWFuaXB1bGF0aW9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZpZXcoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xufVxuLyoqIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdHIod29yZCwgc2hpZnQpIHtcbiAgICByZXR1cm4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG59XG4vKiogVGhlIHJvdGF0ZSBsZWZ0IChjaXJjdWxhciBsZWZ0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGwod29yZCwgc2hpZnQpIHtcbiAgICByZXR1cm4gKHdvcmQgPDwgc2hpZnQpIHwgKCh3b3JkID4+PiAoMzIgLSBzaGlmdCkpID4+PiAwKTtcbn1cbi8qKiBJcyBjdXJyZW50IHBsYXRmb3JtIGxpdHRsZS1lbmRpYW4/IE1vc3QgYXJlLiBCaWctRW5kaWFuIHBsYXRmb3JtOiBJQk0gKi9cbmV4cG9ydCBjb25zdCBpc0xFID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0KSgpO1xuLyoqIFRoZSBieXRlIHN3YXAgb3BlcmF0aW9uIGZvciB1aW50MzIgKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlU3dhcCh3b3JkKSB7XG4gICAgcmV0dXJuICgoKHdvcmQgPDwgMjQpICYgMHhmZjAwMDAwMCkgfFxuICAgICAgICAoKHdvcmQgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICAgICAoKHdvcmQgPj4+IDgpICYgMHhmZjAwKSB8XG4gICAgICAgICgod29yZCA+Pj4gMjQpICYgMHhmZikpO1xufVxuLyoqIENvbmRpdGlvbmFsbHkgYnl0ZSBzd2FwIGlmIG9uIGEgYmlnLWVuZGlhbiBwbGF0Zm9ybSAqL1xuZXhwb3J0IGNvbnN0IHN3YXA4SWZCRSA9IGlzTEVcbiAgICA/IChuKSA9PiBuXG4gICAgOiAobikgPT4gYnl0ZVN3YXAobik7XG4vKiogSW4gcGxhY2UgYnl0ZSBzd2FwIGZvciBVaW50MzJBcnJheSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVTd2FwMzIoYXJyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYnl0ZVN3YXAoYXJyW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmV4cG9ydCBjb25zdCBzd2FwMzJJZkJFID0gaXNMRVxuICAgID8gKHUpID0+IHVcbiAgICA6IGJ5dGVTd2FwMzI7XG4vLyBCdWlsdC1pbiBoZXggY29udmVyc2lvbiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX3VpbnQ4YXJyYXlfZnJvbWhleFxuY29uc3QgaGFzSGV4QnVpbHRpbiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gXG4vLyBAdHMtaWdub3JlXG50eXBlb2YgVWludDhBcnJheS5mcm9tKFtdKS50b0hleCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgVWludDhBcnJheS5mcm9tSGV4ID09PSAnZnVuY3Rpb24nKSgpO1xuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIENvbnZlcnQgYnl0ZSBhcnJheSB0byBoZXggc3RyaW5nLiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoaGFzSGV4QnVpbHRpbilcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnRvSGV4KCk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBBOiA2NSwgRjogNzAsIGE6IDk3LCBmOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2gpIHtcbiAgICBpZiAoY2ggPj0gYXNjaWlzLl8wICYmIGNoIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoIC0gYXNjaWlzLl8wOyAvLyAnMicgPT4gNTAtNDhcbiAgICBpZiAoY2ggPj0gYXNjaWlzLkEgJiYgY2ggPD0gYXNjaWlzLkYpXG4gICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuQSAtIDEwKTsgLy8gJ0InID0+IDY2LSg2NS0xMClcbiAgICBpZiAoY2ggPj0gYXNjaWlzLmEgJiYgY2ggPD0gYXNjaWlzLmYpXG4gICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuYSAtIDEwKTsgLy8gJ2InID0+IDk4LSg5Ny0xMClcbiAgICByZXR1cm47XG59XG4vKipcbiAqIENvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5LiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChoYXNIZXhCdWlsdGluKVxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tSGV4KGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjsgLy8gbXVsdGlwbHkgZmlyc3Qgb2N0ZXQsIGUuZy4gJ2EzJyA9PiAxMCoxNiszID0+IDE2MCArIDMgPT4gMTYzXG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8qKlxuICogVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbiAqIENhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuICogbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuICovXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vKiogUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZy4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIHN0cmluZyB0byBieXRlcyB1c2luZyBVVEY4IGVuY29kaW5nLlxuICogQnVpbHQtaW4gZG9lc24ndCB2YWxpZGF0ZSBpbnB1dCB0byBiZSBzdHJpbmc6IHdlIGRvIHRoZSBjaGVjay5cbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBVaW50OEFycmF5LmZyb20oWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZyBleHBlY3RlZCcpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8qKlxuICogSGVscGVyIGZvciBLREZzOiBjb25zdW1lcyB1aW50OGFycmF5IG9yIHN0cmluZy5cbiAqIFdoZW4gc3RyaW5nIGlzIHBhc3NlZCwgZG9lcyB1dGY4IGRlY29kaW5nLCB1c2luZyBUZXh0RGVjb2Rlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtkZklucHV0VG9CeXRlcyhkYXRhLCBlcnJvclRpdGxlID0gJycpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgcmV0dXJuIGFieXRlcyhkYXRhLCB1bmRlZmluZWQsIGVycm9yVGl0bGUpO1xufVxuLyoqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIGFieXRlcyhhKTtcbiAgICAgICAgc3VtICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyoqIE1lcmdlcyBkZWZhdWx0IG9wdGlvbnMgYW5kIHBhc3NlZCBvcHRpb25zLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYge30udG9TdHJpbmcuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBtdXN0IGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuLyoqIENyZWF0ZXMgZnVuY3Rpb24gd2l0aCBvdXRwdXRMZW4sIGJsb2NrTGVuLCBjcmVhdGUgcHJvcGVydGllcyBmcm9tIGEgY2xhc3MgY29uc3RydWN0b3IuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaGVyKGhhc2hDb25zLCBpbmZvID0ge30pIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZShtc2cpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHVuZGVmaW5lZCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgT2JqZWN0LmFzc2lnbihoYXNoQywgaW5mbyk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoaGFzaEMpO1xufVxuLyoqIENyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBQUk5HLiBVc2VzIGludGVybmFsIE9TLWxldmVsIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYC4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgY29uc3QgY3IgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgPyBnbG9iYWxUaGlzLmNyeXB0byA6IG51bGw7XG4gICAgaWYgKHR5cGVvZiBjcj8uZ2V0UmFuZG9tVmFsdWVzICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuIGNyLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xufVxuLyoqIENyZWF0ZXMgT0lEIG9wdHMgZm9yIE5JU1QgaGFzaGVzLCB3aXRoIHByZWZpeCAwNiAwOSA2MCA4NiA0OCAwMSA2NSAwMyAwNCAwMi4gKi9cbmV4cG9ydCBjb25zdCBvaWROaXN0ID0gKHN1ZmZpeCkgPT4gKHtcbiAgICBvaWQ6IFVpbnQ4QXJyYXkuZnJvbShbMHgwNiwgMHgwOSwgMHg2MCwgMHg4NiwgMHg0OCwgMHgwMSwgMHg2NSwgMHgwMywgMHgwNCwgMHgwMiwgc3VmZml4XSksXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/hashes/utils.js\n");

/***/ })

};
;